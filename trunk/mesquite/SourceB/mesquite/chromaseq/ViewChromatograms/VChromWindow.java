/* Mesquite.chromaseq source code.  Copyright 2005 D. Maddison, W. Maddison. Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.chromaseq.ViewChromatograms;import java.io.*;import java.util.*;import java.net.*;import java.awt.*;import java.awt.event.*;import mesquite.lib.*;import mesquite.lib.table.*;import mesquite.lib.characters.*;import mesquite.categ.lib.*;import mesquite.cont.lib.*;import mesquite.chromaseq.lib.*;//Todo: This and contained panels should be within ViewChromatograms as they are designed to be used by only that one module/* ======================================================================== */public class VChromWindow extends MesquiteWindow implements ChromatogramWindow, AdjustmentListener {	int minimumChromatoHeight=0;	Scrollbar hbar;	int centerBase = 0;	String title;	ChromatogramPanel[] chromPanels;	Chromatogram[] chromatograms;	SequencePanel aceContigPanel;	MesquitePanel allChromPanel;	SequencePanel matrixSeqPanel;	OrigImportedSeqPanel origSeqPanel;	MesquitePanel scrollPanel;	Contig contig;	int vMargin = 20;	String sequenceID = null;	Taxon taxon;	MesquiteTable table; //data matrix table	DNAData data;	DNAData originalData;	ContinuousData qualityData;	int scrollDepth = 16;	int spacer = 4;	int defaultWidth = 600;	int defaultHeight = 300;	int seqPanelHeight = 36;	double peakDistance = 20.0;	double horizScale = 1.0;	int bufferHeight = 4;	Panel bufferPanel;	int numSequencePanels = 3;	MatrixSequence originalSequence;	MatrixSequence editedSequence;	MesquiteModule viewModule;	MesquiteBoolean colorByQuality;	MesquiteBoolean fadeLowQuality;	MesquiteBoolean fadeNonSourceRead;	MesquiteBoolean showReadMatrixConflict;	MesquiteBoolean showReadReadConflict;	MesquiteBoolean showLowerQualSourceConflictsWithHigherQualRead;	MesquiteBoolean showReadName;	MesquiteBoolean dimLowQualityConflicts;	MesquiteInteger fadeLowQualityThreshold;	MesquiteInteger dimConflictMarkerThreshold;	MesquiteInteger jumpQualityThreshold;	MesquiteInteger jumpConflictThreshold;	MesquiteBoolean showA;	MesquiteBoolean showC;	MesquiteBoolean showG;	MesquiteBoolean showT;	MesquiteBoolean scrollToTouched = new MesquiteBoolean(false);	MesquiteBoolean showBaseSource = new MesquiteBoolean(true);	MesquiteBoolean showCodonPosition = new MesquiteBoolean(false);	MesquiteBoolean jumpToNextBase = new MesquiteBoolean(false);	MesquiteBoolean jumpToNextReadReadConflict = new MesquiteBoolean(true);	MesquiteBoolean jumpToNextReadMatrixConflict = new MesquiteBoolean(true);	MesquiteBoolean jumpToNextLowQuality = new MesquiteBoolean(true);	MesquiteBoolean jumpToNextAmbiguity = new MesquiteBoolean(true);	MesquiteBoolean jumpToNextBadSourceRead = new MesquiteBoolean(true);	public VChromWindow(MesquiteModule module, MesquiteModule windowServer, MesquiteTable table, CharacterData data, Taxon taxon, String title, Chromatogram[] chroms, Contig contig) {		super(windowServer, false);		this.viewModule = module;		setVisible(false);		setWindowSize(defaultWidth, defaultHeight + scrollDepth+seqPanelHeight);
		windowServer.addMenuItem(null, "Reverse Complement", MesquiteModule.makeCommand("reverseComplement", this));
		windowServer.addMenuItem("Show Matrix", MesquiteModule.makeCommand("showMatrix", this));
		colorByQuality = new MesquiteBoolean(true);		windowServer.addCheckMenuItem(null, "Color By Quality", MesquiteModule.makeCommand("toggleColorByQuality", this), colorByQuality);		fadeLowQuality = new MesquiteBoolean(false);		windowServer.addCheckMenuItem(null, "Fade Low Quality", MesquiteModule.makeCommand("toggleFadeLowQuality", this), fadeLowQuality);		fadeLowQualityThreshold = new MesquiteInteger(20);		windowServer.addMenuItem( "Fade Quality Threshold...", MesquiteModule.makeCommand("setFadeThreshold",  this));		fadeNonSourceRead = new MesquiteBoolean(false);		windowServer.addCheckMenuItem(null, "Fade Non-Source Read", MesquiteModule.makeCommand("toggleFadeNonSourceRead", this), fadeNonSourceRead);		dimLowQualityConflicts = new MesquiteBoolean(true);		windowServer.addMenuLine();		showLowerQualSourceConflictsWithHigherQualRead = new MesquiteBoolean(true);		windowServer.addCheckMenuItem(null, "Show Source Read Conflicts with Higher Quality Read", MesquiteModule.makeCommand("toggleShowLowerQualSourceConflictsWithHigherQualRead", this), showLowerQualSourceConflictsWithHigherQualRead);		showReadMatrixConflict = new MesquiteBoolean(true);		windowServer.addCheckMenuItem(null, "Show Read-Matrix Conflict", MesquiteModule.makeCommand("toggleShowChromMatrixDisagreement", this), showReadMatrixConflict);		showReadReadConflict = new MesquiteBoolean(true);		windowServer.addCheckMenuItem(null, "Show Read-Read Conflict", MesquiteModule.makeCommand("toggleShowReadReadConflict", this), showReadReadConflict);		windowServer.addCheckMenuItem(null, "Dim Conflict Markers if Low Quality", MesquiteModule.makeCommand("toggleDimLowQualityConflicts", this), dimLowQualityConflicts);		dimConflictMarkerThreshold = new MesquiteInteger(30);		windowServer.addMenuItem( "Dim Conflict Marker Threshold...", MesquiteModule.makeCommand("setDimConflictMarkerTheshold",  this));		windowServer.addMenuLine();		showReadName = new MesquiteBoolean(true);		MesquiteSubmenuSpec mss = windowServer.addSubmenu(null, "Show");		showA = new MesquiteBoolean(true);		showC = new MesquiteBoolean(true);		showG = new MesquiteBoolean(true);		showT = new MesquiteBoolean(true);		windowServer.addCheckMenuItemToSubmenu(null, mss, "A Trace", MesquiteModule.makeCommand("toggleShowA",  this), showA);		windowServer.addCheckMenuItemToSubmenu(null, mss, "C Trace", MesquiteModule.makeCommand("toggleShowC",  this), showC);		windowServer.addCheckMenuItemToSubmenu(null, mss, "G Trace", MesquiteModule.makeCommand("toggleShowG",  this), showG);		windowServer.addCheckMenuItemToSubmenu(null, mss, "T Trace", MesquiteModule.makeCommand("toggleShowT",  this), showT);		windowServer.addLineToSubmenu(null,mss);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Base Source", MesquiteModule.makeCommand("toggleShowBaseSource", this), showBaseSource);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Codon Position", MesquiteModule.makeCommand("toggleShowCodonPosition", this), showCodonPosition);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Read Name", MesquiteModule.makeCommand("toggleShowReadName", this), showReadName);			windowServer.addCheckMenuItem(null, "Center Where Touched", MesquiteModule.makeCommand("toggleScrollToTouched", this), scrollToTouched);		MesquiteSubmenuSpec navSubmenu = windowServer.addSubmenu(null, "Arrow Keys");		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Move To Next Base", MesquiteModule.makeCommand("toggleJumpToNextBase",  this), jumpToNextBase);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Source Read Conflicts with Higher Quality Read", MesquiteModule.makeCommand("toggleJumpToNextBadSource",  this), jumpToNextBadSourceRead);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Read-Matrix Conflict", MesquiteModule.makeCommand("toggleJumpToNextReadMatrixConflict",  this), jumpToNextReadMatrixConflict);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Read-Read Conflict", MesquiteModule.makeCommand("toggleJumpToNextConflict",  this), jumpToNextReadReadConflict);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Low Quality", MesquiteModule.makeCommand("toggleJumpToNextLowQuality",  this), jumpToNextLowQuality);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Ambiguity", MesquiteModule.makeCommand("toggleJumpToNextAmbiguity",  this), jumpToNextAmbiguity);		windowServer.addLineToSubmenu(null,navSubmenu);		jumpConflictThreshold = new MesquiteInteger(30);		windowServer.addItemToSubmenu(null, navSubmenu, "Jump Conflict Threshold...", MesquiteModule.makeCommand("setJumpConflictThreshold",  this));		jumpQualityThreshold = new MesquiteInteger(30);		windowServer.addItemToSubmenu(null, navSubmenu, "Jump Quality Threshold...", MesquiteModule.makeCommand("setJumpQualityThreshold",  this));		windowServer.addMenuItem("-",null);		this.title = title;		this.taxon = taxon;		this.table = table;		this.data = (DNAData)data;		this.contig = contig;		chromatograms = chroms;		setAnnotation(taxon.getName() + " (in matrix " + data.getName() + ")", null);		addKeyListener(this);		double totalPeakDistance = 0.0;		allChromPanel = new MesquitePanel();	//	allChromPanel.setBackground(Color.red);		addToWindow(allChromPanel);		if (chroms != null){			chromPanels = new ChromatogramPanel[chroms.length];			for (int i=0; i<chroms.length; i++){				chromPanels[i] = new ChromatogramPanel(chroms[i], this, i);				chromPanels[i].setVisible(true);			//	chromPanels[i].setBackground(Color.blue);				//addToWindow(chromPanels[i]);				allChromPanel.add(chromPanels[i]);				totalPeakDistance+= chroms[i].getAveragePeakDistance();			}			peakDistance = totalPeakDistance/chroms.length;			}		aceContigPanel = new MainConsensusPanel(this, contig);		aceContigPanel.setVisible(true);		aceContigPanel.setShowLowerQualSourceConflictsWithHigherQualRead(true);		addToWindow(aceContigPanel);		Vector links = data.getDataLinkages();		if (links != null){			for (int i=0; i<links.size(); i++){				CharacterData d = (CharacterData)links.elementAt(i);				if (d instanceof DNAData)					originalData = (DNAData)d;				else if(d instanceof ContinuousData)					qualityData = (ContinuousData)d;			}		}		if (originalData != null){				originalSequence =new OrigSequenceImported((MolecularData)data, (MolecularData)originalData, (ContinuousData)qualityData, contig, taxon.getNumber());				origSeqPanel = new OrigImportedSeqPanel(this, originalSequence);				origSeqPanel.setVisible(true);				addToWindow(origSeqPanel);		}		if (originalData == null)			originalData = (DNAData)data;		editedSequence =new EditedMatrixSequence((MolecularData)data, (MolecularData)originalData, (ContinuousData)qualityData,  contig, taxon.getNumber());		matrixSeqPanel = new MatrixSequencePanel(this, editedSequence);		if (originalSequence == null)			originalSequence = editedSequence;		matrixSeqPanel.setVisible(true);		addToWindow(matrixSeqPanel);				bufferPanel = new Panel();//		bufferPanel.setBackground(ColorDistribution.sienna);		bufferPanel.setVisible(true);		addToWindow(bufferPanel);				int numPeaksVisible = getApproximateNumberOfPeaksVisible();		centerBase = numPeaksVisible/2;		scrollPanel = new MesquitePanel();		hbar = new Scrollbar(Scrollbar.HORIZONTAL);		hbar.addAdjustmentListener(this);		hbar.setValues(centerBase,numPeaksVisible,numPeaksVisible/2,getTotalNumPeaks() + numPeaksVisible/2); //Debugg.println("centerBase: " +centerBase + ", numPeaksVisible: " + numPeaksVisible + ", totalPeaks: " + getTotalNumPeaks());		hbar.setUnitIncrement(1);		hbar.setBlockIncrement(1);//		hbar.addKeyListener(this);		scrollPanel.add("South",hbar);		//hbar.setVisible(true);		scrollPanel.setVisible(true);		scrollPanel.setBackground(Color.red);		addToWindow(scrollPanel);				//infoPanel = new InfoPanel(taxon.getName());		//addToWindow(infoPanel);//		sizeDisplays()				ChromatogramTool arrowTool = new ChromatogramTool(this, "arrow", MesquiteModule.getRootImageDirectoryPath(),"arrow.gif", 4,2,"Select", "Selection tool", MesquiteModule.makeCommand("arrowTouch",  this) , MesquiteModule.makeCommand("arrowDrop",  this), null);		arrowTool.setIsArrowTool(true);		setShowAnnotation(true);		setShowExplanation(true);		addTool(arrowTool);  	 	setCurrentTool(arrowTool); 		arrowTool.setInUse(true); 				Associable tInfo = data.getTaxaInfo(false);		trimOffset = 0;		if (tInfo != null && taxon != null) {			int it = taxon.getNumber();			long t =	tInfo.getAssociatedLong(NameReference.getNameReference("startTrim"), it);			if (MesquiteLong.isCombinable(t)) {				trimOffset = (int)t;				int padBeforeTrim = contig.resetPadding(trimOffset, false);				trimOffset -= padBeforeTrim;			}		}		 		resetTitle();		synchChromToTable(true);		sizeDisplays();		hbar.addKeyListener(this);		//setBackground(Color.gray);				}	public void dispose(){		if (originalSequence!=null)				originalSequence.dispose();		if (editedSequence != null)				editedSequence.dispose();		super.dispose();	}	protected ToolPalette makeToolPalette(){		MesquiteCommand sliderCommand = MesquiteModule.makeCommand("magnify", this);		ChromWindowPalette palette = new ChromWindowPalette(ownerModule, this, sliderCommand);				return palette;	}	public DNAData getMatrixData(){		return data;	}	public DNAData getOriginalData(){		return originalData;	}	public ContinuousData getQualityData(){		return qualityData;	}	public int getCenterBase(){		return centerBase;	}	/*.................................................................................................................*/	 public Snapshot getSnapshot(MesquiteFile file) { 	 	Snapshot snapshot = new Snapshot();	 	Snapshot fromWindow = super.getSnapshot(file);	 	snapshot.incorporate(fromWindow,false);	 	snapshot.addLine("toggleColorByQuality  " + colorByQuality.toOffOnString());	 	snapshot.addLine("toggleShowChromMatrixDisagreement  " + showReadMatrixConflict.toOffOnString());	 	snapshot.addLine("toggleShowReadReadConflict  " + showReadReadConflict.toOffOnString());	 	snapshot.addLine("toggleShowLowerQualSourceConflictsWithHigherQualRead  " + showLowerQualSourceConflictsWithHigherQualRead.toOffOnString());	 	snapshot.addLine("toggleFadeLowQuality  " + fadeLowQuality.toOffOnString());	 	snapshot.addLine("toggleFadeNonSourceRead  " + fadeNonSourceRead.toOffOnString());	 	snapshot.addLine("toggleShowReadName  " + showReadName.toOffOnString());	 	snapshot.addLine("toggleDimLowQualityConflicts  " + dimLowQualityConflicts.toOffOnString()); 	 	snapshot.addLine("setFadeThreshold  " + fadeLowQualityThreshold.getValue());	 	snapshot.addLine("setJumpQualityThreshold  " + jumpQualityThreshold.getValue());	 	snapshot.addLine("setJumpConflictThreshold  " + jumpConflictThreshold.getValue());	 	snapshot.addLine("setDimConflictMarkerTheshold " + dimConflictMarkerThreshold.getValue());	 	snapshot.addLine("toggleShowA  " + showA.toOffOnString());	 	snapshot.addLine("toggleShowC " + showC.toOffOnString());	 	snapshot.addLine("toggleShowG " + showG.toOffOnString());	 	snapshot.addLine("toggleShowT " + showT.toOffOnString());	 	snapshot.addLine("toggleScrollToTouched " + scrollToTouched.toOffOnString());	 	snapshot.addLine("toggleShowBaseSource " + showBaseSource.toOffOnString());	 	snapshot.addLine("toggleShowCodonPosition " + showCodonPosition.toOffOnString());	 	snapshot.addLine("toggleJumpToNextBase " + jumpToNextBase.toOffOnString());	 	snapshot.addLine("toggleJumpToNextConflict " + jumpToNextReadReadConflict.toOffOnString());	 	snapshot.addLine("toggleJumpToNextReadMatrixConflict " + jumpToNextReadMatrixConflict.toOffOnString());	 	snapshot.addLine("toggleJumpToNextLowQuality " + jumpToNextLowQuality.toOffOnString());	 	snapshot.addLine("toggleJumpToNextAmbiguity " + jumpToNextAmbiguity.toOffOnString());	 	snapshot.addLine("toggleJumpToNextBadSource " + jumpToNextBadSourceRead.toOffOnString());	 	return snapshot;	 }/*.................................................................................................................*/	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {	 	if (checker.compare(this.getClass(), "Convert selected to gaps", null, commandName, "selectedToGaps")) {					selectedToGaps(); 	 	}	 	else if (checker.compare(this.getClass(), "Revert selected to called", null, commandName, "selectedToCalled")) {					selectedToRevert();	  	 	}	 	else if (checker.compare(this.getClass(), "Magnify chromatograms", null, commandName, "magnify")) {	 				 			MesquiteInteger io = new MesquiteInteger(0);	   			double x= MesquiteDouble.fromString(arguments, io);	   			if (MesquiteDouble.isCombinable(x)){	   					setMagnification(3.0 - x/2);	   					/*(3 - x/2)	   					0 -- 3.0	   					1-- 2.5	   					2 --  2	   					3 -- 1.5	   					4-- 1.0	   					5-- 0.5*/	   			}	 	}	 	else if (checker.compare(this.getClass(), "Reverse Complements this sequence", "[]", commandName, "reverseComplement")) {	 			for (int i=0; i<chromatograms.length; i++){	 				chromatograms[i].reverseComplement(true);	 			}	 			contig.reverseComplement();	 			repaintAll();		 }	 	else if (checker.compare(this.getClass(), "Sets the threshold below which low quality bases will be faded", "[fadeLowQualityThreshold]", commandName, "setFadeThreshold")) {	 		MesquiteInteger pos = new MesquiteInteger(0);	 		int newNum= MesquiteInteger.fromFirstToken(arguments, pos);			 if (!MesquiteInteger.isCombinable(newNum))				 newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Fading Threshold", "Threshold for fading low quality bases:", fadeLowQualityThreshold.getValue(), 0, 100);			 if (newNum>0  && newNum!=fadeLowQualityThreshold.getValue()) {				 fadeLowQualityThreshold.setValue(newNum);				 setFadeQualityThreshold(fadeLowQualityThreshold.getValue());				 repaintAll();			 }		 }	 	else if (checker.compare(this.getClass(), "Sets the quality threshold for arrow keys jumping between low quality bases", "[jumpQualityThreshold]", commandName, "setJumpQualityThreshold")) {	 		MesquiteInteger pos = new MesquiteInteger(0);	 		int newNum= MesquiteInteger.fromFirstToken(arguments, pos);	 		String help = "Holding down the Option or Alt key and using the right and left arrow keys will cause the chromatogram viewer to jump to the next or previous bases in the Phred.Phrap.Mesquite ";	 		help += " sequence of quality less than the jump quality threshold value.  The jump quality threshold is set in this dialog box.";			 if (!MesquiteInteger.isCombinable(newNum))				 newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Jump Quality Threshold", "Jump between bases with quality less than:", help, jumpQualityThreshold.getValue(), 0, 100);			 if (newNum>0  && newNum!=jumpQualityThreshold.getValue()) {				 jumpQualityThreshold.setValue(newNum);			 }		 }	 	else if (checker.compare(this.getClass(), "Sets the quality threshold for arrow keys jumping between bases with conflicting reads", "[jumpConflictThreshold]", commandName, "setJumpConflictThreshold")) {	 		MesquiteInteger pos = new MesquiteInteger(0);	 		int newNum= MesquiteInteger.fromFirstToken(arguments, pos);	 		String help = "Holding down the Control key and using the right and left arrow keys will cause the chromatogram viewer to jump to the next or previous bases in the Phred.Phrap.Mesquite ";	 		help += " sequence in which two reads, both of quality greater than or equal to the jump conflict threshold value, differ in their calls.  The jump conflict threshold is set in this dialog box.";			 if (!MesquiteInteger.isCombinable(newNum))				 newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Jump Conflict Threshold", "Jump between bases with conflict quality greater than:", help, jumpConflictThreshold.getValue(), 0, 100);			 if (newNum>0  && newNum!=jumpConflictThreshold.getValue()) {				 jumpConflictThreshold.setValue(newNum);			 }		 }	 	else if (checker.compare(this.getClass(), "Sets the quality threshold below conflcits will be dimmed", "[dimConflictMarkerThreshold]", commandName, "setDimConflictMarkerTheshold")) {	 		MesquiteInteger pos = new MesquiteInteger(0);	 		int newNum= MesquiteInteger.fromFirstToken(arguments, pos);			 if (!MesquiteInteger.isCombinable(newNum))				 newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Dimming Threshold", "Quality threshold for dimming conflicts:", dimConflictMarkerThreshold.getValue(), 0, 100);			 if (newNum>0  && newNum!=dimConflictMarkerThreshold.getValue()) {				 dimConflictMarkerThreshold.setValue(newNum);				 setDimConflictMarkerThreshold(dimConflictMarkerThreshold.getValue());				 repaintAll();			 }		 }	 	else if (checker.compare(this.getClass(), "Sets whether bases are colored by quality scores", "[on; off]", commandName, "toggleColorByQuality")) {	 			colorByQuality.toggleValue(new Parser().getFirstToken(arguments));	 			setColorByQuality(colorByQuality.getValue());				repaintAll();		 }	 	else if (checker.compare(this.getClass(), "Sets whether reads are dimmed in regions of low quality", "[on; off]", commandName, "toggleFadeLowQuality")) {			fadeLowQuality.toggleValue(new Parser().getFirstToken(arguments));			setFadeLowQuality(fadeLowQuality.getValue());			repaintAll();	 }	 	else if (checker.compare(this.getClass(), "Sets whether reads are dimmed in regions of where they are not the source", "[on; off]", commandName, "toggleFadeNonSourceRead")) {	 		fadeNonSourceRead.toggleValue(new Parser().getFirstToken(arguments));			setFadeNonSourceRead(fadeNonSourceRead.getValue());			repaintAll();	 }	 	else if (checker.compare(this.getClass(), "Sets whether shading indicates whether a chromatogram's call is different from matrix state", "[on; off]", commandName, "toggleShowChromMatrixDisagreement")) {			showReadMatrixConflict.toggleValue(new Parser().getFirstToken(arguments));			setShowReadMatrixConflict(showReadMatrixConflict.getValue());			repaintAll();	 }	 	else if (checker.compare(this.getClass(), "Sets whether bar indicates whether there are differences among the Phred calls for each read.", "[on; off]", commandName, "toggleShowReadReadConflict")) {			showReadReadConflict.toggleValue(new Parser().getFirstToken(arguments));			setShowReadReadConflict(showReadReadConflict.getValue());			repaintAll();	 }	 	else if (checker.compare(this.getClass(), "Sets whether to draw a box around the Phred calls for which the a lower quality read is the source and this conflicts with a higher quality read.", "[on; off]", commandName, "toggleShowLowerQualSourceConflictsWithHigherQualRead")) {	 		showLowerQualSourceConflictsWithHigherQualRead.toggleValue(new Parser().getFirstToken(arguments));			setShowLowerQualSourceConflictsWithHigherQualRead(showLowerQualSourceConflictsWithHigherQualRead.getValue());			repaintAll();	 }	 	else if (checker.compare(this.getClass(), "Sets whether the name of the read is shown", "[on; off]", commandName, "toggleShowReadName")) {			showReadName.toggleValue(new Parser().getFirstToken(arguments));			setShowReadName(showReadName.getValue());			repaintAll();	 }	 	else if (checker.compare(this.getClass(), "Sets whether the red boxes for low quality conflicts are dimmed below the bases in the Phred.Phrap.Mesquite listing", "[on; off]", commandName, "toggleDimLowQualityConflicts")) {			dimLowQualityConflicts.toggleValue(new Parser().getFirstToken(arguments));			setDimLowQualityConflicts(dimLowQualityConflicts.getValue());			repaintAll();	 }	 	else if (checker.compare(this.getClass(), "Sets whether the A trace is shown", "[on; off]", commandName, "toggleShowA")) {			showA.toggleValue(new Parser().getFirstToken(arguments)); 			if (chromPanels!=null)				for (int i = 0; i<chromPanels.length; i++)				 chromPanels[i].setShowA(showA.getValue());			repaintAll();	 }	 	else if (checker.compare(this.getClass(), "Sets whether the C trace is shown", "[on; off]", commandName, "toggleShowC")) {			showC.toggleValue(new Parser().getFirstToken(arguments));			if (chromPanels!=null)				for (int i = 0; i<chromPanels.length; i++)				 chromPanels[i].setShowC(showC.getValue());			repaintAll();	 }	 	else if (checker.compare(this.getClass(), "Sets whether the G trace is shown", "[on; off]", commandName, "toggleShowG")) {			showG.toggleValue(new Parser().getFirstToken(arguments));			if (chromPanels!=null)				for (int i = 0; i<chromPanels.length; i++)				 chromPanels[i].setShowG(showG.getValue());			repaintAll();	 }	 	else if (checker.compare(this.getClass(), "Sets whether the T trace is shown", "[on; off]", commandName, "toggleShowT")) {			showT.toggleValue(new Parser().getFirstToken(arguments));			if (chromPanels!=null)				for (int i = 0; i<chromPanels.length; i++)				 chromPanels[i].setShowT(showT.getValue());			repaintAll();	 }	 	else if (checker.compare(this.getClass(), "Sets whether the T trace is shown", "[on; off]", commandName, "toggleShowT")) {			showT.toggleValue(new Parser().getFirstToken(arguments));			if (chromPanels!=null)				for (int i = 0; i<chromPanels.length; i++)				 chromPanels[i].setShowT(showT.getValue());			repaintAll();	 }	 	else if (checker.compare(this.getClass(), "Sets whether touching on the chromatograms centers the view to that base", "[on; off]", commandName, "toggleScrollToTouched")) {			scrollToTouched.toggleValue(new Parser().getFirstToken(arguments));			if (chromPanels!=null)				for (int i = 0; i<chromPanels.length; i++)				 chromPanels[i].setScrollToTouched(scrollToTouched.getValue());			repaintAll();	 }	 	else if (checker.compare(this.getClass(), "Sets whether the source of the base (that is, the read Phrap chose as the primary one fro that base) is marked by a brown bar", "[on; off]", commandName, "toggleShowBaseSource")) {			showBaseSource.toggleValue(new Parser().getFirstToken(arguments));			if (chromPanels!=null)				for (int i = 0; i<chromPanels.length; i++)				 chromPanels[i].setShowBaseSource(showBaseSource.getValue());			repaintAll();	 }	 	else if (checker.compare(this.getClass(), "Sets whether the codon position of a base is indicated by color", "[on; off]", commandName, "toggleShowCodonPosition")) {			showCodonPosition.toggleValue(new Parser().getFirstToken(arguments));			if (chromPanels!=null)				for (int i = 0; i<chromPanels.length; i++)				 chromPanels[i].setShowCodonPosition(showCodonPosition.getValue());			repaintAll();	 }	 	else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next problem base", "[on; off]", commandName, "toggleJumpToNextBadSource")) {			jumpToNextBadSourceRead.toggleValue(new Parser().getFirstToken(arguments));			if (jumpToNextBadSourceRead.getValue()) {				jumpToNextBase.setValue(false);			}	 }	 	else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next base", "[on; off]", commandName, "toggleJumpToNextBase")) {			jumpToNextBase.toggleValue(new Parser().getFirstToken(arguments));			if (jumpToNextBase.getValue()) {				jumpToNextReadReadConflict.setValue(false);				jumpToNextLowQuality.setValue(false);				jumpToNextReadMatrixConflict.setValue(false);				jumpToNextAmbiguity.setValue(false);				jumpToNextBadSourceRead.setValue(false);			}	 }	 	else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next low quality base", "[on; off]", commandName, "toggleJumpToNextLowQuality")) {	 		jumpToNextLowQuality.toggleValue(new Parser().getFirstToken(arguments));			if (jumpToNextLowQuality.getValue()) {				jumpToNextBase.setValue(false);			}	 }	 	else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next read-read conflict", "[on; off]", commandName, "toggleJumpToNextConflict")) {	 		jumpToNextReadReadConflict.toggleValue(new Parser().getFirstToken(arguments));			if (jumpToNextReadReadConflict.getValue()) {				jumpToNextBase.setValue(false);			}	 }	 	else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next read-matrix conflict", "[on; off]", commandName, "toggleJumpToNextReadMatrixConflict")) {	 		jumpToNextReadMatrixConflict.toggleValue(new Parser().getFirstToken(arguments));			if (jumpToNextReadMatrixConflict.getValue()) {				jumpToNextBase.setValue(false);			}	 }	 	else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next matrix value with an IUPAC ambiguity code", "[on; off]", commandName, "toggleJumpToNextAmbiguity")) {	 		jumpToNextAmbiguity.toggleValue(new Parser().getFirstToken(arguments));			if (jumpToNextAmbiguity.getValue()) {				jumpToNextBase.setValue(false);			}	 }	 	else if (checker.compare(this.getClass(), "Shows the matrix", null, commandName, "showMatrix")) {	 		Frame f = ownerModule.getEmployer().containerOfModule();	 		if (f!= null)	 			f.show();	 }		else	 		return super.doCommand(commandName, arguments, commandRec, checker);	 	return null;	 }	//for coordinating selection	 int firstTouched = MesquiteInteger.unassigned;	 int secondTouched = MesquiteInteger.unassigned;	public void setFirstTouchedOverall(int ic){		firstTouched = ic;	}	public int getFirstTouchedOverall(){		return firstTouched;	}	public int getFirstTouchedConsensus(){		if (!MesquiteInteger.isCombinable(firstTouched))			return firstTouched;		int c =  getConsensusBaseFromOverallBase(firstTouched);		if (c <0)			return 0;		return c;	}public void setSecondTouchedOverall(int ic){		secondTouched = ic;	}	public int getSecondTouchedOverall(){		return secondTouched;	}	public int getSecondTouchedConsensus(){		if (!MesquiteInteger.isCombinable(secondTouched))			return secondTouched;		int c =  getConsensusBaseFromOverallBase(secondTouched);		if (c <0)			return 0;		return c;	}		/*...............................................................................................................*/   	public String getContigDisplayExplanation (int consensusBase){   		StringBuffer sb = new StringBuffer();   		sb.append("Consensus Base Quality: " + contig.getQualityOfBase(consensusBase));  		if (showReadReadConflict.getValue())   			sb.append("\nRed/pink bar: two reads conflict. ");    	if (showLowerQualSourceConflictsWithHigherQualRead.getValue())   			sb.append("Box: source read is notably lower quality than other read. ");   		return sb.toString();   	}	/*.................................................................................................................*/	public void setShowReadName(boolean showReadName) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setShowReadName(showReadName);			}	}	/*.................................................................................................................*/	public void setShowBaseNumberWithinRead(boolean showBaseNumberWithinRead) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setShowBaseNumberWithinRead(showBaseNumberWithinRead);			}	}	/*.................................................................................................................*/	public void setShowReadMatrixConflict(boolean show) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setShowReadMatrixConflict(show);			}	}	/*.................................................................................................................*/	public void setShowReadReadConflict(boolean show) {		if (aceContigPanel!=null)			aceContigPanel.setShowReadReadConflict(show);	}	/*.................................................................................................................*/	public void setShowLowerQualSourceConflictsWithHigherQualRead(boolean show) {		if (aceContigPanel!=null)			aceContigPanel.setShowLowerQualSourceConflictsWithHigherQualRead(show);	}			/*.................................................................................................................*/	public void setDimConflictMarkerThreshold(int dimConflictMarkerThreshold) {		if (contig!=null)			contig.setDimConflictMarkerThreshold(dimConflictMarkerThreshold);		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setDimConflictMarkerThreshold(dimConflictMarkerThreshold);			}	}	/*.................................................................................................................*/	public void setDimLowQualityConflicts(boolean dimLowQualityConflicts) {		if (contig!=null)			contig.setDimLowQualityConflicts(dimLowQualityConflicts);		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setDimLowQualityConflicts(dimLowQualityConflicts);			}	}	/*.................................................................................................................*/	public void setFadeLowQuality(boolean fadeLowQuality) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setFadeLowQuality(fadeLowQuality);			}	}	/*.................................................................................................................*/	public void setFadeNonSourceRead(boolean fadeNonSourceRead) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setFadeNonSourceRead(fadeNonSourceRead);			}	}		/*.................................................................................................................*/	public void setFadeQualityThreshold(int fadeQualityThreshold) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setFadeQualityThreshold(fadeQualityThreshold);			}	}	/*.................................................................................................................*/	public void setColorByQuality(boolean cbQ) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setColorByQuality(cbQ);			}		if (aceContigPanel!=null)			aceContigPanel.setColorByQuality(cbQ);		if (matrixSeqPanel!=null)			matrixSeqPanel.setColorByQuality(cbQ);		if (origSeqPanel!=null)				origSeqPanel.setColorByQuality(cbQ);	}	/*.................................................................................................................*/	public boolean getColorByQuality() {		return colorByQuality.getValue();	}	/*.................................................................................................................*/	public double getHorizScale() {		return horizScale;	}	/*.................................................................................................................*/	public double getAveragePeakDistance() {		return (peakDistance * getHorizScale());	}	/*.................................................................................................................*/	public int getApproximateNumberOfPeaksVisible() {		if (getAveragePeakDistance()<=0)			return 0;		else			return (int)(getBounds().width/getAveragePeakDistance());	}	/*.................................................................................................................*/	/** Returns the number of pixels the window is scrolled */	public int getCenterPixelFromCenterBase(int centerBase){		return (int)((centerBase)*getAveragePeakDistance());	}	/*.................................................................................................................*/	/** Returns the base number within the consensus sequence at the base baseNumber (which is numbered from the beginning, including excess bases at the start).   */	public int getConsensusBaseFromOverallBase(int baseNumber){		if (!MesquiteInteger.isCombinable(baseNumber))			return baseNumber;		return baseNumber-contig.getReadExcessAtStart();	}	/*.................................................................................................................*/	public int getOverallBaseFromConsensusBase(int baseNumber){		if (!MesquiteInteger.isCombinable(baseNumber))			return baseNumber;		return baseNumber+contig.getReadExcessAtStart();	}	/*.................................................................................................................*/	public int getTotalNumPeaks() {		int numPeaks = contig.getNumBases() + contig.getReadExcessAtStart()+ contig.getReadExcessAtEnd();//Debugg.println("|||| totalNumPeaks: " + numPeaks + ", numBases: " + contig.getNumBases()+ ", excessAtStart: " + contig.getReadExcessAtStart()+ ", excessAtEnd: " + contig.getReadExcessAtEnd());		return numPeaks;	}	/*.................................................................................................................*/	public Contig getContig() {		return contig;	}	/*.................................................................................................................*/	public int getHorizontalPixels(int pixels) {		return (int)(pixels * getHorizScale());	}	/*.................................................................................................................*/	public Color getBaseColor(char c) {		Color color = Color.black;		switch (c) {			case 'A':			color = Color.green;			break;			case 'C':			color = Color.blue;			break;			case 'G':			color = Color.black;			break;			case 'T':			color = Color.red;			break;			case 'a':			color = Color.green;			break;			case 'c':			color = Color.blue;			break;			case 'g':			color = Color.black;			break;			case 't':			color = Color.red;			break;			case '-':			color = Color.gray;			break;			case '*':			color = Color.gray;			break;			default:			color = Color.darkGray;		}		return color;	}	public static String findOrigName(String[] fileNamesTranslator, String changedName){		if (fileNamesTranslator == null || changedName == null)			return changedName;		for (int i = 0; i*2+1<fileNamesTranslator.length; i++){			if (changedName.equals(fileNamesTranslator[i*2]))				return fileNamesTranslator[i*2+1];		}		return changedName;	}	/*.................................................................................................................*/   	public static VChromWindow showChromatogram(String[] paths, String[] fileNames, Contig contig, Read[] reads, MesquiteTable table, DNAData matrixData, Taxon taxon, MesquiteModule windowServer, MesquiteModule ownerModule, CommandRecord commandRec){						if (paths==null  || fileNames==null)			return null;		if (windowServer == null)			return null;		try {			Chromatogram[] chromatograms = new Chromatogram[paths.length];			Associable as = matrixData.getTaxaInfo(false);			String[] fileNamesTranslator = null;			if (as != null)				fileNamesTranslator = (String[])as.getAssociatedObject(NameReference.getNameReference("readFileNames"), taxon.getNumber());			for (int i = 0; i<paths.length; i++){ //getting chromatograms from all of the reads				File file = new File(paths[i].toString(), fileNames[i].toString());				FileInputStream regIN = new FileInputStream(file);;				BufferedInputStream fileIN = new BufferedInputStream(regIN);				byte[] magicNumArray = new byte[4];				fileIN.read(magicNumArray);				ByteArrayInputStream magicIN = new ByteArrayInputStream(magicNumArray);				DataInputStream magicDIN = new DataInputStream(magicIN);				int magicNum = magicDIN.readInt();				magicIN.reset();				SequenceInputStream seqIN = new SequenceInputStream(magicIN,fileIN);											if (magicNum == ABIChromatogram.MagicNum) {					chromatograms[i] = new ABIChromatogram(seqIN,reads[i]);					}				else if (magicNum == SCFChromatogram.MagicNum) {					chromatograms[i] = new SCFChromatogram(seqIN, reads[i]);				}				else throw new IOException("Unknown file type");								if (chromatograms[i]!=null) {					String origName = findOrigName(fileNamesTranslator, fileNames[i]);					if (origName != null)						chromatograms[i].setTitle(origName.toString());					else						chromatograms[i].setTitle("Read " + (i+1));//chromatograms[i].report("");					if (reads[i].getComplemented())						chromatograms[i].reverseComplement(false);									}							}			VChromWindow cw = new VChromWindow(ownerModule, windowServer, table, matrixData, taxon,"Chromatograms: " + taxon.getName(), chromatograms, contig); 			windowServer.setModuleWindow(cw);			if (!commandRec.scripting())				cw.setVisible(true);			ownerModule.hireAllEmployees(commandRec, ChromInit.class);			SequencePanel[] sequences = new SequencePanel[]{cw.aceContigPanel, cw.origSeqPanel, cw.matrixSeqPanel};			for (int i=0; i< ownerModule.getEmployeeVector().size(); i++){				 Object e = ownerModule.getEmployeeVector().elementAt(i);				 if (e instanceof ChromInit){					 ((ChromInit)e).setWindow(cw);					 ((ChromInit)e).setContext(taxon, contig, reads, sequences, (DNAData)matrixData, cw.getOriginalData(), cw.getQualityData(), table);				 }			}			windowServer.resetContainingMenuBar();			MesquiteModule.resetAllWindowsMenus();			return cw;					}		catch (MalformedURLException ex) {			System.out.println("Malformed URL");		}		catch (IOException ex) {			String exMessage = ex.getMessage();			String exName = ex.getClass().getName();			System.out.println("IO ERROR: " + exName + " : " + exMessage);		}		return null;	}		/*.................................................................................................................*/	/** When called the window will determine its own title.  MesquiteWindows need	to be self-titling so that when things change (names of files, tree lists, etc.)	they can reset their titles properly*/	public void resetTitle(){		setTitle(title);	}	 private void setMagnification(double mag){		 for (int i = 0; i<chromPanels.length; i++){			 chromPanels[i].setMagnification(mag);		 }	 } 	 /*--------------------------------------*/	public int getChromAreaHeight(){		int totalHeight = getHeight();		return totalHeight-scrollDepth - seqPanelHeight*numSequencePanels - bufferHeight;	}  	 /*--------------------------------------*/	/* Resize the chromatogram area and other components.*/	public void sizeDisplays(){		if (scrollPanel!=null)			scrollPanel.setVisible(false);		int border = 2;		int totalWidth = getWidth();//		int totalHeight = getHeight();		if (chromPanels==null)			return;		int chromatoHeight = MesquiteInteger.maximum(minimumChromatoHeight,getChromAreaHeight()/chromPanels.length) ;		allChromPanel.setBounds(border,0, totalWidth-border*2, getChromAreaHeight() - spacer);		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].setBounds(border,i*chromatoHeight, totalWidth-border*2, chromatoHeight - spacer );			// chromPanels[i].setVisible((i+2)*chromatoHeight<getChromAreaHeight()+spacer+1 || i==0);		}		bufferPanel.setBounds(border,getChromAreaHeight(),totalWidth-border*2,bufferHeight);				aceContigPanel.setBounds(border,getChromAreaHeight()+ bufferHeight,totalWidth-border*2 ,seqPanelHeight);		if (origSeqPanel!=null)			origSeqPanel.setBounds(border,getChromAreaHeight()+seqPanelHeight + bufferHeight,totalWidth-border*2,seqPanelHeight);		matrixSeqPanel.setBounds(border,getChromAreaHeight()+seqPanelHeight*2 + bufferHeight,totalWidth-border*2,seqPanelHeight);		if (scrollPanel!=null) {			scrollPanel.setBounds(border,getChromAreaHeight()+seqPanelHeight*numSequencePanels + bufferHeight,totalWidth-border*2,scrollDepth);			hbar.setBounds(0,0,totalWidth-border*2,scrollDepth);			scrollPanel.setVisible(true);		}	}	 	public SequencePanel getSequencePanel(int whichPanel){	 		if (whichPanel == 0)	 				return aceContigPanel;	 		else if (whichPanel == 1)	 				return origSeqPanel;	 		else if (whichPanel == 2)	 				return matrixSeqPanel;	 		return null;	 	}   	 /*--------------------------------------*/	/*Sets the size of the window (setSize and setBounds should not be used!!!>  <b>(overrides method of MesquiteWindow)</b>*/	public void setWindowSize(int w, int h){		super.setWindowSize(w,h);		sizeDisplays();		if (hbar != null){			int numPeaksVisible = getApproximateNumberOfPeaksVisible();			hbar.setValues(centerBase,numPeaksVisible,numPeaksVisible/2,getTotalNumPeaks() + numPeaksVisible/2);// - numPeaksVisible -1);			hbar.setBlockIncrement(numPeaksVisible);		}	}	/*--------------------------------------*/	/* Called when the window has been resized, e.g. by user. <b>(overrides method of MesquiteWindow)</b>*/	public void windowResized(){		sizeDisplays();	}	/*--------------------------------------*/	/** Moves the chromatogram panels over so that the center line is at consensus base ic.  	 * Do NOT use this to scroll to that base, as this does not set the scroll bar	 * */	public void centerPanelsAtConsensusPosition(int ic){		centerPanelsAtOverallPosition(getOverallBaseFromConsensusBase(ic));	}	/*--------------------------------------*/	/** Moves the chromatogram panels over so that the center line is at overall base ic.  	 * Do NOT use this to scroll to that base, as this does not set the scroll bar	 * */	public void centerPanelsAtOverallPosition(int ic){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].centerPanelAtOverallPosition(ic);  		}		aceContigPanel.centerPanelAtOverallPosition(ic);		matrixSeqPanel.centerPanelAtOverallPosition(ic);		if (origSeqPanel!=null)			origSeqPanel.centerPanelAtOverallPosition(ic);		centerBase = ic;	}		public int getHomePositionInMatrix(){		return getMatrixPositionOfConsensusPosition(getConsensusBaseFromOverallBase(centerBase), originalData);	}	 /*--------------------------------------*/	 public void focusMatrixOn(int ic1, int ic2){  //ic1 is the first touched read base (NOT consensus base); ic2 is the last touched base		if (taxon == null || table == null)			return;		int it = taxon.getNumber();//Debugg.println("  ic1 (first touched): " + ic1 + ", ic2 (second touched): " + ic2);		if (!MesquiteInteger.isCombinable(ic1) && !MesquiteInteger.isCombinable(ic2))  // they are both unassigned, bail			return;		else if (MesquiteInteger.isCombinable(ic1) && ic1<0 && ic2<0)  // they are both <0, and so we don't want to move the matrix here			return;		else if (!MesquiteInteger.isCombinable(ic2) || (ic2<0) ||  ic2 == ic1){   // ic2 hasn't been assigned, or ic1 and ic2 are both positive and assigned			int matrix1 = getMatrixPositionOfConsensusPosition(ic1, originalData);//Debugg.println("   matrix1 " + matrix1 + ", ic1: " + ic1);				table.setFocusedCell(getMatrixPositionOfConsensusPosition(ic1, originalData), it);		}		else {  //both are unassigned, and at least one is positive			int matrix1 = getMatrixPositionOfConsensusPosition(ic1, originalData);//Debugg.println("   matrix1 " + matrix1 + ", ic1: " + ic1);			table.setFocusedSequence(getMatrixPositionOfConsensusPosition(ic1, originalData), getMatrixPositionOfConsensusPosition(ic2, originalData), it);		}	}	 /*--------------------------------------*/	 /**This synchs the chromatogram viewer to the selections currently in the Matrix Editor */	public void synchChromToTable(boolean synchPosition){		if (!listen)			return;			if (!table.anyCellSelectedAnyWay())				return;		if (taxon == null || table == null)			return;		int it = taxon.getNumber();		boolean changed = false;		int firstSel = -1;		int lastSel = -1;		boolean blockEnded = true;				for (int overallBase =0; overallBase<getTotalNumPeaks(); overallBase++) { 				int consensusBase = getConsensusBaseFromOverallBase(overallBase);			int mPos = getMatrixPositionOfConsensusPosition(consensusBase, originalData);			boolean sel = table.isCellSelectedAnyWay(mPos, it);			if (sel) {				if (blockEnded){					firstSel = -1;					lastSel = -1;				}				if (firstSel == -1)					firstSel = overallBase;				lastSel = overallBase;				blockEnded = false;			} 			else if (firstSel != -1){				blockEnded = true;			}						changed = setSelectedConsensusPositionInChrom(consensusBase, sel, false) || changed ;		}		if (changed && synchPosition && firstSel >= 0 && lastSel >= 0)			scrollToOverallBase((firstSel + lastSel)/2);		if (changed)			repaintPanels();	}	 /*--------------------------------------*/	 /**This synchs the chromatogram viewer to the selections currently in the Matrix Editor */	public void matrixChanged(boolean synchPosition){		synchChromToTable(synchPosition);		repaintPanels();	}		/*--------------------------------------*/	public boolean getSelectedAnyChromatogram(int overallBase){		for (int i=0; i<chromPanels.length; i++){			if (chromPanels[i].getSelected(overallBase))				return true;		}		return false;	}	/*--------------------------------------*/	public void synchTableToChrom(boolean synchPosition){		if (!listen)			return;		if (taxon == null || table == null)			return;		int it = taxon.getNumber();		boolean changed = false;		int firstSel = -1;		int lastSel = -1;		boolean blockEnded = true;				for (int overallBase =0; overallBase<getTotalNumPeaks(); overallBase++) { 			boolean sel = getSelectedAnyChromatogram(overallBase);			int consensusBase = getConsensusBaseFromOverallBase(overallBase);						int mPos = getMatrixPositionOfConsensusPosition(consensusBase, originalData); //Wayne: use this to then select table			if (sel) {				if (blockEnded){					firstSel = -1;					lastSel = -1;				}				if (firstSel == -1)					firstSel = overallBase;				lastSel = overallBase;				blockEnded = false;			} 			else if (firstSel != -1){				blockEnded = true;			}						changed = setSelectedConsensusPositionInChrom(consensusBase, sel, false) || changed ;				}		if (changed && synchPosition && firstSel >= 0 && lastSel >= 0)			scrollToOverallBase((firstSel + lastSel)/2);		if (changed)			repaintPanels();	}	 /*--------------------------------------*/	private void selectedToGaps(){			if (taxon == null)					return;			int it = taxon.getNumber();			for (int ic = 0; ic< getTotalNumPeaks(); ic++){				if (getSelectedConsensusPositionInChrom(ic))					((DNAData)data).setState(getMatrixPositionOfConsensusPosition(ic, originalData), it, CategoricalState.inapplicable);			}			data.notifyListeners(this, new Notification(CharacterData.DATA_CHANGED, null));			matrixSeqPanel.repaintPanel();	}	 /*--------------------------------------*/	private void selectedToRevert(){			if (taxon == null)					return;			int it = taxon.getNumber();			for (int ic = 0; ic< getTotalNumPeaks(); ic++){				if (getSelectedConsensusPositionInChrom(ic)){					int icc = getMatrixPositionOfConsensusPosition(ic, originalData);					((DNAData)data).setState(icc, it, ((DNAData)originalData).getStateRaw(icc, it));				}			}			data.notifyListeners(this, new Notification(CharacterData.DATA_CHANGED, null));			matrixSeqPanel.repaintPanel();	}	 /*--------------------------------------*/	/** This returns the horizontal position, in pixels, of consensus site ic  */	public int getFullPixelValueOfConsensusBase(int ic){		int basesFromLeftSide = ic+getContig().getReadExcessAtStart();   // now adjust for the fact that the consensus sequence may not start at 0, 																							// as there may be excess on the left		return (int)(basesFromLeftSide*getAveragePeakDistance());	}	 /*--------------------------------------*/	public long getMatrixStateLongAtConsensusPosition(int ic){		if (taxon == null)				return '-';		int icM = getMatrixPositionOfConsensusPosition(ic);		int it = taxon.getNumber();			return data.getState(icM, it);	}	 /*--------------------------------------*/	public char getMatrixStateAtConsensusPosition(int ic){		if (taxon == null)				return '-';		int icM = getMatrixPositionOfConsensusPosition(ic);		int it = taxon.getNumber();			return DNAData.getIUPACChar(data.getState(icM, it));	}	 /*--------------------------------------*/	/** This returns the number of padded bases before consensus site ic  */	public int getNumPaddedBeforeConsensusBase(int ic){		return getContig().getNumPaddedBefore(ic);	}	 /*--------------------------------------*/	/** This returns the number of  bases inserted into the matrix between consensus site ic-1 and ic  */	public int getNumInsertedBeforeConsensusBase(int ic){		if (ic <= 0)			return 0;		int icmBefore = getMatrixPositionOfConsensusPosition(ic-1);		int icmAfter = getMatrixPositionOfConsensusPosition(ic);		if (icmAfter-icmBefore <=1)			return 0;		if (taxon == null)				return 0;		int it = taxon.getNumber();				int count = 0;		for (int i = icmBefore +1; i< icmAfter; i++){			if (!data.isInapplicable(i, it))				count++;		}		return count;	}	 /*--------------------------------------*/	/** This returns the number of  bases inserted into the matrix between consensus site ic-1 and ic  */	public int getNumInsertedAfterConsensusBase(int ic){		if (ic <= 0)			return 0;		int icmBefore = getMatrixPositionOfConsensusPosition(ic);		int icmAfter = getMatrixPositionOfConsensusPosition(ic+1);		if (icmAfter-icmBefore <=1)			return 0;		if (taxon == null)				return 0;		int it = taxon.getNumber();				int count = 0;		for (int i = icmBefore +1; i< icmAfter; i++){			if (!data.isInapplicable(i, it))				count++;		}		return count;	}	public int getSpaceInsertedAfterConsensusBase(int ic){			int numInserted = getNumInsertedAfterConsensusBase(ic);			if (numInserted>0)				return (int)(getAveragePeakDistance()*numInserted);			return 0;	}	public int getSpaceInsertedBeforeConsensusBase(int ic){			int numInserted = getNumInsertedBeforeConsensusBase(ic);			if (numInserted>0)				return (int)(getAveragePeakDistance()*numInserted);			return 0;	}	public int getTotalSpaceInsertedBeforeConsensusBase(int ic){		int total = 0;		for (int i = 0; i<=ic; i++){			total+= getNumInsertedBeforeConsensusBase(i);		}		return (int)(total*getAveragePeakDistance());	}		private int getConsensusFromUnpadded(int ic){		return getContig().getPaddedSiteFromUnpaddedSite(ic);	}/*--------------------------------------*/	 /** This should return for overall site ic what codon position the site is. */	public int  getCodonPositionOfOverallBase(int overallBase){		if (data==null)			return 0;		int consensusBase = getConsensusBaseFromOverallBase(overallBase);		int matrixCharacter = getMatrixPositionOfConsensusPosition(consensusBase, data);		if (matrixCharacter>=0 && matrixCharacter<data.getNumChars())			return data.getCodonPosition(matrixCharacter);		else			return 0;	}	/*--------------------------------------*/	public int getMatrixPositionOfConsensusPosition(int consensusBase){		return getMatrixPositionOfConsensusPosition(consensusBase, originalData);	}	 /** This should return for consensus site ic what character in matrix it corresponds to.  	 * This is needed in case the sequence has been aligned,	* and thus is not left justified and contiguous.  It also accounts for the trimming that is done in going from 	* the consensus (i.e., main contig) sequence to the sequence in the matrix. */	public int getMatrixPositionOfConsensusPosition(int consensusBase, DNAData data){	//	if (true)	/*		return getMatrixPositionOfPaddedConsensusPosition(consensusBase, data);		if (trimOffset<0){			Associable tInfo = data.getTaxaInfo(false);			trimOffset = 0;			if (tInfo != null && taxon != null) {				int it = taxon.getNumber();				long t =	tInfo.getAssociatedLong(NameReference.getNameReference("startTrim"), it);				if (MesquiteLong.isCombinable(t)) {					trimOffset = (int)t;				}			}		}		*/		int sequencePosition = consensusBase - trimOffset - getNumPaddedBeforeConsensusBase(consensusBase);	//Debugg.println("sequencePosition consensusBase " + consensusBase + " trimOffset "  + trimOffset);		if (taxon != null)			return originalSequence.matrixBaseFromSequenceBase(sequencePosition);		return sequencePosition;	}	public int getConsensusPositionOfMatrixPosition(int ic){		return getConsensusPositionOfMatrixPosition(ic, originalData);	}	/*--------------------------------------*/	/*@@@@@@@@@This should return for character ic in matrix/table, what is the position in the consensus.  This is needed in case the sequence has been aligned,	and thus is not left justified and contiguous.  This has access to both the data and table @@@@@@@@@@@*/	public int getConsensusPositionOfMatrixPosition(int ic, DNAData data){		//if (true)		//	return getPaddedConsensusPositionOfMatrixPosition(ic, data);		int sequencePosition = ic;		if (taxon != null){			sequencePosition = originalSequence.sequenceBaseFromMatrixBase(ic);		}		/*		if (trimOffset<0){			Associable tInfo = data.getTaxaInfo(false);			trimOffset = 0;			if (tInfo != null && taxon != null) {				int it = taxon.getNumber();				long t =	tInfo.getAssociatedLong(NameReference.getNameReference("startTrim"), it);				if (MesquiteLong.isCombinable(t)) {					trimOffset = (int)t;				}			}		}		*/		return getConsensusFromUnpadded(sequencePosition + trimOffset); // + trimOffset;	} 	 /*--------------------------------------*/	int trimOffset = -1;static boolean listen = true; //static because all windows need to stop listening momentarily  	 /*--------------------------------------*/	 /*This uses indices as in consensus*/	public boolean getSelectedConsensusPositionInChrom(int ic){		return matrixSeqPanel.getSelectedConsensus(ic);	}	public boolean getSelectedOverallBase(int overallBase) {		return chromPanels[0].getSelected(overallBase);	}	   	 /*This uses indices as in consensus*/	public boolean setSelectedConsensusPositionInChrom(int ic, boolean sel, boolean repnt){		if (!listen)			return false;		boolean changed = false;		for (int i=0; i<chromPanels.length; i++){			changed = chromPanels[i].selectConsensusPositionInChrom(ic, sel, repnt) || changed;		}		changed = aceContigPanel.setSelectedConsensus(ic, sel, repnt) || changed;		changed = matrixSeqPanel.setSelectedConsensus(ic, sel, repnt) || changed;		if (origSeqPanel!=null)			changed = origSeqPanel.setSelectedConsensus(ic, sel, repnt) || changed;		return changed;	}    /*--------------------------------------*/	//this is consensus position	public void selectConsensusPositionInTable(int i){		listen = false;		if (taxon != null && table != null){			int ic = getMatrixPositionOfConsensusPosition(i, originalData);			int it = taxon.getTaxa().whichTaxonNumber(taxon);	//	originalSequence.dumpFirstPositions();			table.selectCell(ic, it);			table.redrawCell(ic, it);		}		listen = true;	}	//this is consensus position	public void deselectConsensusPositionInTable(int i){		listen = false;		if (taxon != null && table != null){			int it = taxon.getTaxa().whichTaxonNumber(taxon);			int ic = getMatrixPositionOfConsensusPosition(i, originalData);			table.deselectCell(ic, it);			table.redrawCell(ic, it);		}		listen = true;	}	public void deselectAllInTable(){		listen = false;		if (taxon != null && table != null){			int it = taxon.getTaxa().whichTaxonNumber(taxon);			for (int ic = 0; ic<table.getNumColumns(); ic++){				table.deselectCell(ic, it);				table.redrawCell(ic, it);			}		}		listen = true;	}	public void deselectAllInPanels(){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].deselectAll();		}		aceContigPanel.deselectAll();		matrixSeqPanel.deselectAll();		if (origSeqPanel!=null)			origSeqPanel.deselectAll();				}	public void deselectAllChrom(int overallBase){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].deselectAll(overallBase);		}	}	 /*--------------------------------------*/	public void repaintPanels(){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].repaintPanel();		}			aceContigPanel.repaintPanel();			matrixSeqPanel.repaintPanel();			if (origSeqPanel!=null)				origSeqPanel.repaintPanel();	}  	 /*--------------------------------------*/	public Taxon getTaxon(){		return taxon;	}	int keys = 0;	public void keyReleased(KeyEvent e){	}	public void keyTyped(KeyEvent e){	}	public void keyPressed(KeyEvent e){		int k = e.getKeyCode();		if (k==KeyEvent.VK_LEFT) {			if (jumpToNextBase.getValue())				scrollToConsensusBaseOffset(-1);  //David: deselect any selection			else 				goToNextProblem(false, false);		}		else if (k==KeyEvent.VK_RIGHT) {			if (jumpToNextBase.getValue())				scrollToConsensusBaseOffset(1);  //David: deselect any selection			else 				goToNextProblem(true, false);		}	}	/*.................................................................................................................*/ 	public int nextLowQuality(boolean right, int threshold) {		int centerConsensusBase = getConsensusBaseFromOverallBase(centerBase); 		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0) {					int qual = contig.getQualityOfBase(i);					if (qual<threshold)						return i;				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0) {					int qual = contig.getQualityOfBase(i);					if (qual<threshold)						return i;				}			}		return -1;	}	/*.................................................................................................................*/ 	public int nextAmbiguity(boolean right) {  // next ambiguity either in the matrix base or the original Phred.Phrap.Mesquite calls		int centerConsensusBase = getConsensusBaseFromOverallBase(centerBase); 		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0) {						long contigBase = getMatrixStateLongAtConsensusPosition(i);						if (CategoricalState.hasMultipleStates(contigBase)) {							return i;						}						contigBase = contig.getBase(i);						if (CategoricalState.hasMultipleStates(contigBase)) {							return i;						}				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0) {						long contigBase = getMatrixStateLongAtConsensusPosition(i);						if (CategoricalState.hasMultipleStates(contigBase)) {							return i;						}						contigBase = contig.getBase(i);						if (CategoricalState.hasMultipleStates(contigBase)) {							return i;						}				}			}		return -1;	}	/*.................................................................................................................*/ 	public int nextSourceReadIsLowerQualityAndConflicts(boolean right, int smallConflictThreshold, int largeConflictThreshold, boolean strongly) {		int centerConsensusBase = getConsensusBaseFromOverallBase(centerBase); 		MesquiteBoolean higherReadConflicts = new MesquiteBoolean(false);		MesquiteBoolean muchHigherReadConflicts = new MesquiteBoolean(false);		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0) {					if (contig.sourceReadIsLowerQuality(i,smallConflictThreshold, higherReadConflicts, largeConflictThreshold, muchHigherReadConflicts)) {						if (strongly && muchHigherReadConflicts.getValue() || !strongly && higherReadConflicts.getValue())							return i;					}				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0) {					if (contig.sourceReadIsLowerQuality(i,smallConflictThreshold, higherReadConflicts, largeConflictThreshold, muchHigherReadConflicts)) {						if (strongly && muchHigherReadConflicts.getValue() || !strongly && higherReadConflicts.getValue())							return i;					}				}			}		return -1;	}	/*.................................................................................................................*/ 	public int nextSourceReadIsLowerQuality(boolean right, int smallConflictThreshold, int largeConflictThreshold) {		int centerConsensusBase = getConsensusBaseFromOverallBase(centerBase); 		MesquiteBoolean higherReadConflicts = new MesquiteBoolean(false);		MesquiteBoolean muchHigherReadConflicts = new MesquiteBoolean(false);		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0) {					if (contig.sourceReadIsLowerQuality(i,smallConflictThreshold, higherReadConflicts, largeConflictThreshold, muchHigherReadConflicts))						return i;				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0) {					if (contig.sourceReadIsLowerQuality(i,smallConflictThreshold, higherReadConflicts,largeConflictThreshold, muchHigherReadConflicts))						return i;				}			}		return -1;	}	/*.................................................................................................................*/ 	public int nextReadReadConflict(boolean right, int threshold) {		int centerConsensusBase = getConsensusBaseFromOverallBase(centerBase); 		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0) {					int conflict = contig.getConflictLevel(i);					if (conflict>=threshold)						return i;				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0) {					int conflict = contig.getConflictLevel(i);					if (conflict>=threshold)						return i;				}			}		return -1;	}	/*.................................................................................................................*/ 	public int nextReadMatrixConflict(boolean right, int threshold) {		int centerConsensusBase = getConsensusBaseFromOverallBase(centerBase); 		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0) {					for (int chrom = 0; chrom<chromPanels.length; chrom++){						Read read = chromPanels[chrom].getRead();						int readBase = read.getReadBaseFromConsensusBase(i);						char c = read.getPhdBaseChar(readBase);						char contigBase = getMatrixStateAtConsensusPosition(i);						if (c!=contigBase) {							int quality = read.getPhdBaseQuality(readBase);							if (quality>=threshold)								return i;						}					}				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0) {					for (int chrom = 0; chrom<chromPanels.length; chrom++){						Read read = chromPanels[chrom].getRead();						int readBase = read.getReadBaseFromConsensusBase(i);						char c = read.getPhdBaseChar(readBase);						char contigBase = getMatrixStateAtConsensusPosition(i);						if (c!=contigBase) {							int quality = read.getPhdBaseQuality(readBase);							if (quality>=threshold)								return i;						}					}				}			}		return -1;	}	/*.................................................................................................................*/	public void goToNextProblem(boolean right, boolean major) {					int next = -1;		int next2 = -1;				if (jumpToNextAmbiguity.getValue()) {			next2 = nextAmbiguity(right);			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (jumpToNextLowQuality.getValue()) {			next2 = nextLowQuality(right, jumpQualityThreshold.getValue());			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (jumpToNextReadMatrixConflict.getValue()) {			next2 = nextReadMatrixConflict(right, jumpConflictThreshold.getValue());			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (jumpToNextReadReadConflict.getValue()) {			next2 = nextReadReadConflict(right, jumpConflictThreshold.getValue());			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (jumpToNextBadSourceRead.getValue()) {			next2 = nextSourceReadIsLowerQualityAndConflicts(right, 1, 20, major);			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}				//Debugg.println("nextLow: " + nextLow);		if (next>=0 && next<contig.getLength()) {			scrollToConsensusBase(next);		}	}	/*.................................................................................................................*/	public void goToNextReadReadConflict(boolean right) {				int nextLow = nextReadReadConflict(right, jumpConflictThreshold.getValue());		if (nextLow>=0 && nextLow<contig.getLength()) {			scrollToConsensusBase(nextLow);		}	}	/*.................................................................................................................*/	public void goToNextAmbiguity(boolean right) {		int next = nextAmbiguity(right);//Debugg.println("nextLow: " + nextLow);		if (next>=0 && next<contig.getLength()) {			scrollToConsensusBase(next);		}	}	/*.................................................................................................................*/	public void goToNextLowQuality(boolean right) {		int nextLow = nextLowQuality(right, jumpQualityThreshold.getValue());//Debugg.println("nextLow: " + nextLow);		if (nextLow>=0 && nextLow<contig.getLength()) {			scrollToConsensusBase(nextLow);		}	}	/*.................................................................................................................*/	public void goToNextReadMatrixConflict(boolean right) {				int nextLow = nextReadMatrixConflict(right, jumpConflictThreshold.getValue());		if (nextLow>=0 && nextLow<contig.getLength()) {			scrollToConsensusBase(nextLow);		}	}	 /*--------------------------------------*/	 public  void scrollToOverallBase(int overallBase){		hbar.setValue(overallBase);		centerPanelsAtOverallPosition(overallBase);	}	 /*--------------------------------------*/	 public  void scrollToConsensusBase(int i){		scrollToOverallBase(getOverallBaseFromConsensusBase(i));	} 	 /*--------------------------------------*/	 public  void scrollToMatrixBase(int i){		scrollToConsensusBase(getConsensusPositionOfMatrixPosition(i, originalData));	} 	 /*--------------------------------------*/	 public  void scrollToConsensusBaseOffset(int i){		int newBase = centerBase+i;		if (newBase>=0 && newBase<getTotalNumPeaks()) {						hbar.setValue(newBase);			centerPanelsAtOverallPosition(newBase);		}	}  	 /*--------------------------------------*/	 public  void adjustmentValueChanged(AdjustmentEvent evt){		if(evt.getAdjustable() == hbar) {			switch(evt.getAdjustmentType()) {				case AdjustmentEvent.UNIT_DECREMENT:				case AdjustmentEvent.UNIT_INCREMENT:				case AdjustmentEvent.BLOCK_INCREMENT:				case AdjustmentEvent.BLOCK_DECREMENT:				case AdjustmentEvent.TRACK:				centerPanelsAtOverallPosition(evt.getValue());				break;			}		}	}			}/* ======================================================================== */class ChromWindowPalette extends ToolPalette {	ChromatogramWindow w;	MiniSlider slider;	public ChromWindowPalette(MesquiteModule ownerModule, VChromWindow containingWindow, MesquiteCommand sliderCommand) {  //in future pass general MesquiteWindow		super( ownerModule,  containingWindow, 1);			w = containingWindow;					slider = new MiniSlider (sliderCommand, false, 4, 0, 5, 0, 5);			add(slider);			slider.setVisible(true);			slider.setBounds(20, 100, 10, 200);		}			public void setSize(int width, int height){		super.setSize(width, height);		slider.setSize(16, 80);		slider.setLocation(width/2-10, height-100);	}	public void setBounds(int x, int y, int width, int height){		super.setBounds(x, y, width, height);		slider.setSize(16, 80);			slider.setLocation(width/2-10, height-100);}}