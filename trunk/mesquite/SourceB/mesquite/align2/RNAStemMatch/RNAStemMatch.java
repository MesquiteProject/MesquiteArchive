/* Mesquite source code.  Copyright 1997-2005 W. Maddison and D. Maddison. Version 1.06, September 2005.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.align2.RNAStemMatch; import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.categ.lib.*;//  TODO:/*	compatibility check	have it work even if nothing is selected	allow extra bases in selected block	increase speed	(mark stems)   		deal with polymorphisms	contact Dan Miranker's alignment person (Shu Wang,  swang5@ece.utexas.edu)		have it work even if nothing is selected*//* ======================================================================== */public class RNAStemMatch extends DataMatcher {	DNAState csCandidate;	DNAData dnaData;	int originalBlockLength ;	double sum;	double moderateMismatchScore=0.2;	int allowedExtraBases=0;	MesquiteBoolean allowGaps = new MesquiteBoolean(true);	MesquiteBoolean acceptGUMatch = new MesquiteBoolean(true);	double[][]  scores = new double[4][4];   	boolean allowGapsInCandidate;   	long[] reverseBlock=new long[20];   	int numChars;   	   	/*bestA-UC-GG-Umoderate to badA * CG * GC * CU * UU * CA * AworstA * G*/	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName){		MesquiteSubmenuSpec mss = addSubmenu(null, "RNA Stem Match");//getFileCoordinator().		addItemToSubmenu(null, mss, "Allowed Extra Bases...", makeCommand("setAllowedExtraBases",  this));		addCheckMenuItemToSubmenu( null, mss,"Allow Gaps", makeCommand("allowGaps",  this), allowGaps);		addCheckMenuItemToSubmenu( null, mss,"Accept GU Match", makeCommand("acceptGUMatch",  this), acceptGUMatch);		addItemToSubmenu(null, mss, "Moderate Mismatch Score...", makeCommand("setModerateScore",  this));		prepare();		return true;	}	/*.................................................................................................................*/	public void prepare() {		for (int i = 0; i<=3; i++)			for (int j = 0; j<=3; j++)				scores[i][j] = moderateMismatchScore;		scores[0][2] = 0.0;		scores[2][0] = 0.0;		scores[3][0] = 1.0;		scores[0][3] = 1.0;		scores[1][2] = 1.0;		scores[2][1] = 1.0;		if (acceptGUMatch.getValue()) {			scores[2][3] = 1.0;			scores[3][2] = 1.0;		}	}	/*.................................................................................................................*/	public int singleState(long s) {		long lowBits = CategoricalState.statesBitsMask & s;		if (lowBits==1L)			return 0;		if (lowBits==2L)			return 1;		if (lowBits==4L)			return 2;		if (lowBits==8L)			return 3;		return -1;	}	/*.................................................................................................................*/	double RNAComplementMatch(long st1, long st2) {		int s1 =  singleState(st1);		if (s1<0) return 0.0;		int s2 = singleState(st2);		if (s2<0) return 0.0;		return scores[s1][s2];	}	/*.................................................................................................................*/   	/** Returns whether candidate stretch of matrix matches the data contained in the CharacterState array*/   	public double sequenceMatch(CharacterState[] csOriginalArray,  int candidateTaxon, int candidateStartChar, MesquiteInteger candidateEndChar, CommandRecord commandRec){   		if (data==null || table==null)   			return 0.0;   		if (!(data instanceof DNAData))   			return 0.0;    		dnaData = (DNAData)data;   		sum = 0.0;   		allowGapsInCandidate = allowGaps.getValue();   		numChars = data.getNumChars();   		   		originalBlockLength = csOriginalArray.length;   		if (originalBlockLength>reverseBlock.length) {   			reverseBlock = null;   			reverseBlock = new long[originalBlockLength];   		}   		int blockic = 0;   		long s;   		for (int ic = originalBlockLength-1; ic>=0; ic--) {  // loading up the reverse block   			s = ((DNAState)csOriginalArray[ic]).getValue();   			if (!CategoricalState.isInapplicable(s)) {   				reverseBlock[blockic] = s;   				blockic++;   			}   		}		if (blockic==0)			return 0.0;		originalBlockLength = blockic;		long sCandidate;   		      		int num =0;      		int icCandidate = candidateStartChar;		for (int ic = 0; ic< originalBlockLength; ic++){			if (allowGapsInCandidate)				icCandidate=dnaData.thisOrNextApplicableChar(icCandidate,candidateTaxon);   			if (icCandidate<numChars && icCandidate>=0) {	   			sCandidate = dnaData.getStateRaw(icCandidate, candidateTaxon);	   		//	csCandidate = (DNAState)data.getCharacterState(csCandidate, icCandidate, candidateTaxon);	   			sum += RNAComplementMatch(sCandidate, reverseBlock[ic]);	   			num++;   			}			icCandidate++;   		}   		if (candidateEndChar!=null)   			if (icCandidate<=0)   				candidateEndChar.setValue(numChars-1);   			else				candidateEndChar.setValue(MesquiteInteger.minimum(icCandidate-1, numChars-1));		double xSum=0;		double xSum2=0;   			// so we now know the match if no extra bases.  Now let's figure it out if one extra base in the candidate sequence		if (allowedExtraBases>=1 && sum!=originalBlockLength) {  // if we already have a perfect match, don't calculate			xSum=0;			for (int extraBase=1; extraBase<originalBlockLength; extraBase++){				xSum2=0;      				icCandidate = candidateStartChar;				for (int ic = 0; ic< originalBlockLength+1; ic++){					if (allowGapsInCandidate)						icCandidate=dnaData.thisOrNextApplicableChar(icCandidate,candidateTaxon);  //find next non-gap if current one is gap		   			if (ic != extraBase && icCandidate<numChars && icCandidate>=0) {			   			sCandidate = dnaData.getStateRaw(icCandidate, candidateTaxon);			   		//	csCandidate = (DNAState)data.getCharacterState(csCandidate, icCandidate, candidateTaxon);				   			if (ic>extraBase)			   				xSum2 += RNAComplementMatch(sCandidate, reverseBlock[ic-1]);			   			else			   				xSum2 += RNAComplementMatch(sCandidate, reverseBlock[ic]);		   			}		   			icCandidate++;		   		}		   		xSum = MesquiteDouble.maximum(xSum,xSum2);	   		}		   	if (sum<xSum) { // we've found a better match		   		sum = xSum;		   		if (candidateEndChar!=null)		   			if (icCandidate<=0)		   				candidateEndChar.setValue(numChars-1);		   			else	   					candidateEndChar.setValue(MesquiteInteger.minimum(icCandidate-1, numChars-1));		   	}   		}// so we now know the match if 0 or 1 extra bases.  Now let's figure it out if there are two extra bases in the candidate sequence		if (allowedExtraBases>=2 && sum!=originalBlockLength) {  // if we already have a perfect match, don't calculate			xSum=0;			for (int extraBase=1; extraBase<originalBlockLength+1; extraBase++){				for (int extraBase2=extraBase+1; extraBase2<originalBlockLength+1; extraBase2++){					xSum2=0;      					icCandidate = candidateStartChar;					for (int ic = 0; ic< originalBlockLength+2 && ic<numChars; ic++){						if (allowGapsInCandidate)							icCandidate=dnaData.thisOrNextApplicableChar(icCandidate,candidateTaxon);  //find next non-gap is current one is gap			   			if (ic != extraBase && ic != extraBase2 && icCandidate<numChars&& icCandidate>=0) { 				   			sCandidate = dnaData.getStateRaw(icCandidate, candidateTaxon);				   		//	csCandidate = (DNAState)data.getCharacterState(csCandidate, icCandidate, candidateTaxon);				   			if (ic>extraBase) {				   				if (ic>extraBase2)				   					xSum2 += RNAComplementMatch(sCandidate, reverseBlock[ic-2]);				   				else				   					xSum2 += RNAComplementMatch(sCandidate, reverseBlock[ic-1]);				   			}				   			else				   				xSum2 += RNAComplementMatch(sCandidate, reverseBlock[ic]);			   			}		   				icCandidate++;			   		}			   		xSum = MesquiteDouble.maximum(xSum,xSum2);		   		}	   		}		   	if (sum<xSum) {  // we've found a better match		   		sum = xSum;		   		if (candidateEndChar!=null)		   			if (icCandidate<=0)		   				candidateEndChar.setValue(numChars-1);		   			else			   			candidateEndChar.setValue(MesquiteInteger.minimum(icCandidate-1, numChars-1));		   	}   		}   		   		   		return sum/originalBlockLength;	}	/*.................................................................................................................*/    	 public String getName() {		return "RNA Stem Match";   	 }	/*.................................................................................................................*/  	 public String getExplanation() {		return "Returns whether the candidate sequence is a reverse complement (using ribosomal RNA stem rules) of the cells in the original sequence.";   	 }	  	/*.................................................................................................................*/	public int getFirstCharToCalculate(CharacterState[] csOriginalArray, int firstDesired) {		return MesquiteInteger.maximum(0,firstDesired-csOriginalArray.length-1);	}   		/*.................................................................................................................*/  	 public Snapshot getSnapshot(MesquiteFile file) {   	 	Snapshot temp = new Snapshot();  	 	temp.addLine("setModerateScore " + moderateMismatchScore);  	 	temp.addLine("setAllowedExtraBases " + allowedExtraBases);  		temp.addLine("acceptGUMatch " + acceptGUMatch.toOffOnString());  		temp.addLine("allowGaps " + allowGaps.toOffOnString()); 	 	return temp;  	 }	MesquiteInteger pos = new MesquiteInteger();	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {    	 	if (checker.compare(this.getClass(), "Sets the score used for moderate mismatches", "[score]", commandName, "setModerateScore")) {    	 		double oldScore = moderateMismatchScore;   	 		String help = "Mesquite gives a score of 1.0 for A-U (or A-T) matches, C-G matches, and, if Accept GU Match is checked, G-U (or G-T) matches. ";   	 		help += "A score of 0.0 is given for A-G matches.  The score entered into this dialog box is called the moderate mismatch score, and ";   	 		help += "is given to all other matches.";    	 		if (StringUtil.blank(arguments) && !commandRec.scripting()) {				double p = MesquiteDouble.queryDouble(containerOfModule(), "Score for moderate mismatches", "Score:", help, moderateMismatchScore, 0, 1);		   		if (MesquiteDouble.isCombinable(p)) {		   			moderateMismatchScore = p;				}			} else {				double score= MesquiteDouble.fromString(parser.getFirstToken(arguments));				if (MesquiteDouble.isCombinable(score))					moderateMismatchScore = score;				else if (!commandRec.scripting()) {					double p = MesquiteDouble.queryDouble(containerOfModule(), "Score for moderate mismatches", "Score:", help, moderateMismatchScore, 0, 1);			   		if (MesquiteDouble.isCombinable(p)) {			   			moderateMismatchScore = p;					}				}			}			if (oldScore!=moderateMismatchScore)				parametersChanged(null, commandRec);     	 	}     	 	else if (checker.compare(this.getClass(), "Sets allowed number of extra bases in the candidate sequence", "[number]", commandName, "setAllowedExtraBases")) {   	 		int oldBases = allowedExtraBases;   	 		String help = "If this value is above 0, then if Mesquite encounters an extra base in the sequence that is a candidate for the other side of the stem, Mesquite will ignore the extra bases up to the number indicated. ";   	 		help += "It will not ignore extra bases in the selected (master) sequence.";    	 		if (StringUtil.blank(arguments) && !commandRec.scripting()) {				int bases = MesquiteInteger.queryInteger(containerOfModule(), "Number of allowed extra bases", "Allowed number of extra bases", help, allowedExtraBases, 0, 2);		   		if (MesquiteInteger.isCombinable(bases)) {		   			allowedExtraBases = bases;				}			} else {				int bases= MesquiteInteger.fromFirstToken(arguments,pos);				if (MesquiteInteger.isCombinable(bases))					allowedExtraBases = bases;				else if (!commandRec.scripting()) {					bases = MesquiteInteger.queryInteger(containerOfModule(), "Number of allowed extra bases", "Allowed number of extra bases", help, allowedExtraBases, 0, 2);			   		if (MesquiteInteger.isCombinable(bases)) {			   			allowedExtraBases = bases;					}				}			}			if (oldBases!=allowedExtraBases)				parametersChanged(null, commandRec);     	 	}        	 	else if (checker.compare(this.getClass(), "Sets whether or not a match between G and U/T is counted as a full match.", "[on or off]", commandName, "acceptGUMatch")) {    	 		boolean current = acceptGUMatch.getValue();    	 		acceptGUMatch.toggleValue(parser.getFirstToken(arguments));    	 		if (current!=acceptGUMatch.getValue())    	 			parametersChanged(null, commandRec);    	 	}       	 	else if (checker.compare(this.getClass(), "Sets whether or not gaps are allowed in the candidate sequence.", "[on or off]", commandName, "allowGaps")) {    	 		boolean current = allowGaps.getValue();    	 		allowGaps.toggleValue(parser.getFirstToken(arguments));    	 		if (current!=allowGaps.getValue()) {    	 			parametersChanged(null, commandRec);    	 		}    	 		    	 	}    	 	else    	 		return super.doCommand(commandName, arguments, commandRec, checker);		return null;   	 }    /*.................................................................................................................*/    	 public boolean isPrerelease() {		return true;   	 }    		/*.................................................................................................................*/    		public CompatibilityTest getCompatibilityTest(){    			return new DNAStateOnlyTest();    		}}