/* Mesquite source code.  Copyright 1997-2005 W. Maddison and D. Maddison. Version 1.06, September 2005.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.align2.MultiSeqFrom2SeqAligner;/*~~  */import java.util.*;import java.lang.*;import java.io.*;import java.awt.*;import java.awt.event.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.categ.lib.*;import mesquite.lib.table.*;import mesquite.align.lib.*;import mesquite.assoc.lib.AssociationSource;/* ======================================================================== */public class MultiSeqFrom2SeqAligner extends MultipleSequenceAligner{	 boolean preferencesSet = false;	 TwoSequenceAligner pairwiseTask;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName) {		pairwiseTask = (TwoSequenceAligner)hireEmployee(commandRec, TwoSequenceAligner.class, "Pairwise Aligner");		if (pairwiseTask == null)			return sorry(commandRec, getName() + " couldn't start because no pairwise aligner obtained.");		return true;	}	/*.................................................................................................................*/	/** returns whether this module is requesting to appear as a primary choice */   	public boolean requestPrimaryChoice(){   		return true;     	}    	/*.................................................................................................................*/ 	public long[][] alignSequences(MCategoricalDistribution matrix, boolean[] taxaToAlign, int firstSite, int lastSite, CommandRecord commandRec) {  		if (!(matrix.getParentData() != null && matrix.getParentData() instanceof MolecularData)){ 			discreetAlert(commandRec, "Sorry, Multisequence Aligner for Pairwise works only if given a full MolecularData object"); 			return null; 		} 		MolecularData data = (MolecularData)matrix.getParentData();		int numChars = lastSite - firstSite+1;		if (numChars <0 || !MesquiteInteger.isCombinable(firstSite) || !MesquiteInteger.isCombinable(lastSite)){			numChars = data.getNumChars();			firstSite = 0;			lastSite = numChars-1;		}		int numTaxa = 0;		if (taxaToAlign == null)			numTaxa = data.getNumTaxa();		else {			for (int i = 0; i < taxaToAlign.length; i++)				if (taxaToAlign[i])					numTaxa++;					}		long[] seq1 = new long[numChars];		long[] seq2 = new long[numChars];		long[][] alignedPair;		Long2DArray aligned = new Long2DArray(numChars, numTaxa);		Bits newGaps1 = new Bits(numChars);//		long[][] aligned = new long[numChars][2];  //TODO: this should be numTaxa, not 2, and it will be longer than numChars		int firstTaxon = 0;		for (int it = 0; it<data.getNumTaxa(); it++){			if (taxaToAlign == null || taxaToAlign[it]){				firstTaxon=it;				for (int ic = firstSite; ic<=lastSite; ic++) {					seq1[ic-firstSite] = data.getState(ic, it);				}				break;			}				}		int st = 1;		for (int it = firstTaxon+1; it<data.getNumTaxa(); it++){			if (taxaToAlign == null || taxaToAlign[it]){				for (int ic = firstSite; ic<=lastSite; ic++)					seq2[ic-firstSite] = data.getState(ic, it);				Bits bits = new Bits(numChars);  //to hold which sites are new in the new pairwise alignment				MesquiteNumber score = new MesquiteNumber();				alignedPair = pairwiseTask.alignSequences(seq1, seq2, true, score, commandRec);  //later do this as a TwoSequencesAlignerGaps						 	if (bits.numBitsOn()>0)  //info is stored about 					for (int i=0; i<bits.getSize(); i++){									   }				//return Long2DArray.transpose(alignedPair);			 	return alignedPair;				/*				 use a Long2DArray to store new alignment.				for (int ic = 0; ic<=alignedPair.length; ic++) {					aligned[ic][0] = alignedPair[ic][0];					aligned[ic][st] = alignedPair[ic][1];					//TODO: taxa in aligned from 1 to st-1 need to be realigned if gaps added to aligned[][0]				}				st++;				break;  //TODO: this will be removed once new sequences are processed properly				*/			}							}		return aligned.getMatrix();	}	  	/*.................................................................................................................*/  	 public boolean showCitation() {		return true;   	 }	/*.................................................................................................................*/   	 public boolean isPrerelease(){   	 	return false;   	 }	/*.................................................................................................................*/    	 public String getName() {		return "Multiple Alignment From Pairwise";   	 }	/*.................................................................................................................*/ 	/** returns an explanation of what the module does.*/ 	public String getExplanation() { 		return "Does an alignment of multiple sequences by doing independent pairwise alignments." ;   	 }   	 }