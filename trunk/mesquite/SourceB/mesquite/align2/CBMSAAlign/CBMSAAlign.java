/* Mesquite source code.  Copyright 1997-2005 W. Maddison and D. Maddison. Version 1.06, September 2005.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.align2.CBMSAAlign;/*~~  */import java.util.*;import java.lang.*;import java.io.*;import java.awt.*;import java.awt.event.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.categ.lib.*;import mesquite.lib.table.*;import mesquite.align2.lib.*;import edu.utexas.mobios.msa.*;/* ======================================================================== */public class CBMSAAlign extends MolecularDataAlterer implements ActionListener{	CBMSA cbmsa;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName) {		cbmsa = new CBMSA();		return true;	}	/*.................................................................................................................*/	/** returns whether this module is requesting to appear as a primary choice */   	public boolean requestPrimaryChoice(){   		return true;     	}	/*.................................................................................................................*/   	public void alterCell(CharacterData data, int ic, int it, CommandRecord commandRec){   	}   	   	static boolean separateThreadDefault = true;    	boolean separateThread = separateThreadDefault;	/*.................................................................................................................*/	public boolean queryOptions() {		return true;	}	String[] getSelectedSequences(MolecularData data){		StringBuffer outputBuffer = new StringBuffer(100);		String[] s = new String[data.getNumTaxa()];		boolean noneSelected = !data.anySelected();		for (int it = 0; it<data.getNumTaxa(); it++){				outputBuffer.setLength(0);				for (int ic = 0; ic<data.getNumChars(); ic++) {					if (noneSelected || (data.getSelected(ic))){						int currentSize = outputBuffer.length();						if (!data.isInapplicable(ic,it)) {								data.statesIntoStringBuffer(ic, it, outputBuffer, false);						}						if (outputBuffer.length()-currentSize>1) {							MesquiteMessage.warnProgrammer("Sorry, this data matrix can't be exported to this format (some character states aren't represented by a single symbol [char. " + CharacterStates.toExternal(ic) + ", taxon " + Taxon.toExternal(it) + "])");						}					}				}				s[it] = outputBuffer.toString();					}		return s;	}    	/*.................................................................................................................*/   	public boolean prepareAndRunCBMSA(MolecularData data, CommandRecord commandRec){   		String[] sequences = getSelectedSequences(data);   		CBMSAThread thread = new CBMSAThread(this, cbmsa, data, sequences);   		thread.start();		return true;	}	   	/** if returns true, then requests to remain on even after operateData is called.  Default is false*/   	public boolean pleaseLeaveMeOn(){   		return true;   	}    	/*.................................................................................................................*/   	public void processResults(String[] aligned, MolecularData data){		int icStart, icEnd;		boolean wasSel;		if (data.anySelected()) {			icStart = data.firstSelected();			icEnd = data.lastSelected();			wasSel = true;		}		else {			icStart = 0;			icEnd = data.getNumChars()-1;			wasSel = false;		}  		AlignUtil util = new AlignUtil();		Rectangle problem = util.forceAlignment(data, icStart, icEnd, aligned);		if (wasSel) {			data.deselectAll();			int numCharsOrig = icEnd-icStart+1;			int numCharsAligned = aligned[0].length();			if (numCharsAligned>numCharsOrig)				numCharsOrig = numCharsAligned;			for (int i = icStart; i<icStart + numCharsOrig; i++)				data.setSelected(i, true);						}				MesquiteModule mb = data.showMatrix(CommandRecord.nonscriptingRecord);		if (problem != null) {			MesquiteTable table = ((TableWindow)mb.getModuleWindow()).getTable();			table.deselectAll();			table.selectCell(problem.x, problem.y);			table.setFocusedCell(problem.x, problem.y);		}				if (separateThread) {			data.notifyListeners(this, new Notification(MesquiteListener.DATA_CHANGED), CommandRecord.nonscriptingRecord);			MesquiteTable table = ((TableWindow)mb.getModuleWindow()).getTable();			table.repaintAll();		}		if (separateThread)			iQuit();	}		/*.................................................................................................................*/   	/** Called to alter data in those cells selected in table*/   	public boolean alterData(CharacterData data, MesquiteTable table, CommandRecord commandRec){		MolecularData  mData = (MolecularData)data;		if (!(mData.contiguousSelection() || !mData.anySelected())) {			discreetAlert(commandRec, "Data can be aligned only for the whole matrix or for a contiguous set of selected characters");			return false;		}		if (queryOptions())			return prepareAndRunCBMSA(mData, commandRec);		else			return false;		   	}   		/*.................................................................................................................*/  	 public boolean showCitation() {		return true;   	 }	/*.................................................................................................................*/   	 public boolean isPrerelease(){   	 	return false;   	 }	/*.................................................................................................................*/    	 public String getName() {		return "CBMSA Align";   	 }	/*.................................................................................................................*/ 	/** returns an explanation of what the module does.*/ 	public String getExplanation() { 		return "Sends the selected sequences to CBMSA to align." ;   	 }	/*.................................................................................................................*/	 public  void actionPerformed(ActionEvent e) { 		if (e.getActionCommand().equalsIgnoreCase("clustalBrowse")) {		}	 }   	 }class CBMSAThread extends Thread {	CBMSAAlign ownerModule;	CBMSA cbmsa;	String[] sequences;	MolecularData data; 	public CBMSAThread(CBMSAAlign ownerModule, CBMSA cbmsa, MolecularData data, String[] sequences){		this.cbmsa = cbmsa;		this.sequences = sequences;		this.ownerModule = ownerModule;		this.data = data;	}	public void run() {   			sequences = cbmsa.align(sequences, false);                       ownerModule.processResults(sequences, data);	}}