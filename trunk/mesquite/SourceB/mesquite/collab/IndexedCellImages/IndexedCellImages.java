/* Mesquite source code.  Copyright 1997-2002 W. Maddison & D. Maddison. Version 0.992.  September 2002.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.collab.IndexedCellImages; import java.util.*;import java.awt.*;import java.io.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.collab.lib.*;/** ======================================================================== */public class IndexedCellImages extends CellImageSource implements IndexListener {	String indexDirectory = null;	String imageDirectoryBase = null;    	String prefixLow = null;   	String prefixHigh = null;		String relativeDirectory = "";	String viewerPath = null;	String[][] charsToStandardViews;  	ImageIndexManager indexManager;	/*	characterID standardView1 standardView2 ...	characterID2 standardView1 standardView2 ...	*/	String[][] charStatesToTypeImage;  	/*	characterID stateNumber path1 path2 ...	characterID2 stateNumber  path1 path2 ...	*/	String[][] formalTaxaToImageTaxa;  	/*	taxonID imageTaxon1 imageTaxon2 ...	taxonID imageTaxon1 imageTaxon2 ...	*/	String[][] imagePaths;		/*	standardView imageTaxon path	standardView imageTaxon path	*/		boolean ready = false;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName) {		indexManager =(ImageIndexManager)findNearestColleagueWithDuty(ImageIndexManager.class);		if (!commandRec.scripting()){			requestLoadIndices(commandRec);		}		loadPreferences();		if (!MesquiteTrunk.isMacOSX())			addMenuItem( "Image Viewer Preference...", makeCommand("chooseViewer",  this));		if (indexManager != null)			indexManager.addListener(this);		return true;  	 }  	 public void endJob(){  	 		indexManager.removeListener(this);  	 	super.endJob();  	 }  	   	   	 public void indexChanged(CommandRecord commandRec){   		 indexDirectory = null;   		 imageDirectoryBase = null;   		 prefixLow = null;   		 prefixHigh = null;   		 requestLoadIndices(commandRec);   	 }   	 public void imagesChanged(CommandRecord commandRec){   		 imageDirectoryBase = indexManager.getImageRootPath(commandRec);   		 prefixLow = null;   		 prefixHigh = null;   	 	 parametersChanged(null, commandRec);   	 }  	void requestLoadIndices(CommandRecord commandRec){		if (indexDirectory == null){			indexDirectory = indexManager.getIndexDirectory(commandRec);					relativeDirectory = MesquiteFile.decomposePath(getProject().getHomeFile().getDirectoryName(), indexDirectory);		}		if (imageDirectoryBase == null)			imageDirectoryBase = indexManager.getImageRootPath(commandRec);  		logln("Request to load indices for images: " + indexDirectory);		if (StringUtil.blank(indexDirectory))			return;		indexManager.requestLoadIndices(this);  	 }  	 public boolean loadIndices(){		logln("\nLoading index files from " + indexDirectory + "\n");		charsToStandardViews = loadFile("CharsToMorphology.txt", CommandRecord.nonscriptingRecord);		logln("Standard views index loaded");		//charStatesToTypeImage = loadFile("", CommandRecord.nonscriptingRecord);		formalTaxaToImageTaxa = loadFile("TaxaToTerminals.txt", CommandRecord.nonscriptingRecord);		logln("Taxon synonymy index loaded");		imagePaths = loadFile("ImageData.txt", CommandRecord.nonscriptingRecord);		logln("Image paths index loaded");		ready = (charsToStandardViews != null && formalTaxaToImageTaxa != null && imagePaths != null);		if (ready)			parametersChanged(null, CommandRecord.nonscriptingRecord);		return true;	}  	   	 boolean askedOnce = false;  	 void chooseViewer(CommandRecord commandRec){  	 	if (!commandRec.scripting()){  	 		viewerPath = MesquiteFile.openFileDialog("Choose application to display images", null, null);			storePreferences();			askedOnce = true;  	 	}  	 }	public void processPreferencesFromFile (String[] prefs) {		if (prefs!=null && prefs.length>0) {			viewerPath = prefs[0];		}	}			String pathSeparator(String before){		if (indexManager== null) {			if (before == null || !before.endsWith("/"))				return "/";		}		else if (indexManager.useLocalImages()) {			if (before == null || !before.endsWith(MesquiteFile.fileSeparator))				return MesquiteFile.fileSeparator;		}		else {			if (before == null || !before.endsWith("/"))				return "/";		}		return "";	}	/*.................................................................................................................*/	public String[] preparePreferencesForFile () {		if (viewerPath != null)  {				return (new String[] {viewerPath});		}		return null;	}  		public Snapshot getSnapshot(MesquiteFile file) {   	 	Snapshot temp = new Snapshot();  	 	temp.addLine("load");  	 	return temp;  	 }	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {    	 	 if (checker.compare(this.getClass(), "Allows user to choose the viewer to the images", null, commandName, "chooseViewer")) {    	 		chooseViewer(commandRec);    	 	}    	 	else if (checker.compare(this.getClass(), "Loads indices", null, commandName, "load")) {    	 		requestLoadIndices(commandRec);    	 	}    	 	else    	 		return super.doCommand(commandName, arguments, commandRec, checker);	return null;   	 }  	 /*-----------------------------------------------------------*/  	 String[] getTokens(String line){  	 		String[] result;  	 		if (line.indexOf("\t\t")>=0){  	 			StringBuffer sb = new StringBuffer(line);	  	 		boolean prev = false;	  	 		for (int i=sb.length()-1; i>=0; i--){	  	 			if (sb.charAt(i) == '\t'){	  	 				if (prev){	  	 					sb.insert(i+1, ' ');	  	 				}	  	 				prev = true;	  	 			}	  	 			else	  	 				prev = false;	  	 				  	 		}	  	 		line = sb.toString();	  	 	}			StringTokenizer t = new StringTokenizer(line, "\t");			String tok = null;			int count = 0;			try{				while ((tok = t.nextToken())!= null) {					count++;				}			}			catch (NoSuchElementException e){			}			result = new String[count];						StringTokenizer t2 = new StringTokenizer(line, "\t");			tok = null;			count = 0;			try{			while (t2.hasMoreTokens()){				tok = t2.nextToken();				if (tok == null)					tok = "";				result[count] = tok;				count++;			}			}			catch (NoSuchElementException e){			}			return result;  	 }  	 /*-----------------------------------------------------------*/  	 public String[][] loadFile(String fileName, CommandRecord commandRec){  	 	String[] lines = null;		if (indexDirectory.indexOf("://")>=0){  	 		lines = MesquiteFile.getURLContentsAsStrings(indexDirectory + "/" + fileName);		}		else			lines = MesquiteFile.getFileContentsAsStrings(indexDirectory + MesquiteFile.fileSeparator + fileName);		if (lines == null)			return null;		String[][] result = new String[lines.length][];		for (int i= 0; i<lines.length; i++) {			result[i] = getTokens(lines[i]);		}		return result;  	 }  	 /*-----------------------------------------------------------*/  	 //TaxaToTerminals.txt  	 static int TAXONINMATRIX = 0;  	 static int TAXONINIMAGES = 1;  	 String[] getImageTaxonNames(String formalTaxon){  	 	return getMatches(formalTaxaToImageTaxa, formalTaxon, TAXONINMATRIX, TAXONINIMAGES);  	 	  	 }  	 /*-----------------------------------------------------------*/  	 //ImageData.txt  	 static int TAXONINIMAGESim = 0;  	 static int STANDARDVIEWID = 1;  	 static int COMMENT = 2;  	 static int PATHTOIMAGE = 4;  	 static int FILENAME = 3;  	 String[] getImagePaths(String imageTaxon, String standardView, String prefix){  	   	 //0 / 1 harvested  	 	return getMatches(imagePaths, imageTaxon, TAXONINIMAGESim, standardView, STANDARDVIEWID, PATHTOIMAGE, FILENAME, prefix);  	 }  	   	 /*-----------------------------------------------------------*/  	 String[] getComments(String imageTaxon, String standardView){  	   	 //0 / 1 harvested  	 	return getMatches(imagePaths, imageTaxon, TAXONINIMAGESim, standardView, STANDARDVIEWID, COMMENT, -1, "");  	 }  	 /*-----------------------------------------------------------*/  	 //CharsToMorphology.txt  	 static int CHARACTERID = 0;  	 static int STANDARDVIEWIDcm = 1;  	   	 String[] getStandardViews(String character){  	 	return getMatches(charsToStandardViews, character, CHARACTERID, STANDARDVIEWIDcm);  	 	  	 }  	 /*-----------------------------------------------------------*/  	 String[] getMatches( String[][] list, String target, int columnToMatch, int columnToHarvest){  	 	int count = 0;  	 	if (target == null || list == null) {  	 		Debugg.printStackTrace("OOPS TARGET" + target + "  list " + list);  	 		return null;  	 	}  	 	  	 	for (int i = 0; i<list.length; i++){  	 		if (columnToMatch< list[i].length && target.equals(list[i][columnToMatch]))  	 			count++;  	 	}  	 	String[] result = new String[count];  	 	count = 0;  	 	for (int i = 0; i<list.length; i++){  	 		if (target.equals(list[i][columnToMatch])) {  	 			result[count++] = list[i][columnToHarvest];  	 		}  	 	}  	 	return result;  	 }  	 /*-----------------------------------------------------------*/  	 String[] getMatches( String[][] list, String target, int columnToMatch, String target2, int columnToMatch2, int columnToHarvest, int columnToHarvest2, String prefix){  	 	Vector v = new Vector();  	 	if (columnToHarvest2>=0)	  	 	for (int i = 0; i<list.length; i++){	  	 		if (target.equals(list[i][columnToMatch]) && target2.equals(list[i][columnToMatch2])){	  	 			String s = list[i][columnToHarvest];	  	 			s += pathSeparator(s);	  	 			if (prefix != null)	  	 				s += prefix;	  	 			s += list[i][columnToHarvest2];	  	 			v.addElement(s);	  	 		//	v.addElement( list[i][columnToHarvest] + "/" + list[i][columnToHarvest2]);	  	 		}	  	 	}	  	 else	  	 	for (int i = 0; i<list.length; i++){	  	 		if (target.equals(list[i][columnToMatch]) && target2.equals(list[i][columnToMatch2])){	  	 			v.addElement( list[i][columnToHarvest]);	  	 		}	  	 	}	  	return toStrings(v);  	 }  	 /*-----------------------------------------------------------*/  	 String[] toStrings(Vector v){	  	 if (v == null)	  	 	return null;	  	 if (v.size()>0){	  	 	String[] m = new String[v.size()];	  	 	for (int i = 0; i<v.size(); i++){	  	 		m[i] = (String)v.elementAt(i);	  	 	}	  	 	return m;	  	 }  	 	return null;  	 }  	 /*-----------------------------------------------------------*/  	 String getMatch( String[][] list, String target, int columnToMatch, String target2, int columnToMatch2, int columnToHarvest, int columnToHarvest2){  	 	if (columnToHarvest2>=0)	  	 	for (int i = 0; i<list.length; i++){	  	 		if (target.equals(list[i][columnToMatch]) && target2.equals(list[i][columnToMatch2])){	  	 			return list[i][columnToHarvest] + "/" + list[i][columnToHarvest2];	  	 		}	  	 	}	  	 else	  	 	for (int i = 0; i<list.length; i++){	  	 		if (target.equals(list[i][columnToMatch]) && target2.equals(list[i][columnToMatch2])){	  	 			return list[i][columnToHarvest];	  	 		}	  	 	}  	 	return null;  	 }  	   	 /*-----------------------------------------------------------*/  	   	   	 String[] getPathsForFormalTaxonAndCharacter(String character, String formalTaxon, String prefix){  	 	String[] imageTaxa = getImageTaxonNames(formalTaxon);  	 	String[] standardViews = getStandardViews(character);  	 	Vector result = new Vector();  	 	for (int iView = 0; iView<standardViews.length; iView++){  	 		for (int it = 0; it<imageTaxa.length; it++){  	 			String[] matches = getImagePaths(imageTaxa[it], standardViews[iView], prefix);  	 			if (matches != null) {  	 				for (int i=0; i< matches.length; i++)  	 					result.addElement(matches[i]);  	 			}  	 		}  	 	}  	 	return toStrings(result);  	 }  	 String[] getCommentsForFormalTaxonAndCharacter(String character, String formalTaxon){  	 	String[] imageTaxa = getImageTaxonNames(formalTaxon);  	 	String[] standardViews = getStandardViews(character);  	 	Vector result = new Vector();  	 	for (int iView = 0; iView<standardViews.length; iView++){  	 		for (int it = 0; it<imageTaxa.length; it++){  	 			String[] matches = getComments(imageTaxa[it], standardViews[iView]);  	 			if (matches != null) {  	 				for (int i=0; i< matches.length; i++)  	 					result.addElement(matches[i]);  	 			}  	 		}  	 	}  	 	return toStrings(result);  	 }	/*.................................................................................................................*/   	 public boolean isSubstantive(){   	 	return true;   	 }   	 public boolean isPrerelease(){   	 	return true;   	 }	/*.................................................................................................................*/   	 String getNonNull(String[] paths, int whichPath, boolean[] unique){   	 	if (paths == null)   	 		return null;   	 	int count = 0;   	 	for (int i=0; i<paths.length; i++)   	 		if (!StringUtil.blank(paths[i]) && unique[i]) {   	 			if (count == whichPath)   	 				return paths[i];   	 			count++;   	 		}   	 	return null;   	 }   	 boolean[] calculateUnique(String[] paths){   	 	if (paths == null)   	 		return null;   	 	boolean[] b = new boolean[paths.length];   	 	for (int i=0; i<b.length; i++){   	 		b[i] = (!isFoundBefore(paths, paths[i], i));   	 	}   	 	return b;   	 }   	 boolean isFoundBefore(String[] paths, String target, int p){   	 	if (target == null)   	 		return false;   	 	for (int i=0; i<p; i++)   	 		if (paths[i] != null && target.equals(paths[i]))   	 			return true;   	 	return false;   	 }   	    	 String getPrefix(String pathToImages){   	 	if (pathToImages.endsWith(MesquiteFile.fileSeparator) || pathToImages.endsWith("/")){   	 		pathToImages += "_prefix.txt";   	 	}   	 	else {   	 		pathToImages += pathSeparator(pathToImages) + "_prefix.txt";   	 	}   	 	String s;		if (pathToImages.indexOf("://")<0) //local			s = MesquiteFile.getFileContentsAsString(pathToImages, 500, 100, false);		else			s = MesquiteFile.getURLContentsAsString(pathToImages, 500, false);		if (s == null)			return "";		return parser.getFirstToken(s);  	 }  	   	 	/*.................................................................................................................*/   	 public String getCellImageLocation(int i, CharacterData data, int ic, int it, MesquiteString comment, CommandRecord commandRec){   	 	if (!ready)   	 		return null;   	 	if (ic < 0)   	 		return null;   	 	String base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "LowRes";    	 	if (prefixLow == null)   	 		prefixLow = getPrefix(base);   	 	String[] paths = getPathsForFormalTaxonAndCharacter(data.getUniqueID(ic), ParseUtil.tokenize(data.getTaxa().getTaxonName(it)), prefixLow);   	 	boolean[] unique = calculateUnique(paths);	if (i>= getNumberNonNull(paths, unique))  			return null;   	 	String path = getNonNull(paths, i, unique);   	 	   	 	 	 	if (path == null)   	 		return null;  	 	if (path.indexOf("://")<0) {   	 		path = base + pathSeparator(base)  + path;   	 	}   	 	   	 	if (path.indexOf("://")>=0){ //should only massage if path is unmassaged   	 		path = StringUtil.encodeForURL(path);   	 	} 		   	 	String[] comments = getCommentsForFormalTaxonAndCharacter(data.getUniqueID(ic), ParseUtil.tokenize(data.getTaxa().getTaxonName(it)));   	 	String commentt = getNonNull(comments, i, unique);   	 	if (comment!= null)   	 		comment.setValue(commentt);   	 	return path;   	 }	/*.................................................................................................................*/   	 public Image getCellImage(int i, CharacterData data, int ic, int it, MesquiteString comment, MesquiteString location, CommandRecord commandRec){   	 	if (!ready)   	 		return null;   	 	if (ic < 0)   	 		return null;   	 	if (data == null)   	 		return null;   	 	String base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "LowRes";  	 	if (prefixLow == null)   	 		prefixLow = getPrefix(base);   	 	String[] paths = getPathsForFormalTaxonAndCharacter(data.getUniqueID(ic), ParseUtil.tokenize(data.getTaxa().getTaxonName(it)), prefixLow);   	 	boolean[] unique = calculateUnique(paths);  		if (i>= getNumberNonNull(paths, unique))  			return null;   	 	String path = getNonNull(paths, i, unique);   	 	   	 	   	 	if (path == null)   	 		return null;  	 	if (path.indexOf("://")<0) {   	 		path = base + pathSeparator(base)  + path;   	 	}   	 	   	 	if (path.indexOf("://")>=0){ //should only massage if path is unmassaged   	 		path = StringUtil.encodeForURL(path);   	 	} 		   	 	Image image = MesquiteImage.getImage(path, false);   	 	MesquiteImage.waitForImageToLoad(image);   	 	String[] comments = getCommentsForFormalTaxonAndCharacter(data.getUniqueID(ic), ParseUtil.tokenize(data.getTaxa().getTaxonName(it)));   	 	String commentt = getNonNull(comments, i, unique);   	 	if (comment!= null)   	 		comment.setValue(commentt);   	 	if (location!= null)   	 		location.setValue(path);   	 	return image;   	 }   	 	/*.................................................................................................................*/   	 int getNumberNonNull(String[] paths, boolean[] unique){   	 	if (paths == null)   	 		return 0;   	 	int count = 0;   	 	for (int i=0; i<paths.length; i++)   	 		if (unique[i] && !StringUtil.blank(paths[i]))   	 			count++;   	 	return count;   	 }	/*.................................................................................................................*/   	 public int[] getNumCellImages(CharacterData data, int ic, int it, CommandRecord commandRec){  	 	if (!ready)   	 		return null;  	 	if (ic < 0)   	 		return null;   	 	String[] paths = getPathsForFormalTaxonAndCharacter(data.getUniqueID(ic), ParseUtil.tokenize(data.getTaxa().getTaxonName(it)), "");   	 	boolean[] unique = calculateUnique(paths);   	 	int num = getNumberNonNull(paths, unique);   	 	int[] nums = new int[ num];   	 	for (int i=0; i<num; i++){   	 		nums[i] =1;   	 	}    	 	return nums;   	 }	/*.................................................................................................................*/   	 public boolean showCloseupCellImage(int i, CharacterData data, int ic, int it, int modifiers, CommandRecord commandRec){   	 	if (!ready)   	 		return false;   	 	if (ic < 0)   	 		return false;   	 	String prefix = null;   	 	String base;   	 	if (MesquiteEvent.optionKeyDown(modifiers)){	    	 	base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "LowRes";	    	 	if (prefixLow == null)	   	 		prefixLow = getPrefix(base);	   	 	prefix = prefixLow;   	 	}   	 	else {	    	 	base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "HighRes";	    	 	if (prefixHigh == null)	   	 		prefixHigh = getPrefix(base);	   	 	prefix = prefixHigh;  	 	}  	 	String[] paths = getPathsForFormalTaxonAndCharacter(data.getUniqueID(ic), ParseUtil.tokenize(data.getTaxa().getTaxonName(it)), prefix);   	 	String viewer = "open";   	 	boolean[] unique = calculateUnique(paths);   	 	String imagePath = getNonNull(paths, i, unique);   	 	if (imagePath == null)   	 		return false;   	 	if (imagePath.indexOf("://")<0)   	 		imagePath = base + pathSeparator(base) + imagePath;   	 	if (imagePath.indexOf("://")>=0) //should only massage if path is unmassaged   	 		imagePath = StringUtil.encodeForURL(imagePath);    	 	if (!MesquiteTrunk.isMacOSX()){   	 		if (viewerPath == null && !askedOnce)   	 			chooseViewer(commandRec);   	 			   	 		if (viewerPath != null)   	 			viewer = viewerPath;   	 		imagePath = "\"" + imagePath + "\"";   	 	}  	 	//String viewer = "C:\\Program Files\\ACD Systems\\ACDSee\\ACDSee.exe";   	 	//String imagePath = "\"" + imageDirectoryBase + MesquiteFile.fileSeparator + getNonNull(paths, i) + "\"";		try {			Process p = Runtime.getRuntime().exec(new String[]{ viewer, imagePath});			return true;		}		catch (IOException e){			MesquiteMessage.println("exception in showCloseupCellImage ");		}   	 	return false;   	 }	/*.................................................................................................................*/    	 public String getName() {		return "Indexed Cell Matrix Images";   	 }   	 	/*.................................................................................................................*/ 	/** returns an explanation of what the module does.*/ 	public String getExplanation() { 		return "Gives images for a matrix from indexed storage." ;   	 }}