/* Mesquite source code.  Copyright 1997-2005 W. Maddison and D. Maddison. Version 1.06, September 2005.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.collab.a1ReconcileCharacters; import java.util.*;import java.awt.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.lib.table.*;/* ======================================================================== */public class a1ReconcileCharacters extends DataWindowAssistantI  {	MesquiteTable table;	CharacterData data, oData;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName){		mesquite.collab.a0CollabINIT.a0CollabINIT init = (mesquite.collab.a0CollabINIT.a0CollabINIT)findNearestColleagueWithName("a0CollabINIT");		if (init == null)			return false;		addMenuItem(init.collabMenu, "-", null);		addMenuItem(init.collabMenu, "2. Reconcile Character Presence", makeCommand("reconcilePresence",  this));		addMenuItem(init.collabMenu, "3. Reconcile Character Order", makeCommand("reconcileOrder",  this));		return true;	}	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {    	 	if (checker.compare(this.getClass(), "Reconciles presence of characters with other matrix", null, commandName, "reconcilePresence")) {    	 		prepare(commandRec);    	 		reconcilePresence();    	 	}    	 	else if (checker.compare(this.getClass(), "Reconciles order of characters with other matrix", null, commandName, "reconcileOrder")) {    	 		prepare(commandRec);    	 		reconcileOrder();    	 	}    	 	else    	 		return super.doCommand(commandName, arguments, commandRec, checker);		return null;   	 }	/*.................................................................................................................*/   	 public boolean isSubstantive(){   	 	return true;   	 }	/*.................................................................................................................*/	public void setTableAndData(MesquiteTable table, CharacterData data, CommandRecord commandRec){		this.table = table;		this.data = data;	}	/*.................................................................................................................*/    	 public String getName() {		return "Reconcile Characters";   	 }	/*.................................................................................................................*/  	 public String getExplanation() {		return "Reconciles character presence and order with another matrix.";   	 }   	 	/*.................................................................................................................*/   	 public void prepare(CommandRecord commandRec){   		if (oData != null)  //already done   			return;   		CharacterData ooData = null;   		Taxa taxa = data.getTaxa();		int numSets = getProject().getNumberCharMatrices(taxa);		int numSetsDiff = numSets;		for (int i = 0; i<numSets; i++) {			CharacterData pData =getProject().getCharacterMatrix(taxa, i);			if (pData== data)				numSetsDiff--;			else if (pData.getClass() != data.getClass())				numSetsDiff--;		}		if (numSetsDiff<=0) {			discreetAlert(commandRec, "Sorry, there are no other compatible data matrices available for comparison.  If the other matrix is in another file, open the file as a linked file before attempting to compare.");		}		else {			Listable[] matrices = new Listable[numSetsDiff];			int count=0;			ooData = null;			for (int i = 0; i<numSets; i++) {				CharacterData pData =getProject().getCharacterMatrix(taxa, i);				if (pData!= data && (pData.getClass() == data.getClass())) {					matrices[count]=pData;					if (numSetsDiff==1 && count == 0) {						ooData = pData;						break;					}					count++;									}			}			boolean differenceFound=false;			if (ooData == null)				ooData = (CharacterData)ListDialog.queryList(containerOfModule(), "Compare with", "Reconcile with data matrix:", MesquiteString.helpString,matrices, 0);		}		this.oData = ooData;		if (ooData == null)			return;	 }	NameReference notesNameRef = NameReference.getNameReference("notes");	NameReference historyNameRef = NameReference.getNameReference("ChangeHistory");		private int numDifferentPresence(CharacterData data, CharacterData oData){		int num = 0;		for (int ic = 0; ic<oData.getNumChars(); ic++){			String id = oData.getUniqueID(ic);			int whichChar = data.findByUniqueID(id);			if (whichChar<0) {				logln("Character in other matrix, not in this: " + (ic+1));				//items += " " + (ic+1);				num++;			}		}		return num;	}	/*.................................................................................................................*/	private boolean reconcilePresence(){		if (data == null || oData == null)			return false;		boolean changed = false;		String items = "";		int num = numDifferentPresence(data, oData);		if (num == 0){			alert("There are no characters in the other matrix that are not also in this matrix");			return false;		}		CharacterState cs2 = null;		boolean pleaseContinue = AlertDialog.query(containerOfModule(), "Reconcile?", "There are " + num + " characters in the other matrix not in this one (" + ").  Do you want to incorporate them into this matrix?", "Incorporate", "Cancel", 0);		if (pleaseContinue){			for (int ic = 0; ic<oData.getNumChars(); ic++){				String id = oData.getUniqueID(ic);				int whichChar = data.findByUniqueID(id);				if (whichChar<0) {					data.addCharacters(data.getNumChars()-1, 1, false);   					int newIC = data.getNumChars()-1;					data.setUniqueID(newIC, id);					//doesn't yet incorporate colors, etc					data.equalizeCharacter(oData, ic, newIC);				}			}			data.notifyListeners(this, new Notification(MesquiteListener.PARTS_CHANGED));		}		return changed;	}	private AttachedNotesVector getVector(CharacterData d, int ic, int it){		if (it == -1)			return (AttachedNotesVector)d.getAssociatedObject(notesNameRef, ic);		else if (ic>= 0 && it>=0)			return (AttachedNotesVector)d.getCellObject(notesNameRef, ic, it);		return null;	}	void copyAnnotations(CharacterData data, int ic, CharacterData oData, int oic, int it){			AttachedNotesVector v = getVector(data, ic, it);			AttachedNotesVector vO = getVector(oData, oic, it);			if (vO == null) { //no notes; do nothing			}			else if (ic>=0){				v = vO.cloneVector(data);				if (it < 0)					data.setAssociatedObject(notesNameRef, ic, v);				else {					data.setCellObject(notesNameRef, ic, it, v);					data.setCellObjectDisplay(ic, it);				}			}	}	/*.................................................................................................................*/	private boolean reconcileOrder(){		if (data == null || oData == null)			return false;		if (numDifferentPresence(data, oData) > 0) {			alert("You can't reconcile their order if the other matrix has characters not in this one.  Reconcile character presence first.");			return false;		}		boolean changed = false;		boolean noneSelected = (table == null) || !table.anyCellSelectedAnyWay();		int num = 0;		for (int ic = 0; ic<data.getNumChars(); ic++){			String id = data.getUniqueID(ic);			if (!StringUtil.blank(id)){				int whichChar = oData.findByUniqueID(id);				if (whichChar >=0 && whichChar!= ic) {					logln("Character in other not in same order in this: " + ic);					num++;				}			}		}		if (num == 0){			alert("The order of characters is the same in the two matrices");			return false;		}		boolean pleaseContinue = AlertDialog.query(containerOfModule(), "Reconcile?", "There are " + num + " characters in the other matrix in a different order than in this one (" + ").  Do you want to adjust the order of this matrix to be the same as the other?", "Reorder", "Cancel", 0);		if (pleaseContinue) {			for (int ic = 0; ic<data.getNumChars(); ic++){				String id = oData.getUniqueID(ic);				if (!StringUtil.blank(id)){					int whichChar = data.findByUniqueID(id);					if (whichChar >=0 && whichChar!= ic) {						data.swapParts(ic, whichChar);						logln("Character " + (whichChar+1) + " moved into position " + (ic+1));						num++;					}				}			}			data.notifyListeners(this, new Notification(MesquiteListener.PARTS_MOVED));		}		return changed;	}		public String getParameters(){		if (isActive())			return getName();		return null;	}}