/* Mesquite source code.  Copyright 1997-2002 W. Maddison & D. Maddison. Version 0.992.  September 2002.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.collab.zCellChangeHistory; import java.util.*;import java.awt.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.lib.table.*;/** ======================================================================== */public class zCellChangeHistory extends DataWindowAssistantI implements CellColorer {	TableTool historyTool;	CharacterData data;	MesquiteTable table;	NameReference historyNameRef = NameReference.getNameReference("ChangeHistory");	//MesquiteBoolean recChanges;	//MesquiteBoolean recAuthority;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName){ 		//recChanges = new MesquiteBoolean(true);  		//recAuthority = new MesquiteBoolean(false);		//addCheckMenuItem(null, "Record History of Changes", makeCommand("recordHistory",  this), recChanges); 		//addMenuItem("Populate Annotations (Debugging)", makeCommand("fillAnnotations",  this)); 		//addMenuItem("Populate Footnotes (Debugging)", makeCommand("fillFootnotes",  this)); 		//addCheckMenuItem(null, "Require Change Authority", makeCommand("saveAuthority",  this), recAuthority);		return true;	}	/*.................................................................................................................*/   	 public boolean isSubstantive(){   	 	return false;   	 }   	 public void viewChanged(CommandRecord commandRec){   	 }   	    	 long oldestModified = MesquiteTrunk.startupTime;	public void setTableAndData(MesquiteTable table, CharacterData data, CommandRecord commandRec){		this.table = table;		this.data = data;				if (data !=null) {			//recChanges.setValue(data.saveChangeHistory);			oldestModified = MesquiteTrunk.startupTime;   			for (int ic=0; ic<data.getNumChars(); ic++)   				for (int it = 0; it<data.getNumTaxa(); it++)   					if (getHistory(ic, it) != null) {   						long lM = getHistory(ic, it).lastModified();   						if (lM!=0 && MesquiteLong.isCombinable(lM) && lM<oldestModified)   							oldestModified = lM;   					}   								}	}	/*.................................................................................................................*/  	 public Snapshot getSnapshot(MesquiteFile file) {    	 	Snapshot temp = new Snapshot();  	 	//temp.addLine("recordHistory " + recChanges.toOffOnString());  	 	//temp.addLine("saveAuthority " + recAuthority.toOffOnString()); 	 	return temp;  	 }	MesquiteInteger pos = new MesquiteInteger();	NameReference notesNameRef = NameReference.getNameReference("notes");	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {    	 	if (checker.compare(this.getClass(), "Sets the data matrix to save a history of changes", "[on or off]", commandName, "recordHistory")) {    	 		/*    	 		recChanges.toggleValue(parser.getFirstToken(arguments));			if (data !=null) {				data.saveChangeHistory = recChanges.getValue();			}			*/	    	 	}    	 	else if (checker.compare(this.getClass(), "Sets the data matrix to save a history of changes", "[on or off]", commandName, "saveHistory")) {    	 		//old, here to disable    	 	}    	 	else if (checker.compare(this.getClass(), "Sets the data matrix to require indication of an authority for any change", "[on or off]", commandName, "saveAuthority")) {    	 		/*    	 		if (!commandRec.scripting() && data!=null && !(data.saveChangeHistory)) {    	 			alert("To require authority for changes made, first turn on the recording of the history of changes");    	 			return null;    	 		}    	 		recAuthority.toggleValue(parser.getFirstToken(arguments));			if (data !=null) {				data.requireChangeAuthority = recAuthority.getValue();			}			*/    	 	}    	 	else if (checker.compare(this.getClass(), "Populates matrix full of annotations (for debugging purposes)", null, commandName, "fillAnnotations")) {			for (int column = 0; column < data.getNumChars(); column++) 			for (int row = 0; row < data.getNumTaxa(); row++){				commandRec.tick("filling character " + column + " and taxon " + row);				AttachedNote hL = new AttachedNote();				hL.setAuthor(MesquiteModule.author);				AttachedNotesVector aiv = (AttachedNotesVector)data.getCellObject(notesNameRef, column, row);				if (aiv == null) {					aiv = new AttachedNotesVector(data);					data.setCellObject(notesNameRef, column, row, aiv);					data.setCellObjectDisplay(column, row);		 		}		 		aiv.addNote(hL, true);			}    	 	}    	 	else if (checker.compare(this.getClass(), "Populates matrix full of footnotes (for debugging purposes)", null, commandName, "fillFootnotes")) {			for (int column = 0; column < data.getNumChars(); column++) 			for (int row = 0; row < data.getNumTaxa(); row++){				commandRec.tick("filling character " + column + " and taxon " + row);				data.setAnnotation(column, row, new String("this is a test comment, not much to say really"));			}    	 	}    	 	else    	 		return super.doCommand(commandName, arguments, commandRec, checker);		return null;   	 }	/*.................................................................................................................*/   	public boolean hasDisplayModifications(){   		return false;   	}   	 public void setActiveColors(boolean active, CommandRecord commandRec){   	 }   	private ChangeHistory getHistory(int ic, int it){   		if (data == null)   			return null;   		return (ChangeHistory)data.getCellObject(historyNameRef, ic, it);   	}   	ColorRecord[] legend;   	public ColorRecord[] getLegendColors(CommandRecord commandRec){   		if (legend == null) {   			legend = new ColorRecord[4];   			legend[0] = new ColorRecord(Color.white, "No recorded history of changes");   			legend[1] = new ColorRecord(ColorDistribution.lightRed, "Modified in this run of Mesquite");   			legend[2] = new ColorRecord(ColorDistribution.lightGreen, "Modified during the last day");   			legend[3] = new ColorRecord(ColorDistribution.veryLightBlue, "State modified a day or more ago");  		}   		return legend;   	}   	public String getColorsExplanation(CommandRecord commandRec){   		return null;   	}   	public Color getCellColor(int ic, int it){		ChangeHistory cH = getHistory(ic, it);   		if (cH == null)   			return Color.white;   		long mod = cH.lastModified();   		if (mod>= MesquiteTrunk.startupTime) // modified since startup   			return ColorDistribution.lightRed;   		else if (System.currentTimeMillis()-mod < 86400000L) //modifed in last day   			return MesquiteColorTable.getGreenScale(mod, System.currentTimeMillis()-100000000L, MesquiteTrunk.startupTime, true);   		else   			return MesquiteColorTable.getBlueScale(cH.lastModified(), oldestModified*0.999, MesquiteTrunk.startupTime+1000000000L, true);   	}	/*.................................................................................................................*/   	 public String getCellString(int column, int row){		ChangeHistory cH = getHistory(column, row);		if (cH == null)			return("There is no recorded history of changes to cell for character " + (column+1) + ", taxon " + (row+1));   		String s;   		long mod = cH.lastModified();   		if (mod>= MesquiteTrunk.startupTime) // modified since startup   			s = "State modified during this run of Mesquite";    		else if (System.currentTimeMillis()-mod < 86400000L) //modifed in last day   			s = "State modified within the last day";   		else   			s = "State modified a day or more ago";   		s += "\n----------\nHistory of changes to cell for character " + (column+1) + ", taxon " + (row+1) + "\n\n" + cH.toString() +"-----------\n\n";		return s;   	 	   	 }	/*.................................................................................................................*/   	public String getCellExplanation(int ic, int it){		ChangeHistory cH = getHistory(ic, it);   		if (cH == null)   			return null;   		ChangeEvent ce = cH.getLastEvent();   		if (ce == null)   			return null;		String s = "Last change to cell done";		if (ce.getAuthor() != null) {			s += " by  " ;			if (!StringUtil.blank(ce.getAuthor().getName()))				s += (ce.getAuthor().getName());			else				s += (ce.getAuthor().getCode());		}		s += ( " at " + new Date(ce.getTime()) + " Changed to: " + ce.getChange());   				return s;   	}	/*.................................................................................................................*/    	 public String getName() {		return "Cell Change History";   	 }	/*.................................................................................................................*/    	 public String getNameForMenuItem() {		return "Recency of Change";   	 }	/*.................................................................................................................*/  	 public String getVersion() {		return null;   	 }   	 	/*.................................................................................................................*/  	 public String getExplanation() {		return "Colors cells by recency of change.";   	 }}