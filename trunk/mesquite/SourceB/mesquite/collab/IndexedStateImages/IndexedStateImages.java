/* Mesquite source code.  Copyright 1997-2002 W. Maddison & D. Maddison. Version 0.992.  September 2002.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.collab.IndexedStateImages; import java.util.*;import java.awt.*;import java.io.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.collab.lib.*;/** ======================================================================== */public class IndexedStateImages extends CharStateImageSource implements IndexListener {	String indexDirectory = null;	String imageDirectoryBase = null;    	String prefixLow = null;   	String prefixHigh = null;	String relativeDirectory = "";	String viewerPath = null;	String[][] stateTypeImages;  	ImageIndexManager indexManager;	/*	characterID state path comment	characterID state path comment	*/	boolean ready = false;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName) {		indexManager =(ImageIndexManager)findNearestColleagueWithDuty(ImageIndexManager.class);		if (!commandRec.scripting()){			requestLoadIndices(commandRec);		}		loadPreferences();		if (!MesquiteTrunk.isMacOSX())			addMenuItem( "Image Viewer Preference...", makeCommand("chooseViewer",  this));		if (indexManager != null)			indexManager.addListener(this);		return true;  	 }  	 public void endJob(){		indexManager.removeListener(this);  	 	super.endJob();  	 }   	 public void indexChanged(CommandRecord commandRec){   		 indexDirectory = null;   		 imageDirectoryBase = null;   		 prefixLow = null;   		 prefixHigh = null;   		 requestLoadIndices(commandRec);   	 }   	 public void imagesChanged(CommandRecord commandRec){   		 imageDirectoryBase = indexManager.getImageRootPath(commandRec);   		 prefixLow = null;   		 prefixHigh = null;   	 	 parametersChanged(null, commandRec);   	 }  	   	void requestLoadIndices(CommandRecord commandRec){		if (indexDirectory == null){			indexDirectory = indexManager.getIndexDirectory(commandRec);			relativeDirectory = MesquiteFile.decomposePath(getProject().getHomeFile().getDirectoryName(), indexDirectory);		}		if (imageDirectoryBase == null)			imageDirectoryBase = indexManager.getImageRootPath(commandRec);  		logln("Request to load indices for images: " + indexDirectory);		if (StringUtil.blank(indexDirectory))			return;		indexManager.requestLoadIndices(this);  	 }  	 public boolean loadIndices(){		logln("Loading index files from " + indexDirectory);		stateTypeImages = loadFile("CharStateImageTypification.txt", CommandRecord.nonscriptingRecord);		logln("State type images index loaded");		ready = (stateTypeImages != null);		if (ready)			parametersChanged(null, CommandRecord.nonscriptingRecord);		return true;  	 }  	   	 boolean askedOnce = false;  	 void chooseViewer(CommandRecord commandRec){  	 	if (!commandRec.scripting()){  	 		viewerPath = MesquiteFile.openFileDialog("Choose application to display images", null, null);			storePreferences();			askedOnce = true;  	 	}  	 }	public void processPreferencesFromFile (String[] prefs) {		if (prefs!=null && prefs.length>0) {			viewerPath = prefs[0];		}	}	String pathSeparator(String before){		if (indexManager== null) {			if (before == null || !before.endsWith("/"))				return "/";		}		else if (indexManager.useLocalImages()) {			if (before == null || !before.endsWith(MesquiteFile.fileSeparator))				return MesquiteFile.fileSeparator;		}		else {			if (before == null || !before.endsWith("/"))				return "/";		}		return "";	}	/*.................................................................................................................*/	public String[] preparePreferencesForFile () {		if (viewerPath != null)  {				return (new String[] {viewerPath});		}		return null;	}  		public Snapshot getSnapshot(MesquiteFile file) {   	 	Snapshot temp = new Snapshot();  	 	temp.addLine("load");  	 	return temp;  	 }	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {    	 	if (checker.compare(this.getClass(), "Allows user to choose the viewer to the images", null, commandName, "chooseViewer")) {    	 		chooseViewer(commandRec);    	 	}    	 	else if (checker.compare(this.getClass(), "Loads indices", null, commandName, "load")) {    	 		requestLoadIndices(commandRec);    	 	}    	 	else    	 		return super.doCommand(commandName, arguments, commandRec, checker);		return null;   	 }  	 /*-----------------------------------------------------------*/  	 String[] getTokens(String line){  	 		String[] result;  	 		if (line.indexOf("\t\t")>=0){  	 			StringBuffer sb = new StringBuffer(line);	  	 		boolean prev = false;	  	 		for (int i=sb.length()-1; i>=0; i--){	  	 			if (sb.charAt(i) == '\t'){	  	 				if (prev){	  	 					sb.insert(i+1, ' ');	  	 				}	  	 				prev = true;	  	 			}	  	 			else	  	 				prev = false;	  	 				  	 		}	  	 		line = sb.toString();	  	 	}  	 					StringTokenizer t = new StringTokenizer(line, "\t");			String tok = null;			int count = t.countTokens();			result = new String[count];			tok = null;			count = 0;			try{			while (t.hasMoreTokens()){				tok = t.nextToken();				if (tok == null)					tok = "";				result[count] = tok;				count++;			}			}			catch (NoSuchElementException e){			}			return result;  	 }  	 /*-----------------------------------------------------------*/  	 public String[][] loadFile(String fileName, CommandRecord commandRec){		String[] lines = null;		if (indexDirectory.indexOf("://")>=0){  	 		lines = MesquiteFile.getURLContentsAsStrings(indexDirectory + "/" + fileName);		}		else			lines = MesquiteFile.getFileContentsAsStrings(indexDirectory + MesquiteFile.fileSeparator + fileName);				if (lines == null) {			logln("Attempt to load index file at " + indexDirectory + " failed.");			return null;		}		String[][] result = new String[lines.length][];		for (int i= 0; i<lines.length; i++) {			result[i] = getTokens(lines[i]);		}		return result;  	 }  	 /*-----------------------------------------------------------*/	static int ID_COLUMN = 0;	static int LOCALPATH_COLUMN = 5;	static int IMAGEFILE_COLUMN = 4;	static int COMMENT_COLUMN = 3;		/* for character of this ID, return for each character state [0] = location and [1] = comment*/  	 String[][] getCharacterImages(String characterID, String prefix){  	 	return getMatches(stateTypeImages, characterID, ID_COLUMN, LOCALPATH_COLUMN,IMAGEFILE_COLUMN, COMMENT_COLUMN,  prefix);  	 	  	 }  	 /*-----------------------------------------------------------*/  	 String[][] getMatches( String[][] list, String target, int columnToMatch, int columnToHarvest, int columnToHarvest2, int commentColumn, String prefix){  	 	if (target == null)  	 		return null;  	 	int count = 0;  	 	for (int i = 0; i<list.length; i++){  	 		if (target.equals(list[i][columnToMatch]))  	 			count++;  	 	}  	 	String[][] result = new String[count][2];  	 	count = 0;  	 	for (int i = 0; i<list.length; i++){  	 		if (target.equals(list[i][columnToMatch])) {  	 			String s = list[i][columnToHarvest];  	 			s += pathSeparator(s);  	 			if (prefix != null)  	 				s += prefix;  	 			s += list[i][columnToHarvest2];  	 			result[count][0] = s;  	 			result[count][1] = list[i][commentColumn];	 			count++;  	 		}  	 	}  	 	return result;  	 }  	 	/*.................................................................................................................*/   	 public boolean isSubstantive(){   	 	return true;   	 }   	 public boolean isPrerelease(){   	 	return true;   	 }	/*.................................................................................................................*/   	 String getNonNull(String[][] paths, int whichPath){   	 	if (paths == null)   	 		return null;   	 	int count = 0;   	 	for (int i=0; i<paths.length; i++)   	 		if (!StringUtil.blank(paths[i][0])) {   	 			if (count == whichPath)   	 				return paths[i][0];   	 			count++;   	 		}   	 	return null;   	 }	/*.................................................................................................................*/   	 String getNonNullComment(String[][] paths, int whichPath){   	 	if (paths == null)   	 		return null;   	 	int count = 0;   	 	for (int i=0; i<paths.length; i++)   	 		if (!StringUtil.blank(paths[i][0])) {   	 			if (count == whichPath)   	 				return paths[i][1];   	 			count++;   	 		}   	 	return null;   	 }   	 String getPrefix(String pathToImages){   	 	if (pathToImages.endsWith(MesquiteFile.fileSeparator) || pathToImages.endsWith("/")){   	 		pathToImages += "_prefix.txt";   	 	}   	 	else {   	 		pathToImages += pathSeparator(pathToImages) + "_prefix.txt";   	 	}   	 	String s;		if (pathToImages.indexOf("://")<0) //local			s = MesquiteFile.getFileContentsAsString(pathToImages, 500, 100, false);		else			s = MesquiteFile.getURLContentsAsString(pathToImages, 500, false);		return parser.getFirstToken(s);  	 }	/*.................................................................................................................*/   	 public Image[] getCharacterStateImages(int i, CharacterData data, int ic, Vector comment, Vector location, CommandRecord commandRec){   	 	if (!ready)   	 		return null;   	 	String characterID = data.getUniqueID(ic);   	 	String base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "LowRes";   	 	if (prefixLow == null)   	 		prefixLow = getPrefix(base);   	 	String[][] paths = getCharacterImages(characterID, prefixLow);  		if (i>= getNumberNonNull(paths))  			return null;   	 	String path = getNonNull(paths, i);   	 	if (path == null)   	 		return null;   	 	if (path.indexOf("://")<0)   	 		path = base + pathSeparator(base)  + path;   	 	   	 	if (path.indexOf("://")>=0) //should only massage if path is unmassaged   	 		path = StringUtil.encodeForURL(path);   	 	Image image = MesquiteImage.getImage(path, false);   	 	MesquiteImage.waitForImageToLoad(image); 	 	   	 	if (comment!= null)   	 		comment.addElement(getNonNullComment(paths, i));   	 	if (location!= null)   	 		location.addElement(path);   	 	return new Image[] {image};   	 }   	 	/*.................................................................................................................*/   	 int getNumberNonNull(String[][] paths){   	 	if (paths == null)   	 		return 0;   	 	int count = 0;   	 	for (int i=0; i<paths.length; i++)   	 		if (!StringUtil.blank(paths[i][0]))   	 			count++;   	 	return count;   	 }	/*.................................................................................................................*/	/* returns for each character state the number of images for it */   	 public int[] getNumCharacterStateImages(CharacterData data, int ic, CommandRecord commandRec){  	 	if (!ready)   	 		return null;   	 	String characterID = data.getUniqueID(ic);   	 	String[][] paths = getCharacterImages(characterID, "");   	 	int num = getNumberNonNull(paths);   	 	int[] nums = new int[ num];   	 	for (int i=0; i<num; i++){   	 		nums[i] =1;   	 	}   	 	return nums;   	 }   	    	    	 /*NOT YET USED   	String getImagePath(boolean lowRes){   	 	String characterID = data.getUniqueID(ic);   	 	String dir = "LowRes";   	 	if (!lowRes)   	 		dir = "HighRes";   	 	String base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + dir;   	 	String prefix = null;   	 	if (lowRes){	   	 	if (prefixLow == null)	   	 		prefixLow = getPrefix(base);	   	 	previx = prefixLow;   	 	}   	 	else {	   	 	if (prefixHigh == null)	   	 		prefixHigh = getPrefix(base);	   	 	prefixHigh = prefixLow;   	 	}   	 	String[][] paths = getCharacterImages(characterID, prefix);  		if (i>= getNumberNonNull(paths))  			return null;   	 	String path = getNonNull(paths, i);   	 	if (path == null)   	 		return null;   	 	if (path.indexOf("://")<0)   	 		path = base + pathSeparator(base)  + path;   	 	   	 	if (path.indexOf("://")>=0) //should only massage if path is unmassaged   	 		path = StringUtil.encodeForURL(path);		return path;	}	/*.................................................................................................................*/   	 public boolean showCloseupCharImage(int i, CharacterData data, int ic, int modifiers, CommandRecord commandRec){   	 	if (!ready)   	 		return false;   	 	String characterID = data.getUniqueID(ic);   	 	String prefix = null;   	 	String base;   	 	if (MesquiteEvent.optionKeyDown(modifiers)){	    	 	base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "LowRes";	    	 	if (prefixLow == null)	   	 		prefixLow = getPrefix(base);	   	 	prefix = prefixLow;   	 	}   	 	else {	    	 	base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "HighRes";	    	 	if (prefixHigh == null)	   	 		prefixHigh = getPrefix(base);	   	 	prefix = prefixHigh;  	 	}  	 	String[][] paths = getCharacterImages(characterID, prefix);   	 	String imagePath = getNonNull(paths, i);   	 	if (imagePath == null)   	 		return false;   	 	if (imagePath.indexOf("://")<0)   	 		imagePath = base + pathSeparator(base) + imagePath;   	 	if (imagePath.indexOf("://")>=0) //should only massage if path is unmassaged   	 		imagePath = StringUtil.encodeForURL(imagePath);   	 		    	 	String viewer = "open";  	    	 	if (!MesquiteTrunk.isMacOSX()){   	 		if (viewerPath == null && !askedOnce)   	 			chooseViewer(commandRec);   	 			   	 		if (viewerPath != null)   	 			viewer = viewerPath;   	 		imagePath = "\"" + imagePath + "\"";   	 	}  	 	//String viewer = "C:\\Program Files\\ACD Systems\\ACDSee\\ACDSee.exe";   	 	//String imagePath = "\"" + directory + MesquiteFile.fileSeparator + getNonNull(paths, i) + "\"";		try {			Process p = Runtime.getRuntime().exec(new String[]{ viewer, imagePath});			return true;		}		catch (IOException e){			MesquiteMessage.println("exception in showCloseupCellImage ");		}   	 	return false;   	 }	/*.................................................................................................................*/    	 public String getName() {		return "Indexed Character State Images";   	 }   	 	/*.................................................................................................................*/ 	/** returns an explanation of what the module does.*/ 	public String getExplanation() { 		return "Gives images for a character from indexed storage." ;   	 }}