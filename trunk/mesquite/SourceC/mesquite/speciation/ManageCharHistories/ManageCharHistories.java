/* Mesquite module ~~*/package mesquite.speciation.ManageCharHistories;/*~~  */import java.applet.*;import java.util.*;import java.awt.*;import java.io.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;/* ======================================================================== a file interpreter for a NEXUS file format  */public class ManageCharHistories extends FileElementManager {	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName) {		return true;	}	/*.................................................................................................................*/ 	/** A method called immediately after the file has been read in.*/ 	public void projectEstablished() {		super.projectEstablished(); 	} 	public MesquiteModule showElement(FileElement element, CommandRecord commandRec){ 		return null; 	} 		/*.................................................................................................................*/	public Class getElementClass(){		return StoredCharacterHistory.class;	}	/*.................................................................................................................*/	public void elementDisposed(FileElement e){		NexusBlock nb = findNEXUSBlock(e);		if (nb!=null)			removeNEXUSBlock(nb);	}	/*.................................................................................................................*/	public NexusBlock elementAdded(FileElement history){		if (history == null || !(history instanceof StoredCharacterHistory))			return null;				//resetAllMenuBars();		NexusBlock nb = findNEXUSBlock(history);		if (nb==null) {			CharacterHistoryBlock cb = new CharacterHistoryBlock(history.getFile(), this);			cb.setHistory((StoredCharacterHistory)history);			addNEXUSBlock(cb);			return cb;		}		else return nb;	}	/*.................................................................................................................*/	public void fileElementAdded(FileElement history){		if (history == null || !(history instanceof StoredCharacterHistory))			return;				//resetAllMenuBars();		NexusBlock nb = findNEXUSBlock(history);		if (nb==null) {			CharacterHistoryBlock cb = new CharacterHistoryBlock(history.getFile(), this);			cb.setHistory((StoredCharacterHistory)history);			addNEXUSBlock(cb);		}	}	/*.................................................................................................................*/  	 public Snapshot getSnapshot(MesquiteFile file) {    	 	Snapshot temp = new Snapshot();		for (int i = 0; i<getNumberOfEmployees(); i++) {			MesquiteModule e=(MesquiteModule)getEmployeeVector().elementAt(i);			if (e instanceof ManagerAssistant && (e.getModuleWindow()!=null) && e.getModuleWindow().isVisible() && e.getName().equals("Character Matrices List")) {  	 				temp.addLine("showDatasList ", e);   	 		}		}  	 	return temp;  	 }  	 MesquiteInteger pos = new MesquiteInteger(0);	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {    	 	if (false){}    	 	else    	 		return super.doCommand(commandName, arguments, commandRec, checker);		return null;   	 }   	/*.................................................................................................................*/	public NexusBlockTest getNexusBlockTest(){ return new CharHistoryBlockTest();}	/*.................................................................................................................*/	public NexusBlock readNexusBlock(MesquiteFile file, String name, FileBlock block, StringBuffer blockComments, String fileReadingArguments){		Parser commandParser = new Parser();		commandParser.setString(block.toString());		MesquiteInteger startCharC = new MesquiteInteger(0);		String title=null;		String commandString;		MesquiteTree tree = null;		Taxa taxa= null;		if (getProject().getNumberTaxas(file)==1)			taxa = getProject().getTaxa(file, 0); //as default		else if (getProject().getNumberTaxas()==1)			taxa = getProject().getTaxa(0); //as default		NexusBlock b=null;		CharacterHistory cHistory =null;		int numChars=0;		CharacterState state = null;		boolean oldLineEndDark = false;		while (!StringUtil.blank(commandString=commandParser.getNextCommand(startCharC))) {			String commandName = parser.getFirstToken(commandString);			if (commandName.equalsIgnoreCase("TITLE")) {				title = StringUtil.deTokenize(parser.getTokenNumber(2));				logln("Reading CHARACTERHISTORY block " + title);			}			else if (commandName.equalsIgnoreCase("TAXA")) {				String taxaTitle = StringUtil.deTokenize(parser.getTokenNumber(2));				//logln("       for taxa " + taxaTitle);				taxa = getProject().getTaxa(taxaTitle);				if (taxa == null) {					if (getProject().getNumberTaxas()==1)						taxa = getProject().getTaxa(0);					else						alert("Taxa block not found for character history block");				}			}			else if (commandName.equalsIgnoreCase("TREE")) {				if (taxa == null) {					if (getProject().getNumberTaxas()==1)						taxa = getProject().getTaxa(0);				}				if (taxa!=null) {					tree = new MesquiteTree(taxa);					tree.readTree(parser.getTokenNumber(2));				}			}			else if (commandName.equalsIgnoreCase("DATATYPE")) {				if (tree!=null) {					String stateClassName = parser.getTokenNumber(2);					try {						Class c = Class.forName(stateClassName);						state = (CharacterState)c.newInstance();						if (state!=null) {							cHistory = state.makeCharacterHistory(tree.getTaxa(), tree.getNumNodeSpaces());							cHistory.setName(title);						}					}					catch (ClassNotFoundException e){alert("cnfe cs");}					catch (IllegalAccessException e){alert("iae cs");					e.printStackTrace(); }					catch (InstantiationException e){alert("ie cs");e.printStackTrace(); }				}			}			else if (commandName.equalsIgnoreCase("HISTORY")) {				MesquiteInteger pos = new MesquiteInteger(parser.getPosition());				readHistoryString(tree, tree.getRoot(), cHistory, commandString, pos, state);	    	 		StoredCharacterHistory sHistory = new StoredCharacterHistory(cHistory, tree);	    	 		if (sHistory!=null) {	    	 			sHistory.setName(title);					sHistory.setFile( getProject().getHomeFile(), false);  //TODO: should allow user to choose if more than one file		    	 		getProject().addFileElement(sHistory);	    	 		} //TODO: should set current tree to show this one if stored trees used				NexusBlock nb = findNEXUSBlock(sHistory);				if (nb==null){					CharacterHistoryBlock cb = new CharacterHistoryBlock(sHistory.getFile(), this);					cb.setHistory(sHistory);					b = cb;				}				else b = nb;			}			else if (commandName.equalsIgnoreCase("OBSERVED")) {				MesquiteInteger pos = new MesquiteInteger(parser.getPosition());				AdjustableDistribution observed = state.makeAdjustableDistribution(tree.getTaxa(), tree.getTaxa().getNumTaxa());				for (int node = 0; node< observed.getNumNodes() && pos.getValue()<commandString.length(); node++){					state.setValue(commandString, pos);					observed.setCharacterState(node, state);				}				if (cHistory !=null)					cHistory.setObservedStates((CharacterDistribution)observed);			}			else if (b != null && !(commandName.equalsIgnoreCase("BEGIN") || commandName.equalsIgnoreCase("END")  || commandName.equalsIgnoreCase("ENDBLOCK"))) 				readUnrecognizedCommand(file,b, name, block, commandName, commandString, blockComments, null);		}		return b;	}	void readHistoryString(Tree tree, int node, CharacterHistory history, String s, MesquiteInteger pos, CharacterState state){		state.setValue(s, pos);		history.setCharacterState(node, state);		for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))				readHistoryString(tree, daughter, history, s, pos, state);	}	/*.................................................................................................................*/    	 public String getName() {		return "Manage CHARACTERHISTORY blocks";   	 }	/*.................................................................................................................*/ 	/** returns an explanation of what the module does.*/ 	public String getExplanation() { 		return "Coordinates the management of stored character histories." ;   	 }}	/* ======================================================================== */class CharacterHistoryBlock extends NexusBlock {	StoredCharacterHistory history;	public CharacterHistoryBlock(MesquiteFile f, ManageCharHistories mb){		super(f,mb);	}	public void written() {		history.setDirty(false);	}	public boolean mustBeAfter(NexusBlock block){		if (block==null)			return false;		return (block.getBlockName().equalsIgnoreCase("TREES") ||  block.getBlockName().equalsIgnoreCase("TAXA"));			}	public String getBlockName(){		return "CHARACTERHISTORY";	}	public boolean contains(FileElement e) {				return e==history;	}	public void setHistory(StoredCharacterHistory history){		this.history = history;	}	public String getName(){		return "CHARACTERHISTORY block";	}	void writeHistoryString(Tree tree, int node, CharacterHistory history, MesquiteString s){		s.append(" " + history.toString(node, StringUtil.lineEnding()));		for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))				writeHistoryString(tree, daughter, history, s);	}	public String getNEXUSBlock(){		if (history == null || history.getTree()==null || history.getHistory()==null)			return null;		CharacterHistory h = history.getHistory();		String block = "BEGIN CHARACTERHISTORY;"+ StringUtil.lineEnding();		block += "TITLE " + ParseUtil.tokenize(history.getName()) + ";" + StringUtil.lineEnding();		Tree tree = history.getTree();		Taxa taxa = tree.getTaxa();		block += "Taxa " + ParseUtil.tokenize(taxa.getName()) + ";" + StringUtil.lineEnding();		block += "Tree " + ParseUtil.tokenize(tree.writeTree(Tree.BY_NAMES)) + ";" + StringUtil.lineEnding();		block += "DATATYPE " + ParseUtil.tokenize(h.getStateClass().getName()) + ";" + StringUtil.lineEnding();		block += "HISTORY ";		MesquiteString ms = new MesquiteString("");		writeHistoryString(tree, tree.getRoot(), h, ms);		block += ms.getValue();		//for (int i=0; i<h.getNumNodes(); i++)		//	block += " " + h.toString(i) + " ";		block += ";" + StringUtil.lineEnding();		if (h.getObservedStates()!=null){			block += "OBSERVED ";			for (int i=0; i<h.getObservedStates().getNumNodes(); i++)				block += " " + h.getObservedStates().toString(i, StringUtil.lineEnding()) + " ";			block += ";" + StringUtil.lineEnding();		}		block += "END;" + StringUtil.lineEnding();		return block;	}}/* ======================================================================== */class CharHistoryBlockTest extends NexusBlockTest  {	public CharHistoryBlockTest () {	}	public  boolean readsWritesBlock(String blockName, FileBlock block){ //returns whether or not can deal with block		return blockName.equalsIgnoreCase("CHARACTERHISTORY");	}}