/* Mesquite source code.  Copyright 1997-2005 W. Maddison and D. Maddison. Version 1.06, September 2005.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.align.lib; import java.util.*;import java.awt.*;import java.awt.image.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.lib.table.*;import mesquite.categ.lib.*;import java.util.zip.*;/* ======================================================================== */public class TempMover {	CategoricalData data;	public TempMover(CategoricalData data) {		this.data = data;	}   	//===================================================	/*.................................................................................................................*/	public int checkDistanceAvailable(int distance, int startBlock, int endBlock, int it, MesquiteBoolean isTerminalBlock, MesquiteInteger boundaryOfAvailableSpace){   		boolean terminalBlock=false;   		int gapsAvailable = 0;    		int g=0;    		if (distance>0){ //moving right	   			//first check to see whether gaps are to the right 	   			g = endBlock+1;  // start one past end of block  	   			while (g<data.getNumChars() && data.isInapplicable(g, it))  //counting gaps beyond the current one	   				g++;	   			if (g>=data.getNumChars()) //we reached the end and all gaps	   				terminalBlock = true;	   			g--;  //decrement by one as we must be one over what we should be.  g now stores the number of the last available character	   			gapsAvailable = g-endBlock;	   			if (!terminalBlock && distance>gapsAvailable) {	   				distance = gapsAvailable;	   			}   		}   		else if (distance<0){ //moving left   			//first check to see whether gaps can eat at end   			g = startBlock-1;   			while (g>=0 && data.isInapplicable(g, it))  //counting terminal gaps   				g--;   			if (g<0)   				terminalBlock=true;   			g++;   			gapsAvailable = startBlock-g;   			if (!terminalBlock && distance<-gapsAvailable) {   				distance = -gapsAvailable;   			}    		}    		isTerminalBlock.setValue(terminalBlock);	   	boundaryOfAvailableSpace.setValue(g);		return distance;	}	/*.................................................................................................................*/	CharacterState moveOne(int i, int distance, int it, CharacterState cs, String[][] footnotes, Vector cellObjects, MesquiteBoolean dataChanged){		cs = data.getCharacterState(cs, i, it);		if (cs==null)			return null;		data.setState(i+distance, it, cs);		cs.setToInapplicable();		data.setState(i, it, cs);		dataChanged.setValue(true);				if (i+distance>=0){			//footnotes			if (footnotes!=null){				footnotes[i+distance][it] = footnotes[i][it];				footnotes[i][it]=null;			}						//cell objects			if (cellObjects !=null)				for (int k =0; k<cellObjects.size(); k++){					Object2DArray objArray = (Object2DArray)cellObjects.elementAt(k);					Object[][] objects = objArray.getMatrix();					objects[i+distance][it] = objects[i][it];					objects[i][it]=null;				}		}		return cs;	}	/*.................................................................................................................*/	/** moves the cells from character startBlock to character endBlock a distance "distance" for taxon it.  	If canExpand is set, then the procedure will add characters to the front or end of the matrix. 	If canOverwrite is set, then the procedure can overwrite data (otherwise it can only overwrite inapplicable cells).		Returns how many characters are added to the front (if value is -ve) or end (if value is +ve) of the matrix.	*/   	public int move(int startBlock, int endBlock, int distance, int it,  boolean canExpand, boolean canOverwrite, boolean notify, MesquiteBoolean dataChanged){  //startBlock and endBlock are 0-based   		CharacterState cs = null;		String[][] footnotes = data.getFootnotes();		Vector cellObjects = data.getCellObjectsVector();   		MesquiteBoolean isTerminalBlock = new MesquiteBoolean(false);   		MesquiteInteger boundaryOfAvailableSpace = new MesquiteInteger(0);   		int gapsAvailable = 0;   		int g = 0;   		int openUp = 0;   		int added = 0;   		   		if (distance>0){ //moving right			if (!canOverwrite) //adjust distance to avoid overwriting				distance = checkDistanceAvailable(distance, startBlock, endBlock, it, isTerminalBlock, boundaryOfAvailableSpace);	   				g = boundaryOfAvailableSpace.getValue();		   			if (isTerminalBlock.getValue() && canExpand) {	   			openUp = distance-(data.getNumChars()-endBlock)+1;	   			if (openUp>0) {  //makeNewCharacters	   				data.addCharacters(data.getNumChars(), openUp, false);	   				added = openUp;	   				g = data.getNumChars();	   				footnotes = data.getFootnotes(); //need to get again in case changed due to expansion	   				cellObjects = data.getCellObjectsVector();	   				dataChanged.setValue(true);	   			}   			}   			   			//now move from end   			for (int i = g-distance; i>=startBlock; i--){   				cs = moveOne(i, distance, it, cs, footnotes, cellObjects, dataChanged);   			}   		}    		else if (distance<0){ //moving left   			if (!canOverwrite) //adjust distance to avoid overwriting				distance = checkDistanceAvailable(distance, startBlock, endBlock, it, isTerminalBlock, boundaryOfAvailableSpace);	   				g = boundaryOfAvailableSpace.getValue();		   			if (isTerminalBlock.getValue() && canExpand) {	   			openUp = -distance-startBlock;	   				   			//if not then make new characters	   			if (openUp>0) {	   				data.addCharacters(-1, openUp, false);	   				added = -openUp;	   				footnotes = data.getFootnotes();//need to get again in case changed due to expansion	   				cellObjects = data.getCellObjectsVector();	   				dataChanged.setValue(true);	   				startBlock += openUp;	   				endBlock += openUp;	   			}   			}   			   			//now move from front end   			for (int i = startBlock; i<=endBlock; i++){   				cs = moveOne(i, distance, it, cs, footnotes, cellObjects, dataChanged);   			} 		} 		return added;   	}	/*.................................................................................................................*/   	public int shiftSequence(int distance, int it,  boolean canExpand,  boolean notify, MesquiteBoolean dataChanged){  //startBlock and endBlock are 0-based   		int first = data.firstApplicable(it);   		int last = data.lastApplicable(it);   		if (first<0)   			return 0;   		else   			return move(first,last, distance, it, canExpand, false, notify, dataChanged);   	}}