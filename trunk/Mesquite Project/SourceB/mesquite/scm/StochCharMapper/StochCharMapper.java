/* Mesquite.  Copyright 1997-2005 W. Maddison, D. Maddison & Peter Midford. Version 1.06, August 2005.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.scm.StochCharMapper;/*~~  */import java.util.*;import java.awt.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.categ.lib.*;import mesquite.cont.lib.*;import mesquite.stochchar.lib.*;import mesquite.stochchar.CurrentProbModels.*;/* ======================================================================== */public class StochCharMapper extends CharMapper {	CharacterDistribution observedStates;	MargLikeAncStCLForModel reconstructTask;	ProbModelSourceLike modelTask;	MesquiteString modelTaskName;	ProbPhenCategCharModel model;  //CharacterModel model;  - temporary restriction to nonMolecular models PEM 6-Jan-2006	MesquiteNumber likelihood;	boolean warnedNoCalc = false;	CharacterHistory statesAtNodes;	int oldNumTaxa;	boolean oneAtATime = false;	boolean oneAtATimeCHGBL = false;    Random generator;    double pi_s[]; 	MesquiteLong seed; 	long originalSeed=System.currentTimeMillis(); //0L;  		/*  get prior from modelenable prior editing within modelshandle models needing estimation	*/	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName) { 		hireAllEmployees(commandRec, MargLikeAncStCLForModel.class);		for (int i = 0; i<getNumberOfEmployees() && reconstructTask==null; i++) {			Object e=getEmployeeVector().elementAt(i);			if (e instanceof MargLikeAncStCLForModel)				((MargLikeAncStCLForModel)e).setReportCladeLocalValues(true);			}		if (modelTask == null) 			modelTask = (ProbModelSourceLike)hireEmployee(commandRec, ProbModelSourceLike.class, "Source of probability character models (for likelihood calculations)"); 		if (modelTask == null) 			return sorry(commandRec, getName() + " couldn't start because no source of models of character evolution obtained."); 		modelTaskName = new MesquiteString(modelTask.getName()); 		likelihood = new MesquiteNumber();    	 	seed = new MesquiteLong(1);    	 	seed.setValue(originalSeed);       generator = new Random(originalSeed);  //seed?		MesquiteSubmenuSpec mss = addSubmenu(null, "Source of probability models", makeCommand("setModelSource", this), ProbModelSourceLike.class);		mss.setCompatibilityCheck(new ModelCompatibilityInfo(ProbabilityCategCharModel.class, null));		mss.setSelected(modelTaskName); 		addMenuItem("Set Seed (Stoch. Char. Map.)...", makeCommand("setSeed",  this));		return true; 	} 	   	public void setOneCharacterAtATime(boolean chgbl){		oneAtATimeCHGBL = chgbl;		oneAtATime = true;   		modelTask.setOneCharacterAtATime(chgbl);   	}	/*.................................................................................................................*/	/** returns whether this module is requesting to appear as a primary choice */   	public boolean requestPrimaryChoice(){   		return true;     	}	/*.................................................................................................................*/  	 public Snapshot getSnapshot(MesquiteFile file) {   	 	Snapshot temp = new Snapshot();  	 	temp.addLine("setModelSource ",modelTask);   	 	temp.addLine("setSeed " + originalSeed); 	 	return temp;  	 }	MesquiteInteger pos = new MesquiteInteger();	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {    	 	if (checker.compare(this.getClass(), "Sets module used to supply character models", "[name of module]", commandName, "setModelSource")) {    	 		ProbModelSourceLike temp=  (ProbModelSourceLike)replaceEmployee(commandRec, ProbModelSourceLike.class, arguments, "Source of probability character models", modelTask); 			if (temp!=null) { 				modelTask= temp; 				incrementMenuResetSuppression(); 				modelTaskName.setValue(modelTask.getName()); 				if (oneAtATime) 					modelTask.setOneCharacterAtATime(oneAtATimeCHGBL);				parametersChanged(null, commandRec); 				decrementMenuResetSuppression(); 			} 			return modelTask;    	 	}    	 else if (checker.compare(this.getClass(), "Sets the random number seed to that passed", "[long integer seed]", commandName, "setSeed")) {    	 		long s = MesquiteLong.fromString(parser.getFirstToken(arguments));    	 		if (!MesquiteLong.isCombinable(s)){    	 			s = MesquiteLong.queryLong(containerOfModule(), "Random number seed", "Enter an integer value for the random number seed for character evolution simulation", originalSeed);    	 		}    	 		if (MesquiteLong.isCombinable(s)){    	 			originalSeed = s;	    	 		seed.setValue(originalSeed); 				parametersChanged(null, commandRec); //? 			}    	 		return null;    	 	}    	 	else    	 		return super.doCommand(commandName, arguments, commandRec, checker);   	 } 		/*.................................................................................................................*/ 	public void employeeQuit(MesquiteModule m){ 		if (m == modelTask) 			iQuit(); 	}	public boolean allowsStateWeightChoice(){		return false;	}  	private long loopSeed(int ic){		generator.setSeed(originalSeed);		long rnd = originalSeed;		for (int i = 0; i<ic; i++)			rnd =  generator.nextInt();		return rnd + 1;    	} 	boolean warned = false; 	boolean verbose = false; 	CharacterData oldData = null; 	CategoricalHistory cladeLikelihoods = null;	ProbabilityCategCharModel tempModel;	Tree tree; 	/*.................................................................................................................*/ 	public  int getNumberOfMappings(CommandRecord commandRec){		return MesquiteInteger.infinite;	}	/*.................................................................................................................*/	public  void setObservedStates(Tree tree, CharacterDistribution observedStates, CommandRecord commandRec){		if(verbose) Debugg.println("setObservedStates ");					this.observedStates = observedStates;		if (tree==null || observedStates==null)			return;		this.tree = tree;		likelihood.setToUnassigned();		cladeLikelihoods = (CategoricalHistory)observedStates.adjustHistorySize(tree, cladeLikelihoods);		/* At present this redoes the likelihood calculations each time before sampling a history.  		 * In future the likelihood calculations should be done once and cached, and redone only if tree or observedStates have changed		 * since last request */		//a barrier (temporary) while likelihood calculations support only simple categorical		Class stateClass = observedStates.getStateClass();		if (DNAState.class.isAssignableFrom(stateClass) || ProteinState.class.isAssignableFrom(stateClass) || ContinuousState.class.isAssignableFrom(stateClass)) {			String s = "Likelihood calculations cannot be performed ";			if (DNAState.class.isAssignableFrom(stateClass))				s += "currently with DNA or RNA data.  The calculations were not done for some characters.";			else if (ProteinState.class.isAssignableFrom(stateClass))				s += "currently with protein data.  The calculations were not done for some characters.";			else if (ContinuousState.class.isAssignableFrom(stateClass))				s += "currently with continuous valued data.  The calculations were not done for some characters.";			if (!warnedNoCalc) {				discreetAlert(commandRec, s);				warnedNoCalc = true;			}			return;		}		//getting the model        if (modelTask.getCharacterModel(observedStates, commandRec) instanceof ProbPhenCategCharModel )            model = (ProbPhenCategCharModel)modelTask.getCharacterModel(observedStates, commandRec);        if (model == null && !commandRec.scripting()){			if (observedStates.getParentData()!= oldData)				warned = false;			if (!warned){				if (observedStates.getParentData()!=null && modelTask instanceof CurrentProbModels) {					oldData = observedStates.getParentData();					if (AlertDialog.query(containerOfModule(), "Assign models?", "There are currently no probability models assigned to the characters.  Do you want to assign a model to all characters unassigned?")) {						((CurrentProbModels)modelTask).chooseAndFillUnassignedCharacters(observedStates.getParentData());                           if (modelTask.getCharacterModel(observedStates, commandRec) instanceof ProbPhenCategCharModel )                               model = (ProbPhenCategCharModel)modelTask.getCharacterModel(observedStates, commandRec);                           else AlertDialog.notice(containerOfModule(),"Incompatible model","The model you selected is not compatible with Stochastic Character Mapping at this time.");                    }				}				else {					discreetAlert(commandRec, "Sorry, there is no probabilistic model of evolution available for the character; likelihood calculations cannot be accomplished.  Please make sure that the source of models chosen is compatible with this character type.");					warned = true;					return;				}			}			warned = true;		}				//getting the reconstructing module		if (reconstructTask == null || !reconstructTask.compatibleWithContext(model, observedStates)) { 			reconstructTask = null;			for (int i = 0; i<getNumberOfEmployees() && reconstructTask==null; i++) {				Object e=getEmployeeVector().elementAt(i);				if (e instanceof MargLikeAncStCLForModel)					if (((MargLikeAncStCLForModel)e).compatibleWithContext(model, observedStates)) {						reconstructTask=(MargLikeAncStCLForModel)e;					}			}		}				//doing the likelihood calculations		if (reconstructTask != null) {             //========  1 ===========            if (verbose) Debugg.println("Step 1");			//Nielsen's Step 1:  calculate the clade likelihoods.  In the future this will be done once and cached	 		if (tempModel == null || tempModel.getClass() != model.getClass()){				tempModel = (ProbabilityCategCharModel)model.cloneModelWithMotherLink(null);			}			model.copyToClone(tempModel);			model = (ProbPhenCategCharModel)tempModel;          	reconstructTask.estimateParameters( tree,  observedStates,  model, null,   commandRec);			reconstructTask.calculateStates( tree,  observedStates,  cladeLikelihoods, model, null, likelihood, commandRec);		}		else {			String s = "Stochastic mapping cannot be performed because no module was found to perform the calculations for the probability model \"" + model.getName() + "\" with the characters specified.";							if (!warnedNoCalc) {				discreetAlert(commandRec, s);				warnedNoCalc = true;			}		}	}	  	public   void getMapping(int im, CharacterHistory resultStates, MesquiteString resultString, CommandRecord commandRec){	 		if (tree==null || observedStates==null || resultStates == null || !(resultStates instanceof CategoricalHistory))				return; 			resultStates.deassignStates();			if (verbose) Debugg.println("Step 2a");  			loopSeed(im);  			if (verbose) Debugg.println("mapping " + im);			 			//now take clade likelihoods and make a sampled history 			//get a copy of the results; we will then modify them into the sampled history			resultStates = cladeLikelihoods.clone(resultStates);			CategoricalHistory sampledHistory = (CategoricalHistory)resultStates;        //========  2a ===========			//Nielsen's Step 2a: choose a state at the root based on prior at root and root likelihood's             int stateCount = cladeLikelihoods.getMaxState()+1;             if (stateCount>model.getMaxState()+1)            	 	stateCount= model.getMaxState()+1;             //if (verbose) Debugg.println("cladeLikelihoods thinks maxState is" + maxState);             //model.getRootState(tree);             // set these 'flat' to begin with  -- ought to set these from the model.             pi_s = new double[stateCount];  //these are the pi(i)'s             double stationaryValue = 1.0/(1.0*stateCount);             for (int i = 0;i<stateCount;i++)                 pi_s[i]=model.priorProbability(i);                          double denominator = 0.0;             for (int possibleState = 0; possibleState<stateCount;possibleState++){                 double stateFrequency = cladeLikelihoods.getFrequency(tree.getRoot(),possibleState);                 if (verbose) Debugg.println("At root; stateFrequency for state " + possibleState + " is " + stateFrequency);                 if (MesquiteDouble.isCombinable(stateFrequency))                     denominator += pi_s[possibleState]*stateFrequency;             }             if (denominator == 0)  // something's gone wrong                 Debugg.printStackTrace("2a Bad denominator in root likelihood calculations " );             if (verbose) Debugg.println("Denominator is " + denominator);             double sum = 0.0;             double randomValue = generator.nextDouble();             for (int candidate = 0;candidate<stateCount;candidate++) {                 double candidateFrequency = cladeLikelihoods.getFrequency(tree.getRoot(),candidate);                 if (MesquiteDouble.isCombinable(candidateFrequency)) {                     sum += (pi_s[candidate]*candidateFrequency)/denominator;                     if (sum > randomValue) {                         sampledHistory.setState(tree.getRoot(),CategoricalState.makeSet(candidate));                         sampledHistory.addInternodeEvent(tree.getRoot(), new CategInternodeEvent(CategoricalState.makeSet(candidate), 0, false));                         if (verbose) Debugg.println("I picked " + candidate + " at the root.");                         break;                     }                 }             }                          if (verbose) Debugg.println("sampledHistory at root is set to " + sampledHistory.getState(tree.getRoot()));                                       //========  2b ===========           //Nielsen's Step 2b: then go up through the tree recursively choosing a state at each node based on its clade likelihoods and the state chosen for its immediate ancestor              if (verbose) Debugg.println("Step 2b");             sampleStatesUp(tree,tree.getRoot(),cladeLikelihoods,sampledHistory,model);			           //========  3 ===========			//Nielsen's Step 3:  sample changes along the internodes 			if (verbose) Debugg.println("Step 3");            sampleInternodeChanges(tree,tree.getRoot(),sampledHistory,model);						//cycle through random numbers  to get to the seed for the current sample			//for (int i = 0; i< sampledHistory.getNumNodes(); i++){			//	sampledHistory.addInternodeEvent(i, new CategInternodeEvent(1L, 0.2, true));			//	sampledHistory.addInternodeEvent(i, new CategInternodeEvent(2L, 0.4, true));			//	sampledHistory.addInternodeEvent(i, new CategInternodeEvent(4L, 0.6, true));			//	sampledHistory.addInternodeEvent(i, new CategInternodeEvent(1L, 0.8, true));			//	sampledHistory.addInternodeEvent(i, new CategInternodeEvent(2L, 1.0, true));			//}									if (resultString!=null)				resultString.append(" Calc. by " + reconstructTask);		statesAtNodes=resultStates;	}        // This implements the recursion for Nielsen's step 2b    private void sampleStatesUp(Tree tree,int node,CategoricalHistory cladeLikelihoods,CategoricalHistory sampledHistory,ProbPhenCategCharModel model){        int stateCount = cladeLikelihoods.getMaxState()+1;  // Pass this in?             if (stateCount>model.getMaxState()+1)            	 	stateCount= model.getMaxState()+1;        if (node != tree.getRoot()) {            int motherSampledState = CategoricalState.getOnlyElement(sampledHistory.getState(tree.motherOfNode(node)));            sampledHistory.addInternodeEvent(node, new CategInternodeEvent(sampledHistory.getState(tree.motherOfNode(node)), 0, false));            // ask the model for transition values from the mother's state to each of the candidate states            if (verbose) Debugg.println("Mother is " + tree.motherOfNode(node)+ " SampledState is "+ sampledHistory.getState(tree.motherOfNode(node)));            double Pij[] = new double[stateCount];            for (int j=0;j<stateCount;j++){                Pij[j]= model.transitionProbability(motherSampledState,j,tree,node);                if (verbose) Debugg.println("Pij["+node+","+j+"] set to "+ Pij[j]);            }            double denominator = 0.0;            for (int possibleState = 0; possibleState < stateCount;possibleState++){                double stateFrequency = cladeLikelihoods.getFrequency(tree.getRoot(),possibleState);                if (MesquiteDouble.isCombinable(stateFrequency))                    denominator += Pij[possibleState]*stateFrequency;            }            if (denominator == 0)  // something's gone wrong                Debugg.printStackTrace("2b Bad denominator in node likelihood calculations " + stateCount);            double sum = 0.0;            double randomValue = generator.nextDouble();            for (int candidate = 0;candidate<stateCount;candidate++) {                double candidateFrequency = cladeLikelihoods.getFrequency(node,candidate);                if (MesquiteDouble.isCombinable(candidateFrequency)) {                    sum += (Pij[candidate]*candidateFrequency)/denominator;                    if (sum > randomValue) {                        sampledHistory.setState(node,CategoricalState.makeSet(candidate));                         if (verbose) Debugg.println("I picked " + candidate + " at node " + node);                        break;                    }                }            }        }        if (tree.nodeIsInternal(node)){            for(int d=tree.firstDaughterOfNode(node);tree.nodeExists(d);d=tree.nextSisterOfNode(d)) {                sampleStatesUp(tree,d,cladeLikelihoods,sampledHistory,model);            }                    }    }    	/*.................................................................................................................*/    /** This implements the recursion for Nielsen's step 3 */    private void sampleInternodeChanges(Tree tree,int node,CategoricalHistory sampledHistory,ProbPhenCategCharModel model) {        if (node != tree.getRoot()) {            int startState = CategoricalState.getOnlyElement(sampledHistory.getState(tree.motherOfNode(node)));            int endState = CategoricalState.getOnlyElement(sampledHistory.getState(node));            double iRate = model.instantaneousRate(startState,endState,tree,node);            double branchLength = tree.getBranchLength(node);            Vector internodeEvents = null;                        internodeEvents = doSimulation(tree,node,startState,endState,model,cladeLikelihoods);                    if (internodeEvents != null) {                Iterator eventIterator = internodeEvents.iterator();                while(eventIterator.hasNext()){                    sampledHistory.addInternodeEvent(node,(CategInternodeEvent)eventIterator.next());                }            }        }        if (tree.nodeIsInternal(node)){            for(int d=tree.firstDaughterOfNode(node);tree.nodeExists(d);d=tree.nextSisterOfNode(d))                 sampleInternodeChanges(tree,d,sampledHistory, model);        }          }     	/*.................................................................................................................*/   private Vector doSimulation(Tree tree, int node, int start, int end, ProbPhenCategCharModel model,CategoricalHistory cladeLikelihoods){        double nextLength;        double totalLength;        double branchLength = tree.getBranchLength(node);        Vector result;        int nextState;        int stateCount = cladeLikelihoods.getMaxState()+1;        do {            result = null;            nextState = start;            totalLength = 0.0;            while (totalLength < branchLength){                double currentRate = model.instantaneousRate(nextState,nextState,tree,node);                nextLength = Math.log(generator.nextDouble())/currentRate;                if (nextLength+totalLength<branchLength) { // start recording                    if (result == null) result = new Vector();                    double denominator = 0.0;                    for(int i=0;i<stateCount;i++)                        if (i!=nextState)                            denominator += model.instantaneousRate(nextState,i,tree,node);                    double stateChoice = generator.nextDouble();                    double sum = 0.0;                    for (int candidate = 0;candidate<stateCount;candidate++) {                        if (candidate != nextState){                             double candidateRate = model.instantaneousRate(nextState,candidate,tree,node);                             if (MesquiteDouble.isCombinable(candidateRate)) {                                sum += model.instantaneousRate(nextState,candidate,tree,node)/denominator;                                if (sum > stateChoice) {                                    nextState = candidate;                                    if (verbose) Debugg.println("I picked " + candidate + " at time " + (nextLength+totalLength)/branchLength + " from node " + node);                                    CategInternodeEvent thisEvent = new CategInternodeEvent(CategoricalState.makeSet(candidate), (totalLength+nextLength)/branchLength, true);                                    result.addElement(thisEvent);                                    break;                                }                            }                        }                    }                }                totalLength +=nextLength;            }        } while(nextState != end);            return result;    }    	/*.................................................................................................................*/	/** Returns CompatibilityTest so other modules know if this is compatible with some object. */	public CompatibilityTest getCompatibilityTest(){		return new UniversalCategStateTest();	}   	/*.................................................................................................................*/    	 public String getName() {		return "Stochastic Character Mapping (Categorical)";   	 }	/*.................................................................................................................*/    	 public boolean showCitation() {		return true;   	 }	/*.................................................................................................................*/  	 public boolean isPrerelease() { //need to build algorithm!  Add control for replicate samples!		return true;   	 }	/*.................................................................................................................*/ 	/** returns an explanation of what the module does.*/ 	public String getExplanation() { 		return "Coordinates reconstruction of ancestral states using stochastic character mapping. " ;   	 }   	 }