/* Mesquite.cartographer source code.  Copyright 2005 D. Maddison, W. Maddison. Version 1.0, April 2005.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.cartographer.NodeLocsLongLat;/*~~  */import java.util.*;import java.awt.*;import java.text.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.cartographer.lib.*;import mesquite.cont.lib.*;/* ======================================================================== */public class NodeLocsLongLat extends TaxonLocsPlot {	Taxa taxa;	boolean noMapImageShown = false;	boolean showCommandGiven = false;	Point[] location;	String imagePath;	Image mapImage;	int margin = 30;	 static final String prefVersionNumber = "0.99";//	NumbersForNodesIncr numbersForNodesTask;	LocationReconstructor reconstructorTask;	CharSourceCoordObed characterSourceTask;	ContinuousDistribution observedStates;	Taxa currentTaxa;	Double2DArray originalCoordinates, modifiedCoordinates;	MesquiteString numberTaskName;	boolean veryFirstTime=true;	Vector extras;//	public MesquiteBoolean firstIsLatitude;   // if true, then the first character in the character source is the latitude, and the second is the longitude; otherwise it is the reverse.	protected MesquiteBoolean fadeMap;	private int mapWidth, mapHeight;	boolean hide = false;	CommandRecord startedAsScripting;	protected MapProjection projectionTask;	MesquiteString projectionName;	MesquiteCommand stC;	MesquiteCommand nfntC;	MesquiteString addTaxaGroup = new MesquiteString("");		TaxaTool longLatTool;	MesquiteCommand touchMapCommand;	MesquiteCommand moveOverMapCommand;	MesquiteCommand moveOverTaxonCommand;		TaxaTool searchWebTool;	MesquiteCommand mouseUpSearchCommand;	MesquiteCommand taxonSearchCommand;		TaxaTool addTaxonTool;	MesquiteCommand mouseUpTaxonAddTaxonCommand;	MesquiteCommand mouseUpFieldAddTaxonCommand;	TaxaTool moveTaxonTool;	MesquiteCommand touchTaxonMoveTaxonCommand;	MesquiteCommand dragTaxonMoveTaxonCommand;	MesquiteCommand mouseUpMoveTaxonCommand;		protected URLLongLatServer URLTask;	MesquiteCommand[] chooseURLTaskCommands = null;	static String defaultURLTask = null;		boolean treePlot = true;			/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName) { 		treePlot = !(getHiredAs()==TaxonLocsPlot.class); 				if (arguments ==null) 			projectionTask = (MapProjection)hireEmployee(commandRec, MapProjection.class, "Map Projection");	 	else {	 		projectionTask = (MapProjection)hireNamedEmployee(commandRec, MapProjection.class, arguments); 			if (projectionTask == null) 				projectionTask = (MapProjection)hireEmployee(commandRec, MapProjection.class, "Map Projection"); 		} 		if (projectionTask == null) { 			return sorry(commandRec, getName() + " couldn't start because no map projection was obtained."); 		} 		projectionTask.setOwnerModule(this); 		projectionTask.setTreePlot(treePlot); 			 				reconstructorTask = (LocationReconstructor)hireEmployee(commandRec, LocationReconstructor.class, "Location Reconstructor"); 		if (reconstructorTask == null) { 			return sorry(commandRec, getName() + " couldn't start because no task for reconstructing ancestral states was obtained."); 		} 		reconstructorTask.setProjectionTask(projectionTask); 		// now get the longitude and latitude values 		characterSourceTask = (CharSourceCoordObed)hireCompatibleEmployee(commandRec, CharSourceCoordObed.class, GeographicState.class, "Source of latitude and longitude data"); 		if (characterSourceTask == null) { 			return sorry(commandRec, getName() + " couldn't start because no source of characters obtained."); 		} 		 	 	stC = makeCommand("setProjection",  this); 	 	projectionTask.setHiringCommand(stC); 	 	projectionTask.setMargin(margin); 		projectionName = new MesquiteString();	   	 projectionName.setValue(projectionTask.getName());		if (numModulesAvailable(MapProjection.class)>1){			MesquiteSubmenuSpec mss = addSubmenu(null, "Map Projection", stC, MapProjection.class); 			mss.setSelected(projectionName);  		}  		startedAsScripting = commandRec;  		extras = new Vector();  		  		/*		numbersForNodesTask= (NumbersForNodesIncr)hireEmployee(commandRec, NumbersForNodesIncr.class, "Values to calculate for internal nodes for Plot Tree");		if (numbersForNodesTask == null )			return sorry(commandRec, getName() + " couldn't start because no modules calculating numbers for nodes obtained.");		nfntC = makeCommand("setInternalNodeCalculator",  this);		numbersForNodesTask.setHiringCommand(nfntC);		numberTaskName = new MesquiteString(numbersForNodesTask.getName());*/				makeMenu("Plot");		//MesquiteSubmenuSpec xsub = addSubmenu(null, "Map");		addMenuItem("Choose Base Map...", makeCommand("setMap",  this));//call this so that user can choose map//		firstIsLatitude = new MesquiteBoolean(true);//		addCheckMenuItem(null, "First Character is Latitude", makeCommand("toggleFirstLatitude",  this), firstIsLatitude);		fadeMap = new MesquiteBoolean(false);		if (MesquiteWindow.Java2Davailable)			addCheckMenuItem(null, "Fade Base Map", makeCommand("toggleFadeMap",  this), fadeMap);		longLatTool = new TreeTool(this, "longLat", getPath(), "longLatTool.gif", 8,8,"Latitude-Longitude Tool", "This tool allows you to examine the latitude and longitude of points on a map."); 		touchMapCommand = MesquiteModule.makeCommand("touchLongLat",  this);		longLatTool.setTouchedFieldCommand(touchMapCommand);		moveOverTaxonCommand = MesquiteModule.makeCommand("moveOverTaxonLongLat",  this);		longLatTool.setMoveOverTaxonCommand(moveOverTaxonCommand);				moveOverMapCommand = MesquiteModule.makeCommand("moveLongLat",  this);		longLatTool.setMovedCommand(moveOverMapCommand);		if (containerOfModule() instanceof MesquiteWindow) {			((MesquiteWindow)containerOfModule()).addTool(longLatTool);			//longLatTool.setPopUpOwner(this);		}/*adding the search tool*/		if (defaultURLTask!=null) {			URLTask= (URLLongLatServer)hireNamedEmployee(CommandRecord.scriptingRecord, URLLongLatServer.class, defaultURLTask);			if (URLTask == null)				URLTask = (URLLongLatServer)hireEmployee(CommandRecord.scriptingRecord, URLLongLatServer.class, "Latitude Longitude URL Provider");  // just hire first one		}		else			URLTask = (URLLongLatServer)hireEmployee(CommandRecord.scriptingRecord, URLLongLatServer.class, "Latitude Longitude URL Provider");  // just hire first one		if (URLTask!=null) {			searchWebTool = new TreeTool(this, "searchWeb", getPath(), "searchWebTool.gif", 3,3,"Search Web Tool", "This tool allows you to examine the points on a map in various web sites."); 			mouseUpSearchCommand = MesquiteModule.makeCommand("touchSearchWeb",  this);			searchWebTool.setMouseUpFieldCommand(mouseUpSearchCommand);			taxonSearchCommand = MesquiteModule.makeCommand("taxonSearchWeb",  this);			searchWebTool.setMouseUpTaxonCommand(taxonSearchCommand);			if (containerOfModule() instanceof MesquiteWindow) {				((MesquiteWindow)containerOfModule()).addTool(searchWebTool);				searchWebTool.setPopUpOwner(this); //setOptionsChoiceCommand or something like that, build menus in doCommand				searchWebTool.setOptionsCommand(MesquiteModule.makeCommand("searchWebToolOptions", this));			} else return false;		}/*adding the add and move taxon tools, only for the taxa window version*/		if (!treePlot) {			addTaxonTool = new TreeTool(this, "addTaxon", getPath(), "addTaxonTool.gif", 8,8,"Add Taxon Tool", "This tool allows you to add taxa to a map."); 			mouseUpFieldAddTaxonCommand = MesquiteModule.makeCommand("fieldAddTaxon",  this);			addTaxonTool.setMouseUpFieldCommand(mouseUpFieldAddTaxonCommand);			addTaxonTool.setIgnoreTaxa(true);			addTaxonTool.setOptionImageFileName("addTaxonToolOption.gif", 8, 8);			if (containerOfModule() instanceof MesquiteWindow) {				((MesquiteWindow)containerOfModule()).addTool(addTaxonTool);			} else return false;			moveTaxonTool = new TreeTool(this, "moveTaxon", getPath(), "moveTaxonTool.gif", 9,10,"Move Taxon Tool", "This tool allows you to move taxa to a map."); 			touchTaxonMoveTaxonCommand = MesquiteModule.makeCommand("touchMoveTaxon",  this);			moveTaxonTool.setTouchedTaxonCommand(touchTaxonMoveTaxonCommand);			mouseUpMoveTaxonCommand = MesquiteModule.makeCommand("mouseUpMoveTaxon",  this);			moveTaxonTool.setMouseUpTaxonCommand(mouseUpMoveTaxonCommand);			dragTaxonMoveTaxonCommand = MesquiteModule.makeCommand("dragMoveTaxon",  this);			moveTaxonTool.setDraggedTaxonCommand(dragTaxonMoveTaxonCommand);			if (containerOfModule() instanceof MesquiteWindow) {				((MesquiteWindow)containerOfModule()).addTool(moveTaxonTool);			} else return false;			checkToolValidity(commandRec);		}		if (!startedAsScripting.scripting()) {			loadOrChooseMap(null,startedAsScripting);			parametersChanged(null, commandRec);		}  		return true;  	 }	/*.................................................................................................................*/	public void processPreferencesFromFile (String[] prefs) {		if (prefs!=null && prefs.length>0) {			if (prefVersionNumber.equalsIgnoreCase(prefs[0])) {				defaultURLTask = prefs[1];			}		}	}	/*.................................................................................................................*/	public String[] preparePreferencesForFile () {		String[] prefs= new String[2];		prefs[0] = prefVersionNumber;		if (URLTask!=null)			prefs[1] = " ";		else			prefs[1] = defaultURLTask;		return prefs;	}  	/*.................................................................................................................*/  	public GeographicData getGeographicData(CommandRecord commandRec) {		observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa,0, commandRec);		if (observedStates==null)			return null;		GeographicData gData = (GeographicData)observedStates.getParentData();		return gData;  	}  	   	/*.................................................................................................................*/	/**  */	public void checkToolValidity(CommandRecord commandRec){ 		if (!treePlot) {			if (addTaxonTool!=null && moveTaxonTool!=null) {				addTaxonTool.setEnabled (getGeographicData(commandRec)!=null && projectionTask != null && projectionTask.getFullySpecified());				moveTaxonTool.setEnabled (getGeographicData(commandRec)!=null&& projectionTask != null && projectionTask.getFullySpecified());			}		}		if (searchWebTool!=null && projectionTask !=null) {			searchWebTool.setEnabled (projectionTask.getFullySpecified());		}		if (longLatTool!=null && projectionTask !=null) {			longLatTool.setEnabled (projectionTask.getFullySpecified());		}	}  	/*.................................................................................................................*/	/** Returns the preferred size (if any) of the tree drawing.  Insert your own! */	public Dimension getPreferredSize(){ 	//here return size requested (width, height).  If this changes, call parametersChanged(null, commandRec) so employers can respond and request again the preferred size		return new Dimension(getMapWidth()+2*margin, getMapHeight()+2*margin);	}  	/*.................................................................................................................*/	/** Returns whether this is a tree plot or taxa plot */	public boolean getTreePlot(){ 		return treePlot;	}  	/*.................................................................................................................*/	    	public void endJob(){   		hide = true;  	 	if (extras!=null) {	   		for (int i=0; i<extras.size(); i++){	   			if (treePlot) {		   			TreeDisplayExtra extra = (TreeDisplayExtra)extras.elementAt(i);			   		if (extra!=null){			   			TreeDisplay td = extra.getTreeDisplay();			   			extra.turnOff();			   			if (td!=null)			   				td.removeExtra(extra);			   		}	   			}	   			else {		   			TaxaDisplayExtra extra = (TaxaDisplayExtra)extras.elementAt(i);			   		if (extra!=null){			   			TaxaDisplay td = extra.getTaxaDisplay();			   			extra.turnOff();			   			if (td!=null)			   				td.removeExtra(extra);			   		}	   			}	   		}	   		extras.removeAllElements();  	 	}		if (longLatTool!=null)			((MesquiteWindow)containerOfModule()).removeTool(longLatTool);		if (searchWebTool!=null)			((MesquiteWindow)containerOfModule()).removeTool(searchWebTool);		if (addTaxonTool!=null)			((MesquiteWindow)containerOfModule()).removeTool(addTaxonTool);		if (moveTaxonTool!=null)			((MesquiteWindow)containerOfModule()).removeTool(moveTaxonTool);  		super.endJob();   	}	/*.................................................................................................................*/	public  Class getHireSubchoice(){		return MapProjection.class;	}   	/** Called to provoke any necessary initialization.  This helps prevent the module's intialization queries to the user from   	happening at inopportune times (e.g., while a long chart calculation is in mid-progress)*/   	public void initialize(Tree tree, CommandRecord commandRec){   		currentTaxa = tree.getTaxa();   		characterSourceTask.initialize(currentTaxa, commandRec);   	}	/*.................................................................................................................*/	public int getMargin(){		return margin;	}	/*.................................................................................................................*/	public boolean inMapField(int x, int y){		return (x>=getMargin() && x<= getMargin()+ getMapWidth() && y>=getMargin() && y<=getMargin()+getMapHeight());	}	/*.................................................................................................................*/	public MapProjection getProjectionTask(){		return projectionTask;	}	/*.................................................................................................................*/   	public boolean isSubstantive(){   		return true;   	}   	public boolean isPrerelease(){   		return false;   	}	/*.................................................................................................................*/   	 public boolean getFadeMap(){   	 	return fadeMap.getValue();   	 }	/*.................................................................................................................*/   	 public boolean showCitation(){   	 	return true;   	 }	/*.................................................................................................................*/ 	public void employeeParametersChanged(MesquiteModule employee, MesquiteModule source, Notification notification, CommandRecord commandRec) {  	 	if (extras!=null) {	   		for (int i=0; i<extras.size(); i++){				if (!treePlot) {		   			NodeLocsLongLatTaxaExtra extra = (NodeLocsLongLatTaxaExtra)extras.elementAt(i);			   		if (extra!=null){	 					extra.pleaseAdjustScrolls=true;			   		}		   		}		   		else {		   			NodeLocsLongLatExtra extra = (NodeLocsLongLatExtra)extras.elementAt(i);			   		if (extra!=null){	 					extra.pleaseAdjustScrolls=true;			   		}		   		}	   		}  	 	}    	 	parametersChanged(notification, commandRec);    	 	checkToolValidity(commandRec);    	 	   	 }	/*.................................................................................................................*/	public Image getMapImage() {		return mapImage;	}	/*.................................................................................................................*/	public int getMapHeight() {		if (!treePlot) {			NodeLocsLongLatTaxaExtra firstExtra = getFirstTaxaExtra();			if (firstExtra!=null && mapImage!=null)				return mapImage.getHeight(firstExtra.getTaxaDisplay());		}		else {			NodeLocsLongLatExtra firstExtra = getFirstExtra();			if (firstExtra!=null && mapImage!=null)				return mapImage.getHeight(firstExtra.getTreeDisplay());		}		return 200;	}	/*.................................................................................................................*/	public int getMapWidth() {		if (!treePlot) {			NodeLocsLongLatTaxaExtra firstExtra = getFirstTaxaExtra();			if (firstExtra!=null && mapImage!=null)				return mapImage.getWidth(firstExtra.getTaxaDisplay());		}		else {			NodeLocsLongLatExtra firstExtra = getFirstExtra();			if (firstExtra!=null && mapImage!=null)				return mapImage.getWidth(firstExtra.getTreeDisplay());		}		return 200;	}	/*.................................................................................................................*/	public boolean loadOrChooseMap(String path, CommandRecord commandRec) {		MesquiteString ms = new MesquiteString();		noMapImageShown = false;		Image image = null;		boolean canReplaceWithNoMapImage = true;		Component display = null;		if (!treePlot) {			NodeLocsLongLatTaxaExtra firstExtra = getFirstTaxaExtra();			if (firstExtra!=null)				display = firstExtra.getTaxaDisplay();		}		else {			NodeLocsLongLatExtra firstExtra = getFirstExtra();			if (firstExtra!=null)				display = firstExtra.getTreeDisplay();		}		if (display!=null) {				if (mapImage!=null) {   // we already have a map, which means this is being called to choose another one					image = MesquiteImage.loadImage("Choose  map:", null, display, commandRec, ms);					canReplaceWithNoMapImage = false;  // set this so that we don't replace with noMap image if image==null here because of user pressing cancel				}				else {    // we don't have a map, which means this just loads the image				    	 image = MesquiteImage.loadImage("Choose map:", path, display, commandRec, ms);				}				((TaxaTreeDisplay)display).pleaseUpdate(false, commandRec);		} 		else {   // this is where you go if script stored in file, as you get to this before display is available. 		    	 image = MesquiteImage.loadImage("Choose map:", path, null, commandRec, ms);    		    	 if (image==null && !StringUtil.blank(path)) 		    	 	alert("Map is not available in specified location, or it could not be read.");	 		    	 		}		if (image==null && canReplaceWithNoMapImage) {      // set map to noMap.gif			if (display!=null)				image = MesquiteImage.loadImage("Choose map:", getPath() + "noMap.gif", display, commandRec, ms);			else				image = MesquiteImage.loadImage("Choose map:", getPath() + "noMap.gif", null, commandRec, ms);			noMapImageShown = true;		}			if (ms!=null  && image!=null) {			mapImage = image;			imagePath = ms.getValue();			if (display !=null) 				((TaxaTreeDisplay)display).pleaseUpdate(false, commandRec);			return true;		}		return false;		}	/*.................................................................................................................*/	/** Sets the map based upon the path information contained in "arguments".  	*/   	 public void setMap( String arguments, CommandRecord commandRec) {  		imagePath = null;				imagePath = ParseUtil.getFirstToken(arguments, pos);   // get image path relative to data file				if (!StringUtil.blank(imagePath))			imagePath = MesquiteFile.composePath(getProject().getHomeDirectoryName(), imagePath);   // convert to full path		  		loadOrChooseMap(imagePath, commandRec);  //now load map		if (!commandRec.scripting())			parametersChanged(null, commandRec);	 }	/*.................................................................................................................*/	/*.................................................................................................................*/   	 public NodeLocsLongLatTaxaExtra getFirstTaxaExtra(){  	 	if (extras!=null) {	   		for (int i=0; i<extras.size(); i++){	   			NodeLocsLongLatTaxaExtra extra = (NodeLocsLongLatTaxaExtra)extras.elementAt(i);		   		if (extra!=null){ 					return extra;		   		}	   		}  	 	}  	 	return null;   	 }	/*.................................................................................................................*/   	 public NodeLocsLongLatExtra getFirstExtra(){  	 	if (extras!=null) {	   		for (int i=0; i<extras.size(); i++){	   			NodeLocsLongLatExtra extra = (NodeLocsLongLatExtra)extras.elementAt(i);		   		if (extra!=null){ 					return extra;		   		}	   		}  	 	}  	 	return null;   	 }	/*.................................................................................................................*/  	 public Snapshot getSnapshot(MesquiteFile file) {   	 	Snapshot temp = new Snapshot();		temp.addLine( "hide");  	 	if (noMapImageShown)  	 		temp.addLine("setMap ''");  	 	else {  	 		String s =  StringUtil.tokenize(MesquiteFile.decomposePath(getProject().getHomeDirectoryName(), imagePath));  	 		temp.addLine("setMap " + s);  	 	}		temp.addLine("toggleFadeMap " + fadeMap.toOffOnString());  	 	temp.addLine("setProjection ", projectionTask);   	 	temp.addLine( "getCharacterSource " , characterSourceTask);  	 	if (URLTask!=null)  	 		temp.addLine( "setURLTask " + StringUtil.tokenize(URLTask.getName())); 	 	temp.addLine( "show");  	 	return temp;  	 }	/*.................................................................................................................*/    	 public String searchWebURL(double longitude,double latitude){    	 	if (URLTask==null)    	 		return "";    	 	double diff = projectionTask.getDiffLatitude()+projectionTask.getDiffLongitude();    	 	URLTask.setRange(diff);    	 	return URLTask.getURL(latitude, longitude,"");   	}  	/*.................................................................................................................*/ 	public void addTaxonToTaxaDisplays(){   		hide = true;  	 	if (extras!=null) {	   		for (int i=0; i<extras.size(); i++){	   			TaxaDisplayExtra extra = (TaxaDisplayExtra)extras.elementAt(i);		   		if (extra!=null){		   			TaxaDisplay td = extra.getTaxaDisplay();		   			if (td!=null)		   				td.getTaxaDrawing().addOneTaxon();		   		}	   		}  	 	}   	}  	/*.................................................................................................................*/ 	public void addTaxon(MesquiteString taxonName, MesquiteNumber latitude, MesquiteNumber longitude, CommandRecord commandRec){		int it = taxa.getNumTaxa()-1;		taxa.addTaxa(it, 1, true);		it = taxa.getNumTaxa()-1;		if (taxonName!=null && !StringUtil.blank(taxonName.toString()))			taxa.setTaxonName(it, taxonName.toString(), false); 		if (!StringUtil.blank(addTaxaGroup.toString())) {			TaxaPartition currentGroups = (TaxaPartition)taxa.getCurrentSpecsSet(TaxaPartition.class);			TaxaGroupVector groups = (TaxaGroupVector)getProject().getFileElement(TaxaGroupVector.class, 0);			Object  obj = groups.getElement(addTaxaGroup.toString());			TaxaGroup tg = (TaxaGroup)obj;			 if (tg==null)			 	tg = TaxaGroup.makeGroup(this,addTaxaGroup.toString(), taxa, groups);			if (tg!=null) {				if (currentGroups==null) {				 		currentGroups= new TaxaPartition("Untitled Partition", taxa.getNumTaxa(), null, taxa);				 		currentGroups.addToFile(taxa.getFile(), getProject(), findElementManager(TaxaPartition.class));						taxa.setCurrentSpecsSet(currentGroups, TaxaPartition.class);				}				if (currentGroups!=null)					currentGroups.setProperty(tg, it);			}		}		GeographicData gData = getGeographicData(commandRec);		if (gData!=null) {			gData.setState(gData.getLongitudeCharacter(), it, 0, longitude.getDoubleValue());			gData.setState(gData.getLatitudeCharacter(), it, 0, latitude.getDoubleValue());			parametersChanged(null, commandRec);		}	}  	/*.................................................................................................................*/  	private boolean getLatLongFromArguments(String arguments, MesquiteNumber latitude, MesquiteNumber longitude) {  	// this only works if first two items in arguments are the x and y coordinates	   	 MesquiteInteger io = new MesquiteInteger(0);		MesquiteNumber x= new MesquiteNumber(MesquiteInteger.fromString(arguments, io));		MesquiteNumber y= new MesquiteNumber(MesquiteInteger.fromString(arguments, io));		if (inMapField(x.getIntValue(),y.getIntValue())) { 			if (projectionTask.convertScreenToLongLat(x,y,longitude,latitude))				return true;		}		return false;	}  	/*.................................................................................................................*/	 MesquiteInteger pos = new MesquiteInteger();	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {/*    	 	 if (checker.compare(this.getClass(), "Sets the module that calculates coordinates for the nodes", "[name of module]", commandName, "setInternalNodeCalculator")) {    	 		NumbersForNodesIncr temp =  (NumbersForNodesIncr)replaceEmployee(commandRec, NumbersForNodesIncr.class, arguments, "Value for axes", numbersForNodesTask); 			if (temp!=null) { 				numbersForNodesTask = temp;				numbersForNodesTask.setHiringCommand(nfntC);				numberTaskName.setValue(numbersForNodesTask.getName());				resetContainingMenuBar(); 				parametersChanged(null, commandRec); 			} 			return temp;    	 	}   	 	else*/      	 	   	 	 if (checker.compare(this.getClass(), "Sets the map projection", "[name of module]", commandName, "setProjection")) {			MapProjection temp = (MapProjection)replaceEmployee(commandRec, MapProjection.class, arguments, "Map Projection", projectionTask);			if (temp !=null){				projectionTask = temp;    	 			projectionName.setValue(projectionTask.getName());		 	 	projectionTask.setHiringCommand(stC);		 	 	projectionTask.setMargin(margin);				projectionTask.setOwnerModule(this);				reconstructorTask.setProjectionTask(projectionTask);				parametersChanged(null, commandRec);    	 			return projectionTask;    	 		}    	 	}    	 	else if (checker.compare(this.getClass(), "Sets whether or not the map is shown faded.", "[on = fade; off]", commandName, "toggleFadeMap")) {    	 		fadeMap.toggleValue(parser.getFirstToken(arguments));//Debugg.println("toggle fade map, fadeMap: " + fadeMap.getValue());			parametersChanged(null, commandRec);    	 	}    	 	else if (checker.compare(this.getClass(), "Set the URL task", "[module name]", commandName, "setURLTask")) {    	 		URLLongLatServer temp=  (URLLongLatServer)replaceEmployee(commandRec, URLLongLatServer.class, arguments, "URL Provider", URLTask); 			if (temp!=null) 				URLTask= temp;			if (searchWebTool!=null)				searchWebTool.setEnabled(URLTask!=null); 			return URLTask;    	 	}    	 	else if (checker.compare(this.getClass(), "Present the popup menu to select options for search web tool", null, commandName, "searchWebToolOptions")) {    			if (searchWebTool == null)    				return null;    			MesquiteButton button = searchWebTool.getButton();     			if (button!=null){	   	 		MesquiteInteger io = new MesquiteInteger(0);	   			int x= MesquiteInteger.fromString(arguments, io); //getting x and y from arguments	   			int y= MesquiteInteger.fromString(arguments, io);	     			MesquitePopup popup = new MesquitePopup(button);				Listable[] moduleList = MesquiteTrunk.mesquiteModulesInfoVector.getModulesOfDuty(URLLongLatServer.class, null, this);		  		for (int i=0; i<moduleList.length; i++) {		  			MesquiteModuleInfo m = (MesquiteModuleInfo)moduleList[i];		  			MesquiteCommand mc = makeCommand("setURLTask", this);		  			mc.setDefaultArguments(StringUtil.tokenize(m.getName()));					MesquiteCheckMenuItem mItem = new MesquiteCheckMenuItem(m.getName(), this, mc, null, null);					if (URLTask!=null)						mItem.set(URLTask.getName().equalsIgnoreCase(m.getName()));					popup.add(mItem);		  		}				popup.showPopup(x,y+6);   			}   			    	 	}		else if (checker.compare(this.getClass(), "Returns module supplying characters", null, commandName, "getCharacterSource")) { 			return characterSourceTask;    	 	}    	 			else if (checker.compare(this.getClass(), "Returns module supplying URL", null, commandName, "getURLTask")) { 			return URLTask;    	 	}    	 	     	 	else if (checker.compare(this.getClass(), "Hides the plot", null, commandName, "hide")) {    	 		hide = true;    	 	}    	 	else if (checker.compare(this.getClass(), "Shows the plot", null, commandName, "show")) {    	 		hide = false;    	 		showCommandGiven = true;    	 	}   	 	else if (checker.compare(this.getClass(), "Chooses map for the treewindow background", null, commandName, "setMap")) {   	 		setMap(arguments,commandRec);    	 	}   	 	else if (checker.compare(this.getClass(), "Sets the coordinates.", null, commandName, "setCoordinates")) {    	 /*    	 		int ic = CharacterStates.toInternal(MesquiteInteger.fromString(arguments)); 			latitudeCharacter = ic; 			numbersForNodesTask.setCurrent(ic, commandRec); 			if (!commandRec.scripting()) 				parametersChanged(null, commandRec);    	*/    	 	}    	 	else if (checker.compare(this.getClass(), "Long Lat tool has been touched", "[x coordinate][y coordinate]", commandName, "touchLongLat")) {	 		if (!projectionTask.getFullySpecified()) {	 				 		}	 		else {				MesquiteNumber longitude = new MesquiteNumber();					MesquiteNumber latitude = new MesquiteNumber();					if (getLatLongFromArguments(arguments, latitude, longitude)){				}			}    	 	}    	 	else if (checker.compare(this.getClass(), "Long Lat tool has been moved", "[x coordinate][y coordinate]", commandName, "moveLongLat")) {	 		if (!projectionTask.getFullySpecified()) {				if (containerOfModule() instanceof MesquiteWindow) {					((MesquiteWindow)containerOfModule()).setExplanation("Longitude and latitude not calculable as the projection is not yet fully calibrated.");				}		 		}	 		else {				MesquiteNumber longitude = new MesquiteNumber();					MesquiteNumber latitude = new MesquiteNumber();					if (getLatLongFromArguments(arguments, latitude, longitude)){					if (containerOfModule() instanceof MesquiteWindow) {						if (longitude.isCombinable() && latitude.isCombinable())							((MesquiteWindow)containerOfModule()).setExplanation("Longitude: " + MesquiteDouble.toPrecisionSpecifiedString(longitude.getDoubleValue(),projectionTask.getLongPrecision()) + ", latitude: " + MesquiteDouble.toPrecisionSpecifiedString(latitude.getDoubleValue(),projectionTask.getLatPrecision()) );						else							((MesquiteWindow)containerOfModule()).setExplanation("");					}					}			}    	 	}    	 	else if (checker.compare(this.getClass(), "Search Web tool has been touched on the field.", "[x coordinate][y coordinate]", commandName, "touchSearchWeb")) {	 		if (!projectionTask.getFullySpecified()) {				sorry(commandRec, "The Search Web tool cannot be used as the projection is not yet fully calibrated.");	 		}	 		else {				MesquiteNumber longitude = new MesquiteNumber();					MesquiteNumber latitude = new MesquiteNumber();					if (getLatLongFromArguments(arguments, latitude, longitude)){					if (containerOfModule() instanceof MesquiteWindow) {						if (longitude.isCombinable() && latitude.isCombinable()) {							((MesquiteWindow)containerOfModule()).setExplanation("Longitude: " + MesquiteDouble.toPrecisionSpecifiedString(longitude.getDoubleValue(),projectionTask.getLongPrecision()) + ", latitude: " + MesquiteDouble.toPrecisionSpecifiedString(latitude.getDoubleValue(),projectionTask.getLatPrecision()) );							MesquiteModule.showWebPage(searchWebURL(longitude.getDoubleValue(), latitude.getDoubleValue()), true);						} else							((MesquiteWindow)containerOfModule()).setExplanation("");					}					}			}    	 	}  	 	else if (checker.compare(this.getClass(), "Add Taxon tool has been touched on the field.", "[x coordinate][y coordinate]", commandName, "fieldAddTaxon")) {			MesquiteNumber longitude = new MesquiteNumber();				MesquiteNumber latitude = new MesquiteNumber();				boolean optionDown = arguments.indexOf("option")>=0;			if (getLatLongFromArguments(arguments, latitude, longitude)){				if (containerOfModule() instanceof MesquiteWindow && longitude.isCombinable()&& latitude.isCombinable()) {					if (!optionDown) {						MesquiteInteger buttonPressed = new MesquiteInteger(-1);						MesquiteString taxonName = new MesquiteString("");						if (!commandRec.scripting()) {							NewTaxonDialog dialog = new NewTaxonDialog(this,buttonPressed,taxonName, addTaxaGroup);						}						if (buttonPressed.getValue()==0) 							addTaxon(taxonName, latitude, longitude, commandRec);					}					else						addTaxon(null, latitude, longitude, commandRec);				}				}    	 	}    	 	else if (checker.compare(this.getClass(), "Move Taxon tool has been touched on a taxon.", "[taxon][modifiers]", commandName, "touchMoveTaxon")) {	 		MesquiteInteger io = new MesquiteInteger(0);			int it = MesquiteInteger.fromString(arguments, io);						observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa,GeographicData.getLongitudeCharacter(), commandRec);			double longitude = observedStates.getState(it);			observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa,GeographicData.getLatitudeCharacter(), commandRec);			double latitude = observedStates.getState(it);			if (containerOfModule() instanceof MesquiteWindow) {				if ( MesquiteDouble.isCombinable(longitude) && MesquiteDouble.isCombinable(latitude))					((MesquiteWindow)containerOfModule()).setExplanation("Longitude: " + MesquiteDouble.toPrecisionSpecifiedString(longitude,projectionTask.getLongPrecision()) + ", latitude: " + MesquiteDouble.toPrecisionSpecifiedString(latitude,projectionTask.getLatPrecision()) );				else					((MesquiteWindow)containerOfModule()).setExplanation("");			}	    	 	}    	 	else if (checker.compare(this.getClass(), "Move Taxon tool has been dragged.", "[branch number] [x coordinate dragged] [y coordinate dragged] ", commandName, "dragMoveTaxon")) {	 		MesquiteInteger io = new MesquiteInteger(0);			int it= MesquiteInteger.fromString(arguments, io);			MesquiteNumber x= new MesquiteNumber(MesquiteInteger.fromString(arguments, io));			MesquiteNumber y= new MesquiteNumber(MesquiteInteger.fromString(arguments, io));						if (inMapField(x.getIntValue(),y.getIntValue())) { 				MesquiteNumber longitude = new MesquiteNumber();					MesquiteNumber latitude = new MesquiteNumber();					if (projectionTask.convertScreenToLongLat(x,y,longitude,latitude)) {					if (containerOfModule() instanceof MesquiteWindow)  {						if (longitude.isCombinable()&& latitude.isCombinable())							((MesquiteWindow)containerOfModule()).setExplanation("Longitude: " + MesquiteDouble.toPrecisionSpecifiedString(longitude.getDoubleValue(),projectionTask.getLongPrecision()) + ", latitude: " + MesquiteDouble.toPrecisionSpecifiedString(latitude.getDoubleValue(),projectionTask.getLatPrecision()) );						else							((MesquiteWindow)containerOfModule()).setExplanation("");//						moveDot(commandRec);					}					}				}    	 	}    	 	else if (checker.compare(this.getClass(), "LongLat tool has been moved over a taxon.", "[taxon] [modifiers] ", commandName, "moveOverTaxonLongLat")) {	 		MesquiteInteger io = new MesquiteInteger(0);			int it = MesquiteInteger.fromString(arguments, io);						observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa,GeographicData.getLongitudeCharacter(), commandRec);			double longitude = observedStates.getState(it);			observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa,GeographicData.getLatitudeCharacter(), commandRec);			double latitude = observedStates.getState(it);			if (containerOfModule() instanceof MesquiteWindow) {				if ( MesquiteDouble.isCombinable(longitude) && MesquiteDouble.isCombinable(latitude))					((MesquiteWindow)containerOfModule()).setExplanation("Taxon " + taxa.getTaxonName(it) + ".    Longitude: " + MesquiteDouble.toPrecisionSpecifiedString(longitude,projectionTask.getLongPrecision()) + ", latitude: " + MesquiteDouble.toPrecisionSpecifiedString(latitude,projectionTask.getLatPrecision()) );				else					((MesquiteWindow)containerOfModule()).setExplanation("");			}	    	 	}    	 	else if (checker.compare(this.getClass(), "Move Taxon tool has been let go.", "[branch number] [x coordinate dropped] [y coordinate dropped] ", commandName, "mouseUpMoveTaxon")) {	 		MesquiteInteger io = new MesquiteInteger(0);			int it= MesquiteInteger.fromString(arguments, io);			MesquiteNumber x= new MesquiteNumber(MesquiteInteger.fromString(arguments, io));			MesquiteNumber y= new MesquiteNumber(MesquiteInteger.fromString(arguments, io));			if (inMapField(x.getIntValue(),y.getIntValue())) { 				MesquiteNumber longitude = new MesquiteNumber();					MesquiteNumber latitude = new MesquiteNumber();					if (projectionTask.convertScreenToLongLat(x,y,longitude,latitude)) {					if (containerOfModule() instanceof MesquiteWindow && longitude.isCombinable()&& latitude.isCombinable()) {//						eraseDot(oldX,oldY,commandRec);						GeographicData gData = getGeographicData(commandRec);						if (gData!=null) {							gData.setState(gData.getLongitudeCharacter(), it, 0, longitude.getDoubleValue());							gData.setState(gData.getLatitudeCharacter(), it, 0, latitude.getDoubleValue());							parametersChanged(null, commandRec);						}					}					}				}    	 	}    	 	else if (checker.compare(this.getClass(), "Search Web tool has been touched on a taxon.", "[taxon][x][y][modifiers]", commandName, "taxonSearchWeb")) {	 		MesquiteInteger io = new MesquiteInteger(0);			int it = MesquiteInteger.fromString(arguments, io);						observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa,GeographicData.getLongitudeCharacter(), commandRec);			double longitude = observedStates.getState(it);			observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa,GeographicData.getLatitudeCharacter(), commandRec);			double latitude = observedStates.getState(it);			if (containerOfModule() instanceof MesquiteWindow ) {				if (MesquiteDouble.isCombinable(longitude) && MesquiteDouble.isCombinable(latitude)) {					((MesquiteWindow)containerOfModule()).setExplanation("Longitude: " + MesquiteDouble.toPrecisionSpecifiedString(longitude,projectionTask.getLongPrecision()) + ", latitude: " + MesquiteDouble.toPrecisionSpecifiedString(latitude,projectionTask.getLatPrecision()) );					MesquiteModule.showWebPage(searchWebURL(longitude, latitude), true);				} else					((MesquiteWindow)containerOfModule()).setExplanation("" );			}	    	 	}     	 	else    	 		return super.doCommand(commandName, arguments, commandRec, checker);		return null;   	 }	/*.................................................................................................................*//*   	 private void adjustScrolls(){  	 	if (extras!=null) {	   		for (int i=0; i<extras.size(); i++){	   			NodeLocsLongLatExtra extra = (NodeLocsLongLatExtra)extras.elementAt(i);	   		}  	 	}   	 }*/    	 public String getName() {		return "Plot on Map";   	 }   	 	/*.................................................................................................................*/ 	/** returns an explanation of what the module does.*/ 	public String getExplanation() { 		return "Calculates the node locations on a map." ;   	 }	/*_________________________________________________*/   	public boolean compatibleWithOrientation(int orientation) {   		return false;   	}	/*_________________________________________________*/	public void calculateTaxonLocs(TaxaDisplay taxaDisplay, Taxa taxa, Rectangle rect, CommandRecord commandRec) {		this.taxa = taxa;		if (hide || isDoomed())			return;		if (taxaDisplay == null || taxaDisplay.getTaxaDrawing() == null)			return;		if (veryFirstTime) {			veryFirstTime=false;//					 numbersForNodesTask.initialize(tree, commandRec);		}// ................  get Extra for drawing the map ........		NodeLocsLongLatTaxaExtra extra = null;		if (taxaDisplay.getExtras() !=null) {			if (taxaDisplay.getExtras().myElements(this)==null) {  				extra = new NodeLocsLongLatTaxaExtra(this, taxaDisplay); 				taxaDisplay.addExtra(extra); 				extras.addElement(extra);			}			else {				Listable[] mine = taxaDisplay.getExtras().myElements(this);				if (mine !=null && mine.length>0)					extra =(NodeLocsLongLatTaxaExtra) mine[0];			}		}		mapWidth = getMapWidth();		mapHeight = getMapHeight();				MesquiteBoolean illegalValue = new MesquiteBoolean(false);		if (projectionTask.getFullySpecified()) {			projectionTask.setMapSize(mapHeight,  mapWidth);	// ................  init the storage for the locations ........			int taxadn = taxaDisplay.getNumTaxa();			int taxan = taxa.getNumTaxa();						location = new Point[taxaDisplay.getNumTaxa()];   //this will store the location values for all of the nodes			for (int i=0; i<location.length; i++) {				location[i]= new Point();			}			NumberArray numbersX= new NumberArray(taxa.getNumTaxa());			NumberArray numbersY=new NumberArray(taxa.getNumTaxa());	/*				There are three coordinate systems:					- long/lat					- projected  (is of the final shape of the sceen image but is not scaled to fit on screen and some offsets need to be applied					- screen		*/			projectionTask.calcProjectionScalesAndOffsets();	// ................  get raw long lats and put into arrays ........			originalCoordinates = new Double2DArray(2,taxa.getNumTaxa());			modifiedCoordinates = new Double2DArray(2,taxa.getNumTaxa());			observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa, GeographicData.getLongitudeCharacter(), commandRec);			for (int it = 0; it<taxa.getNumTaxa(); it++) {				originalCoordinates.setValue(0,it, observedStates.getState(it));				modifiedCoordinates.setValue(0,it, observedStates.getState(it));			}							observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa, GeographicData.getLatitudeCharacter(), commandRec);			for (int it = 0; it<taxa.getNumTaxa(); it++) {				originalCoordinates.setValue(1,it,observedStates.getState(it));				modifiedCoordinates.setValue(1,it,observedStates.getState(it));			}																MesquiteNumber x = new MesquiteNumber();			MesquiteNumber y = new MesquiteNumber();			double longitude;			double latitude;	// ................  reset the "original" locations to be the calculated ones, so that they can be used in reconstruction of internal nodes ........			for (int it = 0; it<taxa.getNumTaxa(); it++) {				longitude = modifiedCoordinates.getValue(0,it);				latitude = modifiedCoordinates.getValue(1,it);				projectionTask.convertLongLatsToScreenCoordinates (longitude,  latitude,  x,  y, illegalValue);				if (it<location.length && x!=null && y!=null) {					location[it].x = (int)x.getDoubleValue();					location[it].y = (int)y.getDoubleValue();				}			}																	// ................  various clean up things			for (int i=0; i<taxa.getNumTaxa() && i<taxaDisplay.getTaxaDrawing().y.length; i++) {				taxaDisplay.getTaxaDrawing().y[i] = location[i].y;				taxaDisplay.getTaxaDrawing().x[i] = location[i].x;			}		}		else {			for (int i=0; i<taxa.getNumTaxa() && i<taxaDisplay.getTaxaDrawing().y.length; i++) {				taxaDisplay.getTaxaDrawing().y[i] = margin;				taxaDisplay.getTaxaDrawing().x[i] = margin;			}		}		if (illegalValue.getValue())		if (extra!=null)			extra.addWarning(false);	}	/*_________________________________________________*/	public void calculateNodeLocs(TreeDisplay treeDisplay, Tree tree, int drawnRoot, Rectangle rect, CommandRecord commandRec) {		if (hide || isDoomed())			return;		boolean doInternals = true;		if (tree!=null) {//			tree = new MesquiteTree(taxa);			//((MesquiteTree)tree).setToDefaultBush(tree.getNumTaxa(), false);		}		if (MesquiteTree.OK(tree)) {				if (treeDisplay == null || treeDisplay.getTreeDrawing() == null)					return;				if (veryFirstTime) {					veryFirstTime=false;//					 numbersForNodesTask.initialize(tree, commandRec);					// here initialize reconstructorTask?				}		// ................  get Extra for drawing the map ........				NodeLocsLongLatExtra extra = null;				if (treeDisplay.getExtras() !=null) {					if (treeDisplay.getExtras().myElements(this)==null) {  						extra = new NodeLocsLongLatExtra(this, treeDisplay); 						treeDisplay.addExtra(extra); 						extras.addElement(extra);					}					else {						Listable[] mine = treeDisplay.getExtras().myElements(this);						if (mine !=null && mine.length>0)							extra =(NodeLocsLongLatExtra) mine[0];					}				}				mapWidth = getMapWidth();				mapHeight = getMapHeight();								MesquiteBoolean illegalValue = new MesquiteBoolean(false);				if (projectionTask.getFullySpecified()) {					projectionTask.setMapSize(mapHeight,  mapWidth);			// ................  init the storage for the locations ........					int subRoot = tree.motherOfNode(drawnRoot);										location = new Point[tree.getNumNodeSpaces()];   //this will store the location values for all of the nodes					for (int i=0; i<location.length; i++) {						location[i]= new Point();					}					NumberArray numbersX= new NumberArray(tree.getNumNodeSpaces());					NumberArray numbersY=new NumberArray(tree.getNumNodeSpaces());			/*						There are three coordinate systems:							- long/lat							- projected  (is of the final shape of the sceen image but is not scaled to fit on screen and some offsets need to be applied							- screen						*/					projectionTask.calcProjectionScalesAndOffsets();			// ................  get raw long lats and put into arrays ........					originalCoordinates = new Double2DArray(2,tree.getNumNodeSpaces());					modifiedCoordinates = new Double2DArray(2,tree.getNumNodeSpaces());					observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(tree,GeographicData.getLongitudeCharacter(), commandRec);					for (int it = 0; it<tree.getNumTaxa(); it++) {						originalCoordinates.setValue(0,tree.nodeOfTaxonNumber(it), observedStates.getState(it));						modifiedCoordinates.setValue(0,tree.nodeOfTaxonNumber(it), observedStates.getState(it));					}									observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(tree, GeographicData.getLatitudeCharacter(), commandRec);					for (int it = 0; it<tree.getNumTaxa(); it++) {						originalCoordinates.setValue(1,tree.nodeOfTaxonNumber(it),observedStates.getState(it));						modifiedCoordinates.setValue(1,tree.nodeOfTaxonNumber(it),observedStates.getState(it));					}																											/* ................  converts terminal node long lats into projected coordinates, and stores results in originalCoordinates array, 						with modifiedCoordinates[0][it] being X ........ 						and modifiedCoordinates[1][it] being Y .......						This isn't the actual screen coordinates, just the virtual, unscaled, unshifted coordinates			*/								projectionTask.convertLongLatsToProjected(tree,drawnRoot,modifiedCoordinates, illegalValue, false);										if (illegalValue.getValue())						doInternals = false;			// ................  sets location, in screen coordinates, of terminal nodes.  Will be stored in the location array ........					projectionTask.convertProjectedToScreenCoordinates(tree, drawnRoot, modifiedCoordinates, false);			// ................  reconstruct position of internal nodes ........					if (doInternals) {						double[][]  reconstructed  = reconstructorTask.reconstructLocations(tree, originalCoordinates, modifiedCoordinates, commandRec); 						for (int node = 0; node<tree.getNumNodeSpaces(); node++) {							if (!tree.nodeIsTerminal(node)) {								modifiedCoordinates.setValue(0,node, reconstructed[0][node]);								modifiedCoordinates.setValue(1,node, reconstructed[1][node]);							}						}				// ................  reset the "original" locations to be the calculated ones, so that they can be used in reconstruction of internal nodes ........						for (int node = 0; node<tree.getNumNodeSpaces(); node++) {							location[node].x = (int)modifiedCoordinates.getValue(0,node);							location[node].y = (int)modifiedCoordinates.getValue(1,node);						}																					// ................  various clean up things						location[subRoot].x = location[drawnRoot].x;						location[subRoot].y = location[drawnRoot].y;						for (int i=0; i<tree.getNumNodeSpaces() && i<treeDisplay.getTreeDrawing().y.length; i++) {							treeDisplay.getTreeDrawing().y[i] = location[i].y;							treeDisplay.getTreeDrawing().x[i] = location[i].x;						}					} 					else {			// ................  reset the "original" locations to be the calculated ones, so that they can be used in reconstruction of internal nodes ........						for (int node = 0; node<tree.getNumNodeSpaces(); node++) {							if (tree.nodeIsTerminal(node)) {								location[node].x = (int)modifiedCoordinates.getValue(0,node);								location[node].y = (int)modifiedCoordinates.getValue(1,node);							}						}																					// ................  various clean up things						for (int i=0; i<tree.getNumNodeSpaces() && i<treeDisplay.getTreeDrawing().y.length; i++) 							if (tree.nodeIsTerminal(i)) {								treeDisplay.getTreeDrawing().y[i] = location[i].y;								treeDisplay.getTreeDrawing().x[i] = location[i].x;							}					}				}				if (illegalValue.getValue() || !projectionTask.getFullySpecified())					if (doInternals) {						for (int i=0; i<tree.getNumNodeSpaces() && i<treeDisplay.getTreeDrawing().y.length; i++) {							treeDisplay.getTreeDrawing().y[i] = margin;							treeDisplay.getTreeDrawing().x[i] = margin;							treeDisplay.getTreeDrawing().z[i] = margin;						}						if (extra!=null)							extra.addWarning(true);						return;					} //else						//discreetAlert(commandRec,"Some longitude latitude values are illegal (perhaps missing data), and were not plotted");				if (extra!=null)					extra.addWarning(false);		}	}		/*.................................................................................................................*/	void nodePositions(int N,  Tree tree, StringBuffer sb, NumberArray numbersX, NumberArray numbersY) {		for (int d = tree.firstDaughterOfNode(N); tree.nodeExists(d); d = tree.nextSisterOfNode(d))				nodePositions(d, tree, sb, numbersX, numbersY);		if (tree.nodeIsTerminal(N))			sb.append(tree.getTaxa().getName(tree.taxonNumberOfNode(N)) + '\t');		else			sb.append("node " + N +  '\t');		sb.append(numbersX.toString(N) + '\t' + numbersY.toString(N) + "\n");	}	/*.................................................................................................................*/	private void drawString(Graphics g, String s, int x, int y){		if (g == null || StringUtil.blank(s))			return;		try {		g.drawString(s, x, y);		}		catch (Exception e){		}	}	/*.................................................................................................................*/	public void drawExtras (Graphics g,TreeDisplay treeDisplay) {		projectionTask.setMapSize(getMapHeight(), getMapWidth());		projectionTask.drawExtras(g,treeDisplay);	}	/*.................................................................................................................*/	public void drawTaxaExtras (Graphics g,TaxaDisplay taxaDisplay) {		projectionTask.setMapSize(getMapHeight(), getMapWidth());		projectionTask.drawTaxaExtras(g,taxaDisplay);	}}/*=======================================================================*/class NewTaxonDialog extends ExtensibleDialog  {	NodeLocsLongLat ownerModule;		public NewTaxonDialog (NodeLocsLongLat ownerModule, MesquiteInteger buttonPressed, MesquiteString taxonName, MesquiteString group){		super(ownerModule.containerOfModule(), "New Taxon", buttonPressed);		this.ownerModule = ownerModule;				addLabel("New Taxon", Label.CENTER);		SingleLineTextField textField = addTextField("Name: ", "", 20);		ListableVector groupList = (ListableVector)ownerModule.getProject().getFileElement(TaxaGroupVector.class,0);		int numGroups = groupList.getNumberOfParts();		String[] groups = new String[numGroups+1];		groups[0] = "(no group)";		for (int i = 1; i<numGroups+1; i++)			groups[i] = groupList.nameOfElementAt(i-1);		Choice groupPopUp=null;		if (groups!=null) {			groupPopUp = addPopUpMenu("Group: ", groups, 0);			if (!StringUtil.blank(group.getValue()))				groupPopUp.select(group.getValue());		}		completeAndShowDialog("Create", "Cancel",true,null);		int button = query();		if (buttonPressed!=null)			buttonPressed.setValue(button);		if (button==0) {			if (groupPopUp!=null) {				int groupValue = groupPopUp.getSelectedIndex();				if (groupValue>0) 					group.setValue(groupPopUp.getSelectedItem());				else					group.setValue("");			}			taxonName.setValue(textField.getText());		}		dispose();						}}	/* ======================================================================== */class NodeLocsLongLatExtra extends TreeDisplayBkgdExtra {	NodeLocsLongLat ownerModule;	public boolean pleaseAdjustScrolls = false;	public String parameters = "";	StringBuffer textPositions;		public NodeLocsLongLatExtra (NodeLocsLongLat ownerModule, TreeDisplay treeDisplay) {		super(ownerModule, treeDisplay);		this.ownerModule = ownerModule;		textPositions = new StringBuffer();		setPlacement(BELOW);//		Image mapImage = ownerModule.getMapImage();//		if (mapImage !=null)//			treeDisplay.setPreferredSize(ownerModule.getMapImage().getWidth(treeDisplay)+ownerModule.getMargin(), ownerModule.getMapImage().getHeight(treeDisplay)+ownerModule.getMargin());	}	/*_________________________________________________*/	public   void drawImage(TreeDisplay treeDisplay, Tree tree, int drawnRoot, Graphics g) {	        if (MesquiteTree.OK(tree)) {		       	if (ownerModule.getFadeMap()) 		       		ColorDistribution.setTransparentGraphics(g);	        	g.drawImage(ownerModule.getMapImage(),ownerModule.getMargin(),ownerModule.getMargin(),Color.white, null);		       	if (ownerModule.getFadeMap())		        	ColorDistribution.setOpaqueGraphics(g);		        if (!ownerModule.getProjectionTask().getFullySpecified()) {				Font f = g.getFont();		 		if (f!=null){			 		Font fontToSet = new Font (f.getName(), Font.BOLD,32);			 		if (fontToSet!= null) {			 			g.setFont(fontToSet);			 			g.setColor(Color.black);		        			g.drawString("Uncalibrated Projection", ownerModule.getMargin()+7, ownerModule.getMargin()+62);			 			g.setColor(Color.red);		        			g.drawString("Uncalibrated Projection", ownerModule.getMargin()+5, ownerModule.getMargin()+60);		        						 			GraphicsUtil.setFontSize(14,g);			 			g.setColor(Color.white);		        			g.drawString("To calibrate, add latitude-longitude calibration points, then set parameter values of map", ownerModule.getMargin()+7, ownerModule.getMargin()+102);			 			g.setColor(Color.blue);		        			g.drawString("To calibrate, add latitude-longitude calibration points, then set parameter values of map", ownerModule.getMargin()+5, ownerModule.getMargin()+100);			 			g.setColor(Color.black);			 		}			 		g.setFont(f);		 		}		        }	       	 }	   }	/*.................................................................................................................*/	boolean doWarn = false;	public void addWarning(boolean warn){		doWarn = warn;	}	/*.................................................................................................................*/	public   String infoAtNodes(Tree tree, int drawnRoot) {		return parameters + "\n\nNodes with X, Y positions\n\n" + textPositions.toString();	}	/*.................................................................................................................*/	public   String additionalText(Tree tree, int drawnRoot) {		return parameters;	}	/*.................................................................................................................*/	public   void drawOnTree(Tree tree, int drawnRoot, Graphics g) {		drawImage(treeDisplay, tree, drawnRoot, g);		ownerModule.drawExtras(g,treeDisplay);	}	public   void printOnTree(Tree tree, int drawnRoot, Graphics g) {		drawOnTree(tree, drawnRoot, g);	}	public   void setTree(Tree tree, CommandRecord commandRec) {	}	public void turnOff() {		super.turnOff();	}}	/* ======================================================================== */class NodeLocsLongLatTaxaExtra extends TaxaDisplayBkgdExtra {	NodeLocsLongLat ownerModule;	public boolean pleaseAdjustScrolls = false;	public String parameters = "";	StringBuffer textPositions;		public NodeLocsLongLatTaxaExtra (NodeLocsLongLat ownerModule, TaxaDisplay taxaDisplay) {		super(ownerModule, taxaDisplay);		this.ownerModule = ownerModule;		textPositions = new StringBuffer();		setPlacement(BELOW);//		Image mapImage = ownerModule.getMapImage();//		if (mapImage !=null)//			treeDisplay.setPreferredSize(ownerModule.getMapImage().getWidth(treeDisplay)+ownerModule.getMargin(), ownerModule.getMapImage().getHeight(treeDisplay)+ownerModule.getMargin());	}	/*_________________________________________________*/	public   void drawImage(TaxaDisplay taxaDisplay, Graphics g) {//	       		Debugg.println("drawImage");	       	if (ownerModule.getFadeMap()) {	       		ColorDistribution.setTransparentGraphics(g);//	       		Debugg.println("trans");	   	 }	      //  ((Graphics2D)g).scale(0.5,0.5);	       g.drawImage(ownerModule.getMapImage(),ownerModule.getMargin(),ownerModule.getMargin(),Color.white, null);	      // MesquiteImage.drawImageWithinRect(g,ownerModule.getMapImage(),ownerModule.getMargin(),ownerModule.getMargin(),(int)(ownerModule.getMapWidth()*0.5), (int)(ownerModule.getMapHeight()*0.5), null);	       // ((Graphics2D)g).scale(2.0,2.0);	       	if (ownerModule.getFadeMap())	        	ColorDistribution.setOpaqueGraphics(g);	        if (!ownerModule.getProjectionTask().getFullySpecified()) {			Font f = g.getFont();	 		if (f!=null){		 		Font fontToSet = new Font (f.getName(), Font.BOLD,32);		 		if (fontToSet!= null) {		 			g.setFont(fontToSet);		 			g.setColor(Color.black);	        			g.drawString("Uncalibrated Projection", ownerModule.getMargin()+7, ownerModule.getMargin()+62);		 			g.setColor(Color.red);	        			g.drawString("Uncalibrated Projection", ownerModule.getMargin()+5, ownerModule.getMargin()+60);		 			g.setColor(Color.black);		 			GraphicsUtil.setFontSize(14,g);		 			g.setColor(Color.white);	        			g.drawString("To calibrate, add latitude-longitude calibration points, then set parameter values of map", ownerModule.getMargin()+6, ownerModule.getMargin()+101);		 			g.setColor(Color.blue);	        			g.drawString("To calibrate, add latitude-longitude calibration points, then set parameter values of map", ownerModule.getMargin()+5, ownerModule.getMargin()+100);		 			g.setColor(Color.black);		 		}		 		g.setFont(f);	 		}	        }	   }	/*.................................................................................................................*/	boolean doWarn = false;	public void addWarning(boolean warn){		doWarn = warn;	}	/*.................................................................................................................*/	public   String infoAtNodes(Tree tree) {		return parameters + "\n\nNodes with X, Y positions\n\n" + textPositions.toString();	}	/*.................................................................................................................*/	public   String additionalText(Tree tree) {		return parameters;	}	/*.................................................................................................................*/	public   void drawOnTaxa(Taxa taxa, Graphics g) {		drawImage(taxaDisplay , g);		ownerModule.drawTaxaExtras(g,taxaDisplay);	}	public   void printOnTaxa(Taxa taxa, Graphics g) {		drawOnTaxa(taxa, g);	}	public   void setTaxa(Taxa taxa, CommandRecord commandRec) {	}	public void turnOff() {		super.turnOff();	}}