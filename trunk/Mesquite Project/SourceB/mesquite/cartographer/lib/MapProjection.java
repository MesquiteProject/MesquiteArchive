/* Mesquite.cartographer source code.  Copyright 2005 D. Maddison, W. Maddison. Version 1.0, April 2005.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.cartographer.lib;/*~~  */import java.util.*;import java.awt.*;import mesquite.lib.*;import mesquite.lib.duties.*;/* ======================================================================== */public abstract class MapProjection extends MesquiteModule {	protected MesquiteModule ownerModule = null;	protected boolean treePlot = true;	protected int defaultLongPrecision=2;	protected int defaultLatPrecision=2;	protected int margin = 30;	protected int mapWidth;	protected int mapHeight;	protected double xScale = 1.0;	protected double yScale = 1.0;	protected double xLeftOffset = 0.0;	protected double yTopOffset = 0.0;	protected double diffLatitude=180;	protected double diffLongitude=360;	   	 public Class getDutyClass() {   	 	return MapProjection.class;   	 } 	public String getDutyName() { 		return "Map Projection";   	 } 	/*_________________________________________________*  	public void ownerModuleParametersChanged(CommandRecord commandRec) { 		if (ownerModule!=null) 			ownerModule.parametersChanged(null, commandRec); 	}	/*_________________________________________________*/  	public void setTreePlot(boolean treePlot) { 		this.treePlot = treePlot; 	}	/*_________________________________________________*/  	public boolean getTreePlot() { 		return treePlot; 	}	/*_________________________________________________*/  	public void setOwnerModule(MesquiteModule ownerModule) { 		this.ownerModule = ownerModule; 	} 	/*_________________________________________________*/  	public boolean getFullySpecified() { 		return false; 	} 	/*_________________________________________________*/	/** sets the margin around the map.  */  	public void setMargin(int margin) { 		this.margin = margin; 	}	/*_________________________________________________*/	/** sets the mapHeight and mapWidth.  */  	public void setMapSize(int mapHeight, int mapWidth) { 		this.mapHeight = mapHeight; 		this.mapWidth = mapWidth; 	} 	/*_________________________________________________*/	/** Can be overridden to draw something (e.g., long lat lines) over the map  */	public void drawExtras (Graphics g,TreeDisplay treeDisplay) {	} 	/*_________________________________________________*/	/** Can be overridden to draw something (e.g., long lat lines) over the map  */	public void drawTaxaExtras (Graphics g,TaxaDisplay taxaDisplay) {	} 	/*_________________________________________________*/ 	/** This method converts standard x and y coordinate values from the projection (with x increasing as you go to the right, and y increasing as you go up)  	into the x and y coordinate system used for screen coordinates, that is, with the origin at the upper left, and x values increasing as you go to  	the right, and y increasing as  you go down.*/   	public void convertProjectedToUnscaledScreenCoordinates(MesquiteNumber x, MesquiteNumber y){   		y.changeSign();  // flips the polarity so that numbers now are zero at the top, and go up as you go down   	}	/*.................................................................................................................*/        public static double arctanRatio(double A, double B) {               	if (A==0.0)               		return MesquiteDouble.unassigned;               	else if (B==0.0) {                	if (A<0.0)                		return -Math.PI/2;                	else                		return Math.PI/2;                }               	else if (B<0) {                	if (A<0.0)                		return Math.atan(A/B)+Math.PI;                	else                		return Math.atan(A/B)-Math.PI;                }               	else return Math.atan(A/B);        }	/*.................................................................................................................*/        public static double sinh(double x) {                return (Math.exp(x)-Math.exp(-x))/2.0;        }	/*.................................................................................................................*/        public static double cosh(double x) {                return (Math.exp(x)+Math.exp(-x))/2.0;        }	/*.................................................................................................................*/        public static double latitudeAdjust(double lambda) {               if (lambda>Math.PI)               		return 2*Math.PI-lambda;               if (lambda<-Math.PI)               		return 2*Math.PI+lambda;               	return lambda;        }	/*.................................................................................................................*/  	 public double checkGeographicValue(boolean latitude, double value, MesquiteBoolean success) { 		if (!MesquiteDouble.isCombinable(value))			success.setValue(false);		else if (latitude) {			if (value<-90.0 || value > 90.0)				success.setValue(false);		}		 else if (value<-180.0 || value > 180.0)			success.setValue(false);		return value;  	 }	/*.................................................................................................................*/   	public double getDiffLongitude(){		return diffLongitude;   	}	/*.................................................................................................................*/   	public double getDiffLatitude(){		return diffLatitude;   	}	/*.................................................................................................................*/   	public void processProjectionParameters(boolean duringOptimization){		if (!duringOptimization) {			MesquiteNumber minLatitude = new MesquiteNumber();			MesquiteNumber maxLatitude = new MesquiteNumber();			MesquiteNumber minLongitude = new MesquiteNumber();			MesquiteNumber maxLongitude = new MesquiteNumber();			findMinMaxLongLat (minLatitude, maxLatitude, minLongitude, maxLongitude);			if (minLatitude.isCombinable()&& maxLatitude.isCombinable())				diffLatitude = Math.abs(minLatitude.getDoubleValue() - maxLatitude.getDoubleValue());			if (minLongitude.isCombinable()&& maxLongitude.isCombinable())				diffLongitude = Math.abs(minLongitude.getDoubleValue() - maxLongitude.getDoubleValue());		}		   	}	/*_________________________________________________*/	public void setToUnassigned (MesquiteNumber minLatitude, MesquiteNumber maxLatitude, MesquiteNumber minLongitude, MesquiteNumber maxLongitude){		minLatitude.setToUnassigned();		maxLatitude.setToUnassigned();		minLongitude.setToUnassigned();		maxLongitude.setToUnassigned();	}	/*_________________________________________________*/	public void findMinMaxLongLat (MesquiteNumber minLatitude, MesquiteNumber maxLatitude, MesquiteNumber minLongitude, MesquiteNumber maxLongitude){		MesquiteNumber x = new MesquiteNumber(margin);		MesquiteNumber y = new MesquiteNumber(margin);		MesquiteNumber longitude = new MesquiteNumber();			MesquiteNumber latitude = new MesquiteNumber();		setToUnassigned(minLatitude, maxLatitude,  minLongitude,  maxLongitude);		for (int hor = margin; hor<margin+mapWidth; hor++) {			x.setValue(hor*1.0);			y.setValue(margin*1.0);//Debugg.println("\nx: " + x.getDoubleValue() + ", y: " + y.getDoubleValue());			if (convertScreenToLongLat(x,y,longitude, latitude)) {				if (!latitude.isCombinable() || !longitude.isCombinable()) {					setToUnassigned(minLatitude, maxLatitude,  minLongitude,  maxLongitude);					return;				}				minLatitude.setMeIfIAmMoreThan(latitude.getDoubleValue());				maxLatitude.setMeIfIAmLessThan(latitude.getDoubleValue());				minLongitude.setMeIfIAmMoreThan(longitude.getDoubleValue());				maxLongitude.setMeIfIAmLessThan(longitude.getDoubleValue());			}		}		for (int hor = margin; hor<margin+mapWidth; hor++) {			x.setValue(hor*1.0);			y.setValue((margin+mapHeight)*1.0);			if (convertScreenToLongLat(x,y,longitude, latitude)) {				if (!latitude.isCombinable() || !longitude.isCombinable()) {					setToUnassigned(minLatitude, maxLatitude,  minLongitude,  maxLongitude);					return;				}				minLatitude.setMeIfIAmMoreThan(latitude.getDoubleValue());				maxLatitude.setMeIfIAmLessThan(latitude.getDoubleValue());				minLongitude.setMeIfIAmMoreThan(longitude.getDoubleValue());				maxLongitude.setMeIfIAmLessThan(longitude.getDoubleValue());			}		}		for (int ver = margin; ver<margin+mapHeight; ver++) {			x.setValue(margin*1.0);			y.setValue(ver*1.0);			if (convertScreenToLongLat(x,y,longitude, latitude)) {				if (!latitude.isCombinable() || !longitude.isCombinable()) {					setToUnassigned(minLatitude, maxLatitude,  minLongitude,  maxLongitude);					return;				}				minLatitude.setMeIfIAmMoreThan(latitude.getDoubleValue());				maxLatitude.setMeIfIAmLessThan(latitude.getDoubleValue());				minLongitude.setMeIfIAmMoreThan(longitude.getDoubleValue());				maxLongitude.setMeIfIAmLessThan(longitude.getDoubleValue());			}		}		for (int ver = margin; ver<margin+mapHeight; ver++) {			x.setValue((margin+mapWidth)*1.0);			y.setValue(ver*1.0);			if (convertScreenToLongLat(x,y,longitude, latitude)) {				if (!latitude.isCombinable() || !longitude.isCombinable()) {					setToUnassigned(minLatitude, maxLatitude,  minLongitude,  maxLongitude);					return;				}				minLatitude.setMeIfIAmMoreThan(latitude.getDoubleValue());				maxLatitude.setMeIfIAmLessThan(latitude.getDoubleValue());				minLongitude.setMeIfIAmMoreThan(longitude.getDoubleValue());				maxLongitude.setMeIfIAmLessThan(longitude.getDoubleValue());			}		}				}	/*.................................................................................................................*/  	 public double getLambdaDiff(double lambda, double lambda0, boolean checkBeyond180) { 		double lambdaDiff = (lambda-lambda0);		if (checkBeyond180)			if (lambdaDiff>Math.PI)				lambdaDiff -= 2*Math.PI;			else if (lambdaDiff < -Math.PI)				lambdaDiff += 2*Math.PI;		return lambdaDiff;  	 }	/*.................................................................................................................*/  	 public double getLambdaDiff90(double lambda, double lambda0, boolean checkBeyond90) { 		double lambdaDiff = (lambda-lambda0);		if (checkBeyond90)			if (lambdaDiff>Math.PI/2)				lambdaDiff -= Math.PI;			else if (lambdaDiff < -Math.PI/2)				lambdaDiff += Math.PI;		return lambdaDiff;  	 }	/*.................................................................................................................*/	/** Returns the number of digits to the right of the decimal points that should be written when displaying longitude values by a tool. **/	public int getLongPrecision() {		return defaultLongPrecision;	}	/*.................................................................................................................*/	/** Returns the number of digits to the right of the decimal points that should be written when displaying latitude values by a tool. **/	public int getLatPrecision() {		return defaultLatPrecision;	}/*_________________________________________________*/ 	  	/** This method converts standard x and y coordinate values (with x increasing as you go to the right, and y increasing as you go up)  	into the x and y coordinate system used for screen coordinates, that is, with the origin at the upper left, and x values increasing as you go to  	the right, and y increasing as  you go down.  This is used by tools that give feedback to user about where cursor is.  */    	public void convertFromScreenCoordinates(MesquiteNumber x, MesquiteNumber y){   		x.subtract(margin);   		y.subtract(margin);   		scaleFromScreenToProjected(x,y);   		y.changeSign();      	}	/*_________________________________________________*/	public boolean convertLongLatsToScreenCoordinates (double longitude, double latitude, MesquiteNumber x, MesquiteNumber y){		return convertLongLatsToScreenCoordinates(longitude, latitude, x, y, null);	}	/*_________________________________________________*/	public boolean convertLongLatsToScreenCoordinates (double longitude, double latitude, MesquiteNumber x, MesquiteNumber y, MesquiteBoolean illegalValue){		if (x==null || y==null)			return false;		if (!convertToUnscaledProjectionCoordinates(longitude, latitude, x, y))			return false;		if (illegalValue!=null && ((!y.isCombinable() || !x.isCombinable())&& illegalValue!=null))			illegalValue.setValue(true);		convertProjectedToUnscaledScreenCoordinates(x, y);		x.setValue(scaleXFromProjectedToScreen(x));		y.setValue(scaleYFromProjectedToScreen(y));		return true;	}	/*_________________________________________________*/	public void convertLongLatsToProjected (Tree tree, int node, Double2DArray original, MesquiteBoolean illegalValue, boolean allNodes){		for (int d = tree.firstDaughterOfNode(node); tree.nodeExists(d); d = tree.nextSisterOfNode(d))			convertLongLatsToProjected(tree, d, original, illegalValue, allNodes);					if (allNodes ||  tree.nodeIsTerminal(node)) {			double longitude = original.getValue(0,node);			double latitude = original.getValue(1,node);			MesquiteNumber projectedX = new MesquiteNumber();			MesquiteNumber projectedY = new MesquiteNumber();			convertToUnscaledProjectionCoordinates(longitude, latitude, projectedX, projectedY);			if ((!projectedX.isCombinable() || !projectedY.isCombinable())&& illegalValue!=null)				illegalValue.setValue(true);			original.setValue(0,node, projectedX.getDoubleValue());			original.setValue(1,node, projectedY.getDoubleValue());		}	}	/*_________________________________________________*/	public void convertProjectedToScreenCoordinates (Tree tree, int node, Double2DArray  original, boolean allNodes){		if (original==null)			return;		for (int d = tree.firstDaughterOfNode(node); tree.nodeExists(d); d = tree.nextSisterOfNode(d))			convertProjectedToScreenCoordinates(tree, d, original, allNodes);								if (allNodes || tree.nodeIsTerminal(node)) {			MesquiteNumber projectedX = new MesquiteNumber(original.getValue(0,node));			MesquiteNumber projectedY = new MesquiteNumber(original.getValue(1,node));	// convert to unscaled screen coordinates 			convertProjectedToUnscaledScreenCoordinates(projectedX, projectedY);	// now scale the values to fit within the screen Rectangle of the map.  This basically converts to scaled screen coordinates			original.setValue(0,node,scaleXFromProjectedToScreen(projectedX));			original.setValue(1,node,scaleYFromProjectedToScreen(projectedY));		}	}		/*_________________________________________________*/	public boolean convertScreenToLongLat (MesquiteNumber x, MesquiteNumber y, MesquiteNumber longitude, MesquiteNumber latitude){		convertFromScreenCoordinates(x,y);		return convertFromProjectionCoordinates(x.getDoubleValue(),y.getDoubleValue(),longitude,latitude);	} 	/*_________________________________________________*/ 	/** This method takes in the values of x and y for a point in the current projection, and returns the longitude and latitude.   	If the longitude and latitude are undefined (e.g., the points are outside of the projection), the value returned is unassigned.  */   	public abstract boolean convertFromProjectionCoordinates(double x, double y, MesquiteNumber longitude, MesquiteNumber latitude); 	/*_________________________________________________*/ 	/** This method takes in the values of longitude and latitude for a point, and returns the x-y coordinates of that point in the current projection. 	You needn't worry about scaling - that is done elsewhere.  */   	public abstract boolean convertToUnscaledProjectionCoordinates(double longitude, double latitude, MesquiteNumber x, MesquiteNumber y);	/*_________________________________________________*/	public abstract boolean calcProjectionScalesAndOffsets () ;	/*_________________________________________________*/  	/** This method does the simple scaling back down from screen coordinates to projection coordinates.  */   	public abstract void scaleFromScreenToProjected(MesquiteNumber x, MesquiteNumber y);	/*_________________________________________________*/  	/** This method does the simple scaling up from the projection coordinates to screen size for the x axis.  */	public abstract double scaleXFromProjectedToScreen (MesquiteNumber x);	/*_________________________________________________*/  	/** This method does the simple scaling up from the projection coordinates to screen size for the x axis.  */	public abstract double scaleYFromProjectedToScreen (MesquiteNumber y);	/*_________________________________________________*/   	}