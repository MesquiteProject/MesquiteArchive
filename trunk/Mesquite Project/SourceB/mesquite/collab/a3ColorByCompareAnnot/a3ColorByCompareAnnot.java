/* Mesquite source code.  Copyright 1997-2005 W. Maddison and D. Maddison. Version 1.06, September 2005.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.collab.a3ColorByCompareAnnot; import java.util.*;import java.awt.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.lib.table.*;import mesquite.categ.lib.*;/* ======================================================================== */public class a3ColorByCompareAnnot extends DataWindowAssistantI implements CellColorer {	MesquiteTable table;	CharacterData data, oData;	MesquiteBoolean useIDs;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName){		useIDs = new MesquiteBoolean(true);		mesquite.collab.a0CollabINIT.a0CollabINIT init = (mesquite.collab.a0CollabINIT.a0CollabINIT)findNearestColleagueWithName("a0CollabINIT");		if (init == null)			return false;		addMenuItem(init.collabMenu, "-", null);		addMenuItem(init.collabMenu, "6. Show Annotation Differences", makeCommand("showDiff",  this));		addMenuItem(init.collabMenu, "7. Incorporate Annotations if Newer", makeCommand("incorpDiff",  this));		addMenuItem(init.collabMenu, "Incorporate Annotations Regardless", makeCommand("incorpRegardless",  this));		addCheckMenuItem(init.collabMenu, "Use Annotation IDs to Compare", makeCommand("toggleUseIDs",  this), useIDs);		addMenuItem(init.collabMenu, "Delete Duplicate Annotations", makeCommand("exterminateDups", this));		return true;	}	/*.................................................................................................................*/   	 public boolean isSubstantive(){   	 	return false;   	 }   	 int count = 0; 	private boolean exterminateIdenticalNotes(AttachedNotesVector v, boolean excludeDateCreated, boolean excludeDateModified){		if (v.getNumNotes() ==0)  //returns true if any notes exterminated			 return false;		boolean anyMatches = false;		while (deleteFirstMatch(v, excludeDateCreated, excludeDateModified)){			anyMatches = true;		}		return anyMatches;	}	private boolean deleteFirstMatch(AttachedNotesVector v, boolean excludeDateCreated, boolean excludeDateModified){		boolean matchFound = false;		for (int i= 0; i< v.getNumNotes(); i++){			AttachedNote note = v.getAttachedNote(i);			boolean first = true;			for (int j= i+1; j< v.getNumNotes();j++){				AttachedNote otherNote = v.getAttachedNote(j);				if (note.sameContents(otherNote, true, true)) {					logln("Note deleted:\n" + otherNote);					if (first)						logln("\nbecause identical by content to this note:\n" + note);					first = false;					v.deleteNote(j);					count++;					return true;				}							}		}		return false;			}	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {    	 	if (checker.compare(this.getClass(), "Shows differences from other matrix if newer", null, commandName, "showDiff")) {    	 		if (!isActive()) {				MesquiteModule mb = findEmployerWithDuty(DataWindowMaker.class);				if (mb != null && mb instanceof DataWindowMaker)					((DataWindowMaker)mb).demandCellColorer(this,"The cells of the matrix will be colored to show differences in annotations", commandRec);    	 		}    	 		if (table != null)    	 			table.repaintAll();    	 	}    	 	else if (checker.compare(this.getClass(), "Incorporates differences from other matrix if newer", null, commandName, "incorpDiff")) {    	 		if (!isActive()) {				MesquiteModule mb = findEmployerWithDuty(DataWindowMaker.class);				if (mb != null && mb instanceof DataWindowMaker)					((DataWindowMaker)mb).demandCellColorer(this,"The cells of the matrix will be colored to show differences in annotations", commandRec);    	 		}    	 		importChanges(true);    	 		if (table != null)    	 			table.repaintAll();    	 	}    	 	else if (checker.compare(this.getClass(), "Incorporates differences from other matrix", null, commandName, "incorpRegardless")) {    	 		if (!isActive()) {				MesquiteModule mb = findEmployerWithDuty(DataWindowMaker.class);				if (mb != null && mb instanceof DataWindowMaker)					((DataWindowMaker)mb).demandCellColorer(this,"The cells of the matrix will be colored to show differences in annotations", commandRec);    	 		}    	 		importChanges(false);    	 		if (table != null)    	 			table.repaintAll();    	 	}     	 	else if (checker.compare(this.getClass(), "Toggles whether ID strings of annotations used to decide if same.", "[on = use ids; off]", commandName, "toggleUseIDs")) {    	 		boolean current = useIDs.getValue();    	 		useIDs.toggleValue(ParseUtil.getFirstToken(arguments,new MesquiteInteger(0)));    	 		if (useIDs.getValue() != current && table != null) {     	 			table.repaintAll();			}    	 	}     	 	else if (checker.compare(this.getClass(), "Toggles whether annotation incorporation respects last modified and only uses newer.", "[on = use last modification times; off]", commandName, "toggleUseLMs")) {    	 		//not used    	 	}   	 	else if (checker.compare(this.getClass(), "Exterminates duplicate annotations", null, commandName, "exterminateDups")) {			if (data != null){				count = 0;				for (int it = 0; it<data.getNumTaxa(); it++){					AttachedNotesVector v = (AttachedNotesVector)data.getTaxa().getAssociatedObject(notesNameRef, it);						if (v != null)							if (exterminateIdenticalNotes(v, true, true))								logln("Annotation(s) deleted for taxon " + (it+1));				}				for (int ic = 0; ic<data.getNumChars(); ic++){					AttachedNotesVector v = (AttachedNotesVector)data.getAssociatedObject(notesNameRef, ic);						if (v != null)							if (exterminateIdenticalNotes(v, true, true))								logln("Annotation(s) deleted for character " + (ic+1));				}				for (int ic = 0; ic<data.getNumChars(); ic++){					for (int it = 0; it<data.getNumTaxa(); it++){						AttachedNotesVector v = (AttachedNotesVector)data.getCellObject(notesNameRef, ic, it);						if (v != null)							if (exterminateIdenticalNotes(v, true, true))								logln("Annotation(s) deleted for character " + (ic+1) + " and taxon " + (it+1));												}				}				if (count == 0)					discreetAlert(commandRec, "No duplicates found");				else					discreetAlert(commandRec, Integer.toString(count) + " duplicate annotations deleted.  See log for details.");				if (table!=null)					table.repaintAll();    	 		}    	 	}      	 	else    	 		return super.doCommand(commandName, arguments, commandRec, checker);    	 	return null;    	 }	/*.................................................................................................................*/	public void setTableAndData(MesquiteTable table, CharacterData data, CommandRecord commandRec){		this.table = table;		this.data = data;	}	public void endJob(){		if (oData!=null)			oData.removeListener(this);		super.endJob();	}	public void disposing(Object obj){		if (obj == oData)			oData = null;	}		/** passes which object changed, along with optional code number (type of change) and integers (e.g. which character)*/	public void changed(Object caller, Object obj, Notification notification, CommandRecord commandRec){		if (obj instanceof CharacterData){			if (table!=null && isActive()) {				table.repaintAll();			}			//parametersChanged(null, commandRec);		}	}	/*.................................................................................................................*/    	 public String getName() {		return "Annotation Comparison";   	 }	/*.................................................................................................................*/    	 public String getNameForMenuItem() {		return "*Compare Annotations in Matrices";   	 }	/*.................................................................................................................*/  	 public String getExplanation() {		return "Colors the cells of a character matrix by whether or not they differ from another comparable matrix in attached annotations.";   	 }   	 	/*.................................................................................................................*/   	public void viewChanged(CommandRecord commandRec){   	}	/*.................................................................................................................*/   	TextArea panelText = null;   	DWPanel panel = null;	void setPanel(boolean showPanel){		Frame f = containerOfModule();		if (f instanceof TableWindow){			if (showPanel){				if (panel == null)					panel = new DWPanel();				((TableWindow)f).addSidePanel(panel, DWPanel.width);				panelText = panel.getTextArea();			}			else {				if (panel != null)					((TableWindow)f).removeSidePanel(panel);			}		}			}   	 public void setActiveColors(boolean active, CommandRecord commandRec){   	 	setActive(active);   		if (!active) {   			setPanel(false);   			return;   		}   			//todo should remember if turned off and on   			//should not alert if scripting   		CharacterData ooData = null;   		Taxa taxa = data.getTaxa();		int numSets = getProject().getNumberCharMatrices(taxa);		int numSetsDiff = numSets;		for (int i = 0; i<numSets; i++) {			CharacterData pData =getProject().getCharacterMatrix(taxa, i);			if (pData== data)				numSetsDiff--;			else if (pData.getClass() != data.getClass())				numSetsDiff--;		}		if (numSetsDiff<=0) {			discreetAlert(commandRec, "Sorry, there are no other compatible data matrices available for comparison.  If the other matrix is in another file, open the file as a linked file before attempting to compare.");		}		else {			Listable[] matrices = new Listable[numSetsDiff];			int count=0;			ooData = null;			for (int i = 0; i<numSets; i++) {				CharacterData pData =getProject().getCharacterMatrix(taxa, i);				if (pData!= data && (pData.getClass() == data.getClass())) {					matrices[count]=pData;					if (numSetsDiff==1 && count == 0) {						ooData = pData;						break;					}					count++;									}			}			boolean differenceFound=false;			if (ooData == null)				ooData = (CharacterData)ListDialog.queryList(containerOfModule(), "Compare with", "Compare data matrix with:", MesquiteString.helpString,matrices, 0);		}		if (this.oData!=ooData && this.oData!=null)			this.oData.removeListener(this);   		setPanel(true);		this.oData = ooData;		if (ooData != null)			ooData.addListener(this);	 }	 	/*.................................................................................................................*/	 	CharacterState cs1 = null;	CharacterState cs2 = null;	NameReference notesNameRef = NameReference.getNameReference("notes");		private AttachedNotesVector getVector(CharacterData d, int ic, int it){		if (ic == -1)			return (AttachedNotesVector)d.getTaxa().getAssociatedObject(notesNameRef, it);		else if (it == -1)			return (AttachedNotesVector)d.getAssociatedObject(notesNameRef, ic);		else if (ic>= 0 && it>=0)			return (AttachedNotesVector)d.getCellObject(notesNameRef, ic, it);		return null;	}	public Color getCellColor(int ic, int it){		if (data == null || oData == null|| !isActive())			return null;		if (ic<0 && it<0)			return null;		AttachedNotesVector v = getVector(data, ic, it);		AttachedNotesVector vO = getVector(oData, ic, it);				if (v == null && vO == null)			return colorForStates(ic, it);		if (v == null) {			return Color.orange;  //this has no annotations; other has annotations		}		else if (vO == null) {			return ColorDistribution.lightBlue;  //this has annotations; other has none		}		int comparison = 0;		if (!useIDs.getValue())			comparison = v.compareNotesByContent(vO, true, true);		else			comparison = v.compareNotesByDescent(vO);		if (comparison == AttachedNotesVector.SUBSET)  //other matrix has additional annotations			return Color.yellow;		else if (comparison == AttachedNotesVector.SUPERSET) //this matrix has additional annotations			return ColorDistribution.lightGreen;		else if (comparison == AttachedNotesVector.NOTCONTAINED) //both matrices have annotations the other doesn't			return Color.red;		else if (comparison == AttachedNotesVector.EQUALBUTMODIFIED) //both matrices have same annotations but they are modififed			return Color.cyan;		else 			return colorForStates(ic, it);	}	Color colorForStates(int ic, int it){		if (it<0 && data instanceof CategoricalData && oData instanceof CategoricalData) {  //for character			for (int st = 0; st <= CategoricalState.maxCategoricalState; st++){				AttachedNotesVector anv = ((CategoricalData)data).getStateAnnotationsVector(ic, st);				AttachedNotesVector anvO = ((CategoricalData)oData).getStateAnnotationsVector(ic, st);				if (anv != null || anvO != null){					if (anv == null)						return Color.orange;  					else if (anvO == null)						return ColorDistribution.lightBlue;					else {						int comparison = 0;						if (!useIDs.getValue())							comparison = anv.compareNotesByContent(anvO, true, true);						else							comparison = anv.compareNotesByDescent(anvO);						if (comparison == AttachedNotesVector.SUBSET)  //other matrix has additional annotations							return Color.yellow;						else if (comparison == AttachedNotesVector.SUPERSET) //this matrix has additional annotations							return ColorDistribution.lightGreen;						else if (comparison == AttachedNotesVector.NOTCONTAINED) //both matrices has annotations the other doesn't							return Color.red;						else if (comparison == AttachedNotesVector.EQUALBUTMODIFIED) //both matrices have same annotations but they are modififed							return Color.cyan;						else 							return Color.white;					}				}			}		}		return Color.white;	}   	ColorRecord[] legend;   	public ColorRecord[] getLegendColors(CommandRecord commandRec){   		if (legend == null) {   			legend = new ColorRecord[7];   			legend[0] = new ColorRecord(Color.white, "Same annotations");   			legend[1] = new ColorRecord(Color.cyan, "Same annotations, but contents different");   			legend[2] = new ColorRecord(ColorDistribution.lightGreen, "Both matrices with annotations, but this with additional");   			legend[3] = new ColorRecord(ColorDistribution.lightBlue, "Other matrix lacks annotations at this cell");    			legend[4] = new ColorRecord(Color.yellow, "* Both matrices with annotations, but other with additional");   			legend[5] = new ColorRecord(Color.orange, "* This matrix lacks annotations at this cell; other has annotations");   			legend[6] = new ColorRecord(Color.red, "* Each matrix has annotations the other doesn't at this cell");  		}   		return legend;   	}   	public String getColorsExplanation(CommandRecord commandRec){   		return null;   	}	/*.................................................................................................................*/   	public String getCellString(int ic, int it){		if (data == null || oData == null || !isActive())			return null;		if (ic<0 && it<0)			return null;		AttachedNotesVector v = getVector(data, ic, it);		AttachedNotesVector vO = getVector(oData, ic, it);		String s;		if (v == null && vO == null)			s = "";		else if (v == null) {			s = "The cell in this matrix lacks annotations; the cell in the other matrix has annotations.";		}		else if (vO == null) {			s = "The cell in this matrix has annotations; the cell in the other matrix doesn't.";		}		else {			int comparison = 0;			if (!useIDs.getValue())				comparison = v.compareNotesByContent(vO, true, true);			else				comparison = v.compareNotesByDescent(vO);			if (comparison == AttachedNotesVector.SUBSET)  //other matrix has additional annotations				s =  "The cell in the other matrix has additional annotations lacking in this matrix.";			else if (comparison == AttachedNotesVector.SUPERSET) //this matrix has additional annotations				s = "The cell in this matrix has additional annotations lacking in the other matrix.";			else if (comparison == AttachedNotesVector.NOTCONTAINED) //both matrices has annotations the other doesn't				s = "Each matrix has annotations the other doesn't at this cell";			else if (comparison == AttachedNotesVector.EQUALBUTMODIFIED) //both matrices have same annotations but they are modififed				s = "Each matrix has the same annotations at this cell, but their contents are not the same (i.e. one has been modified).";			else 				s = "Annotations in this cell are the same (if any) in both matrices.";		}		return s + stringForStates(ic, it);   	}   	String stringForStates(int ic, int it) {   		String s = "";		if (it<0 && data instanceof CategoricalData && oData instanceof CategoricalData) {  //for character			for (int st = 0; st <= CategoricalState.maxCategoricalState; st++){				AttachedNotesVector anv = ((CategoricalData)data).getStateAnnotationsVector(ic, st);				AttachedNotesVector anvO = ((CategoricalData)oData).getStateAnnotationsVector(ic, st);				if (anv != null || anvO != null){					if (anv == null)						s += "\nState " + st + " lacks annotations in this matrix, but has annotations in the other.";					else if (anvO == null)						s += "\nState " + st + " lacks annotations in the other matrix, but has annotations in this.";					else {						int comparison = 0;						if (!useIDs.getValue())							comparison = anv.compareNotesByContent(anvO, true, true);						else							comparison = anv.compareNotesByDescent(anvO);						if (comparison == AttachedNotesVector.SUBSET)  //other matrix has additional annotations							s +=  "\nState " + st + " in the other matrix has additional annotations lacking in this matrix.";						else if (comparison == AttachedNotesVector.SUPERSET) //this matrix has additional annotations							s += "\nState " + st + "  in this matrix has additional annotations lacking in the other matrix.";						else if (comparison == AttachedNotesVector.NOTCONTAINED) //both matrices has annotations the other doesn't							s += "\nEach matrix has annotations the other doesn't at state " + st;						else if (comparison == AttachedNotesVector.EQUALBUTMODIFIED) //both matrices have same annotations but they are modififed							s += "\nEach matrix has the same annotations at state " + st + ", but their contents are not the same (i.e. one has been modified).";						else 							s += "\nAnnotations in state " + st + " are the same (if any) in both matrices.";					}				}			}		}		return s;   	}	private boolean importChanges(boolean useLMS){		if (data == null || oData == null)			return false;		boolean changed = false;		boolean noneSelected = (table == null) || !table.anythingSelected();		for (int ic = -1; ic<data.getNumChars(); ic++){			for (int it = -1; it<data.getNumTaxa(); it++){				if (noneSelected || table.isCellSelectedAnyWay(ic, it)){					AttachedNotesVector v = getVector(data, ic, it);					AttachedNotesVector vO = getVector(oData, ic, it);					if (vO == null) { //no notes; do nothing					}					else if (v == null) {						if (ic<0)							v = vO.cloneVector(data.getTaxa());						else							v = vO.cloneVector(data);						if (ic<0)							data.getTaxa().setAssociatedObject(notesNameRef, it, v);						else if (it < 0)							data.setAssociatedObject(notesNameRef, ic, v);						else {							data.setCellObject(notesNameRef, ic, it, v);							data.setCellObjectDisplay(ic, it);						}					}					else if (useIDs.getValue()){						int comparison = v.compareNotesByDescent(vO);						if (comparison == AttachedNotesVector.SUBSET || comparison == AttachedNotesVector.NOTCONTAINED || comparison == AttachedNotesVector.EQUALBUTMODIFIED){							v.incorporateByDescent(vO, useLMS);  							changed = true;						}					}					else {						int comparison = v.compareNotesByContent(vO, true, true);						if (comparison == AttachedNotesVector.SUBSET || comparison == AttachedNotesVector.NOTCONTAINED || comparison == AttachedNotesVector.EQUALBUTMODIFIED){							v.incorporateByContent(vO);							changed = true;						}					}										if (it<0 && data instanceof CategoricalData && oData instanceof CategoricalData) {  //for character						for (int st = 0; st <= CategoricalState.maxCategoricalState; st++){							AttachedNotesVector anv = ((CategoricalData)data).getStateAnnotationsVector(ic, st);							AttachedNotesVector anvO = ((CategoricalData)oData).getStateAnnotationsVector(ic, st);							if (anv != null || anvO != null){								if (anv == null)									((CategoricalData)data).setStateAnnotationsVector(ic, st, anvO.cloneVector(data));								else {									int comparison = 0;									if (!useIDs.getValue()) {										comparison = anv.compareNotesByContent(anvO, true, true);										if (comparison == AttachedNotesVector.SUBSET || comparison == AttachedNotesVector.NOTCONTAINED || comparison == AttachedNotesVector.EQUALBUTMODIFIED){											anv.incorporateByDescent(anvO, useLMS);  											changed = true;										}									}									else {										comparison = anv.compareNotesByDescent(anvO);										if (comparison == AttachedNotesVector.SUBSET || comparison == AttachedNotesVector.NOTCONTAINED || comparison == AttachedNotesVector.EQUALBUTMODIFIED){											anv.incorporateByContent(anvO);  											changed = true;										}									}																	}							}						}					}				}			}					}		if (table != null)			table.repaintAll();		return changed;	}	/*.................................................................................................................*/   	public void focusInCell(int ic, int it){		if (data == null || oData == null || !isActive() || panelText == null)			return;		if (ic<0 && it<0)			return;		AttachedNotesVector v = getVector(data, ic, it);		AttachedNotesVector vO = getVector(oData, ic, it);		if (v == null && vO == null) {			panelText.setText("Neither matrix has annotations at this cell." + stringForStates(ic, it));			return;		}		String s = "";		if (v == null) {			s= "The cell in this matrix lacks annotations; the cell in the other matrix has annotations";		}		else if (vO == null) {			s= "The cell in this matrix has annotations; the cell in the other matrix doesn't";		}		else {			int comparison = 0;			if (!useIDs.getValue())				comparison = v.compareNotesByContent(vO, true, true);			else				comparison = v.compareNotesByDescent(vO);			if (comparison == AttachedNotesVector.SUBSET)  //other matrix has additional annotations				s= "The cell in the other matrix has additional annotations lacking in this matrix";			else if (comparison == AttachedNotesVector.SUPERSET) //this matrix has additional annotations				s= "The cell in the this matrix has additional annotations lacking in the other matrix";			else if (comparison == AttachedNotesVector.NOTCONTAINED) //both matrices has annotations the other doesn't				s= "Each matrix has annotations the other doesn't at this cell";			else if (comparison == AttachedNotesVector.EQUALBUTMODIFIED) //both matrices have same annotations but they are modififed				s= "Each matrix has the same annotations at this cell, but their contents are not the same (i.e. one has been modified)";			else 				s= "Annotations in this cell are the same (if any) in both matrices";			StringBuffer sb = new StringBuffer();			v.describeDifferencesByDescent(vO, true, sb);			s += "\n\n" + sb.toString();		}			s += stringForStates(ic, it);		panelText.setText(s);   	}	public CompatibilityTest getCompatibilityTest(){		return new CharacterStateTest();	}	public String getParameters(){		if (isActive())			return getName();		return null;	}}	class DWPanel extends MousePanel{	static final int width = 300;	static final int height = 36;	int ic;	int it;	TextArea text;	String taxonName = null;	public DWPanel (){		super();		text = new TextArea(" ", 20, 50, TextArea.SCROLLBARS_VERTICAL_ONLY);		setLayout(null);		text.setVisible(true);		add(text);		setBackground(ColorDistribution.lightBlue);		text.setBackground(ColorDistribution.veryLightBlue);		setSize(width, 500);	}	TextArea getTextArea(){		return text;	}	public void setSize(int w, int h){		text.setSize(w, h-height);		super.setSize(w, h);	}	public void setBounds(int x, int y, int w, int h){		text.setBounds(0, height, w, h-height);		super.setBounds(x, y, w, h);	}	public void paint(Graphics g){		g.drawString("Comparison of matrices (annotations)", 10, height - 22);		g.fillRect(0, height-2, getBounds().width, 2);	}}	