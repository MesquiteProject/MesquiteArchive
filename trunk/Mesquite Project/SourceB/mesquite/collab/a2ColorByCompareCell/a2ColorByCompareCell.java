/* Mesquite source code.  Copyright 1997-2005 W. Maddison and D. Maddison. Version 1.06, September 2005.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.collab.a2ColorByCompareCell; import java.util.*;import java.awt.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.lib.table.*;/* ======================================================================== */public class a2ColorByCompareCell extends DataWindowAssistantI implements CellColorer {	MesquiteTable table;	CharacterData data, oData;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName){		mesquite.collab.a0CollabINIT.a0CollabINIT init = (mesquite.collab.a0CollabINIT.a0CollabINIT)findNearestColleagueWithName("a0CollabINIT");		if (init == null)			return false;		addMenuItem(init.collabMenu, "-", null);		addMenuItem(init.collabMenu, "4. Show state differences", makeCommand("showDiff",  this));		addMenuItem(init.collabMenu, "5. Incorporate States if Newer", makeCommand("incorpDiff",  this));		addMenuItem(init.collabMenu, "Incorporate States Regardless", makeCommand("incorpRegardless",  this));		return true;	}	/*.................................................................................................................*/  	 public Snapshot getSnapshot(MesquiteFile file) {  	 	Snapshot temp = new Snapshot(); 	 	return temp;  	 }	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {    	 	if (checker.compare(this.getClass(), "Shows differences from other matrix if newer", null, commandName, "showDiff")) {    	 		if (!isActive()) {				MesquiteModule mb = findEmployerWithDuty(DataWindowMaker.class);				if (mb != null && mb instanceof DataWindowMaker)					((DataWindowMaker)mb).demandCellColorer(this,"The cells of the matrix will be colored to show differences in states", commandRec);    	 		}    	 	}    	 	else if (checker.compare(this.getClass(), "Incorporates differences from other matrix if newer", null, commandName, "incorpDiff")) {    	 		if (!isActive()) {				MesquiteModule mb = findEmployerWithDuty(DataWindowMaker.class);				if (mb != null && mb instanceof DataWindowMaker)					((DataWindowMaker)mb).demandCellColorer(this,"The cells of the matrix will be colored to show differences in states", commandRec);    	 		}    	 		    	 		importChanges(true);    	 	}    	 	else if (checker.compare(this.getClass(), "Incorporates differences from other matrix", null, commandName, "incorpRegardless")) {    	 		if (!isActive()) {				MesquiteModule mb = findEmployerWithDuty(DataWindowMaker.class);				if (mb != null && mb instanceof DataWindowMaker)					((DataWindowMaker)mb).demandCellColorer(this,"The cells of the matrix will be colored to show differences in states", commandRec);    	 		}    	 		    	 		importChanges(false);    	 	}     	 	else if (checker.compare(this.getClass(), "Toggles whether annotation incorporation respects last modified and only uses newer.", "[on = use last modification times; off]", commandName, "toggleUseLMs")) {    	 		//no longer used    	 	}    	 	else    	 		return super.doCommand(commandName, arguments, commandRec, checker);		return null;   	 }	/*.................................................................................................................*/   	 public boolean isSubstantive(){   	 	return true;   	 }	/*.................................................................................................................*/	public void setTableAndData(MesquiteTable table, CharacterData data, CommandRecord commandRec){		this.table = table;		this.data = data;	}	public void endJob(){		if (oData!=null)			oData.removeListener(this);		super.endJob();	}	/** passes which object changed, along with optional code number (type of change) and integers (e.g. which character)*/	public void changed(Object caller, Object obj, Notification notification, CommandRecord commandRec){		if (obj instanceof CharacterData){			if (table!=null && isActive()) {				table.repaintAll();			}			//parametersChanged(null, commandRec);		}	}	public void disposing(Object obj){		if (obj == oData)			oData = null;	}	/*.................................................................................................................*/    	 public String getName() {		return "State Comparison";   	 }	/*.................................................................................................................*/    	 public String getNameForMenuItem() {		return "*Compare States in Matrices";   	 }	/*.................................................................................................................*/  	 public String getExplanation() {		return "Colors the cells of a character matrix by whether or not they differ from another comparable matrix.";   	 }   	 	/*.................................................................................................................*/   	public void viewChanged(CommandRecord commandRec){   	}	/*.................................................................................................................*/   	TextArea panelText = null;   	DWPanel panel = null;	void setPanel(boolean showPanel){		Frame f = containerOfModule();		if (f instanceof TableWindow){			if (showPanel){				if (panel == null)					panel = new DWPanel();				((TableWindow)f).addSidePanel(panel, DWPanel.width);				panelText = panel.getTextArea();			}			else {				if (panel != null)					((TableWindow)f).removeSidePanel(panel);			}		}			}   	 public void setActiveColors(boolean active, CommandRecord commandRec){   	 	setActive(active);   		if (!active) {   			setPanel(false);   			return;   		}   			//todo should remember if turned off and on   			//should not alert if scripting   		CharacterData ooData = null;   		Taxa taxa = data.getTaxa();		int numSets = getProject().getNumberCharMatrices(taxa);		int numSetsDiff = numSets;		for (int i = 0; i<numSets; i++) {			CharacterData pData =getProject().getCharacterMatrix(taxa, i);			if (pData== data)				numSetsDiff--;			else if (pData.getClass() != data.getClass())				numSetsDiff--;		}		if (numSetsDiff<=0) {			discreetAlert(commandRec, "Sorry, there are no other compatible data matrices available for comparison.  If the other matrix is in another file, open the file as a linked file before attempting to compare.");		}		else {			Listable[] matrices = new Listable[numSetsDiff];			int count=0;			ooData = null;			for (int i = 0; i<numSets; i++) {				CharacterData pData =getProject().getCharacterMatrix(taxa, i);				if (pData!= data && (pData.getClass() == data.getClass())) {					matrices[count]=pData;					if (numSetsDiff==1 && ooData == null) {						ooData = pData;						break;					}					count++;									}			}			boolean differenceFound=false;			if (ooData == null)				ooData = (CharacterData)ListDialog.queryList(containerOfModule(), "Compare with", "Compare data matrix with:", MesquiteString.helpString,matrices, 0);		}		if (this.oData!=ooData && this.oData!=null)			this.oData.removeListener(this);		this.oData = ooData;   		setPanel(true);		if (ooData == null)			return;		ooData.addListener(this);	 }	/*.................................................................................................................*/	NameReference historyNameRef = NameReference.getNameReference("ChangeHistory");   	private ChangeHistory getHistory(CharacterData d, int ic, int it){   		if (d == null)   			return null;   		return (ChangeHistory)d.getCellObject(historyNameRef, ic, it);   	}	/*.................................................................................................................*/	CharacterState cs1 = null;	CharacterState cs2 = null;		private int getCategory(int ic, int it){		if (data == null || oData == null)			return -1;		int diff = 0;		if (ic<0 || it<0)			return -1;		cs1 = data.getCharacterState(cs1, ic, it);		cs2 = oData.getCharacterState(cs2, ic, it);		if (cs1 != null && !cs1.equals(cs2))			diff = 100;		ChangeHistory h1 = getHistory(data, ic, it);		ChangeHistory h2 = getHistory(oData, ic, it);		int comparison;		if (h1 == null && h2 == null)			comparison = ChangeHistory.NOHISTORY;		else if (h1 == null) 			comparison = ChangeHistory.SUBSET;		else if (h2 == null) 			comparison = ChangeHistory.SUPERSET;		else {			comparison = h1.compareHistories(h2);		}		return diff + comparison;	}		private boolean importChanges(boolean useLMS){		if (data == null || oData == null)			return false;		boolean changed = false;		boolean noneSelected = (table == null) || !table.anyCellSelectedAnyWay();		for (int ic = 0; ic<data.getNumChars(); ic++){			for (int it = 0; it<data.getNumTaxa(); it++){				if (noneSelected || table.isCellSelectedAnyWay(ic, it)){					int cat = getCategory(ic, it);					boolean diff = false;					ChangeHistory h1 = getHistory(data, ic, it);					ChangeHistory h2 = getHistory(oData, ic, it);					if (cat>=100){ //difference in states						diff = true;						cat = cat-100;					}										if (diff) { //import character states						cs2 = oData.getCharacterState(cs2, ic, it);						if (cs2 !=null) {							boolean imprt = true;							if (useLMS){								if (h1 == null && h2 == null)									imprt = false;								else if (h2 == null)									imprt = false;								else if (h1!= null && h1.lastModified()>h2.lastModified())									imprt = false;							}							if (imprt) {								data.incrementSuppressHistoryStamp();								data.setState(ic, it, cs2);								data.decrementSuppressHistoryStamp();								changed = true;							}						}					}					if (cat == ChangeHistory.NOTCONTAINED || cat == ChangeHistory.SUBSET ){						if (h1 == null) { // need to pull history over entirely							if (h2 != null){								h1 = h2.cloneHistory();								data.setCellObject(historyNameRef, ic, it, h1);							}						}						else							h1.incorporate(h2);							changed = true;					}				}			}					}		data.notifyListeners(this, new Notification(MesquiteListener.PARTS_CHANGED));		return changed;	}		public Color getCellColor(int ic, int it){		if (data == null || oData == null)			return null;		boolean diff = false;		if (ic<0 && it<0)			return null;		if (it<0) { //char			String n = data.getCharacterName(ic);			String nO = oData.getCharacterName(ic);			if ( !StringUtil.stringsEqual(n, nO))				return Color.gray;			else				return null;		}		else if (ic<0) {			return null;		}		int cat = getCategory(ic, it);		int comparison = cat;				if (cat>=100) {			comparison = cat-100;			diff = true;		}		else			diff = false;		if (comparison == ChangeHistory.SUBSET){  //other matrix has additional change events			if (diff)				return Color.orange;			else				return ColorDistribution.straw;		}		else if (comparison == ChangeHistory.SUPERSET){ //this matrix has additional change events			if (diff)				return Color.green;			else				return ColorDistribution.lightGreen;		}		else if (comparison == ChangeHistory.NOTCONTAINED){ //both matrices have change events the other doesn't			if (diff)				return Color.red;			else				return ColorDistribution.lightRed;		}		else if (comparison == ChangeHistory.NOHISTORY){ //change events are not recorded			if (diff)				return ColorDistribution.lightBlue;			else				return null;		}		else if (comparison == ChangeHistory.EQUAL){ //change events are the same			if (diff)				return Color.blue;			else				return Color.white;		}		else			return Color.white;	}   	ColorRecord[] legend;   	public ColorRecord[] getLegendColors(CommandRecord commandRec){   		if (legend == null) {   			legend = new ColorRecord[9];   			legend[0] = new ColorRecord(Color.white, "States and histories same");   			legend[1] = new ColorRecord(Color.orange, "States differ; other more recently changed");   			legend[2] = new ColorRecord(ColorDistribution.straw, "States same, but other more recently changed");   			legend[3] = new ColorRecord(Color.green, "States differ; this more recently changed");    			legend[4] = new ColorRecord(ColorDistribution.lightGreen, "States same, but this more recently changed");   			legend[5] = new ColorRecord(Color.red, "POTENTIAL CONFLICT: States differ; both appear modified independently");   			legend[6] = new ColorRecord(ColorDistribution.lightRed, "States same, but both appear modified independently");   			legend[7] = new ColorRecord(ColorDistribution.lightBlue, "States differ; netiher matrix with record of changes");   			legend[8] = new ColorRecord(Color.blue, "POTENTIAL CONFLICT: states differ, but both show same history of changes!");  		}   		return legend;   	}   	public String getColorsExplanation(CommandRecord commandRec){   		return null;   	}	/*.................................................................................................................*/   	public String getCellString(int ic, int it){		if (data == null || oData == null || !isActive())			return null;		if (ic<0 && it<0)			return null;		if (it<0) { //char			String n = data.getCharacterName(ic);			String nO = oData.getCharacterName(ic);			if ( !StringUtil.stringsEqual(n, nO))				return "Character names are different";			else				return null;		}		else if (ic<0) {			return null;		}		boolean diff;		int cat = getCategory(ic, it);		int comparison = cat;				if (cat>=100) {			comparison = cat-100;			diff = true;		}		else			diff = false;		if (comparison == ChangeHistory.SUBSET){  //other matrix has additional change events			if (diff)				return "States differ; the other matrix has been more recently changed.";			else				return "States are the same, but the other matrix has been more recently changed.";		}		else if (comparison == ChangeHistory.SUPERSET){ //this matrix has additional change events			if (diff)				return "States differ, and this matrix has been more recently changed.";			else				return "States are the same, but this matrix has been more recently changed.";		}		else if (comparison == ChangeHistory.NOTCONTAINED){ //both matrices have change events the other doesn't			if (diff)				return "WARNING; POTENTIAL CONFLICT: States differ; both matrices seem to have been modified independently!  That is, each matrix records events of change the other matrix doesn't record!";			else				return "States are the same, BUT both matrices seem to have been modified independently.  That is, each matrix records events of change the other matrix doesn't record.";		}		else if (comparison == ChangeHistory.NOHISTORY){ //change events are not recorded			if (diff)				return "States differ.  Neither matrix has a record of the history of changes.";			else				return "States are the same.  Neither matrix has a record of the history of changes.";		}		else if (comparison == ChangeHistory.EQUAL){ //change events are the same			if (diff)				return "WARNING; POTENTIAL CONFLICT: States differ, BUT both matrices record the same history of changes!  It is possible that one matrix was modified outside of the collaborative version of Mesquite.";			else				return "States are the same, and both matrices record the same history of changes.";		}		else			return null;   	}	/*.................................................................................................................*/   	public void focusInCell(int ic, int it){		if (data == null || oData == null || !isActive() || panelText == null)			return ;		if (ic<0 && it<0)			return ;		if (it<0) { //char			String n = data.getCharacterName(ic);			String nO = oData.getCharacterName(ic);			if ( !StringUtil.stringsEqual(n, nO))				panelText.setText("Character " + (ic+1) + ":  Character names are different");			return ;		}		else if (ic<0) {			panelText.setText("");			return ;		}		boolean diff;		int cat = getCategory(ic, it);		int comparison = cat;				if (cat>=100) {			comparison = cat-100;			diff = true;		}		else			diff = false;		StringBuffer sb = new StringBuffer();		if (comparison == ChangeHistory.SUBSET){  //other matrix has additional change events			if (diff)				sb.append("States differ; the other matrix has been more recently changed.");			else				sb.append("States are the same, but the other matrix has been more recently changed.");		}		else if (comparison == ChangeHistory.SUPERSET){ //this matrix has additional change events			if (diff)				sb.append("States differ, and this matrix has been more recently changed.");			else				sb.append("States are the same, but this matrix has been more recently changed.");		}		else if (comparison == ChangeHistory.NOTCONTAINED){ //both matrices have change events the other doesn't			if (diff)				sb.append("WARNING; POTENTIAL CONFLICT: States differ; both matrices seem to have been modified independently!  That is, each matrix records events of change the other matrix doesn't record!");			else				sb.append("States are the same, BUT both matrices seem to have been modified independently.  That is, each matrix records events of change the other matrix doesn't record.");		}		else if (comparison == ChangeHistory.NOHISTORY){ //change events are not recorded			if (diff)				sb.append("States differ.  Neither matrix has a record of the history of changes.");			else				sb.append("States are the same.  Neither matrix has a record of the history of changes.");		}		else if (comparison == ChangeHistory.EQUAL){ //change events are the same			if (diff)				sb.append("WARNING; POTENTIAL CONFLICT: States differ, BUT both matrices record the same history of changes!  It is possible that one matrix was modified outside of the collaborative version of Mesquite.");			else				sb.append("States are the same, and both matrices record the same history of changes.");		}		cs2 = oData.getCharacterState(cs2, ic, it);		ChangeHistory h1 = getHistory(data, ic, it);		ChangeHistory h2 = getHistory(oData, ic, it);		sb.append( "\n\nState in this matrix: ");		data.statesIntoStringBuffer( ic,  it,  sb, true);		if (h1 == null)			sb.append("\n(No record of history of changes!)");		else			sb.append("\nLast recorded change: " + h1.getLastEvent());		sb.append("\n\nState in other matrix: ");		oData.statesIntoStringBuffer( ic,  it,  sb, true);		if (h2 == null)			sb.append("\n(No record of history of changes!)");		else			sb.append("\nLast recorded change: " + h2.getLastEvent());		//modification histories		sb.append("\n===============\nFull histories\n\nThis matrix:");		if (h1 == null)			sb.append(" No recorded history!");		else			sb.append("\n" + h1);		sb.append("\nOther matrix:");		if (h2 == null)			sb.append(" No recorded history!");		else			sb.append("\n" + h2);		panelText.setText(sb.toString());   	}	/*.................................................................................................................*/	public CompatibilityTest getCompatibilityTest(){		return new CharacterStateTest();	}	public String getParameters(){		if (isActive())			return getName();		return null;	}}class DWPanel extends MousePanel{	static final int width = 300;	static final int height = 36;	int ic;	int it;	TextArea text;	String taxonName = null;	public DWPanel (){		super();		text = new TextArea(" ", 20, 50, TextArea.SCROLLBARS_VERTICAL_ONLY);		setLayout(null);		text.setVisible(true);		add(text);		setBackground(ColorDistribution.lightGreen);		text.setBackground(ColorDistribution.veryLightGreen);		setSize(width, 500);	}	TextArea getTextArea(){		return text;	}	public void setSize(int w, int h){		text.setSize(w, h-height);		super.setSize(w, h);	}	public void setBounds(int x, int y, int w, int h){		text.setBounds(0, height, w, h-height);		super.setBounds(x, y, w, h);	}	public void paint(Graphics g){		g.drawString("Comparison of matrices (states)", 10, height - 22);		g.fillRect(0, height-2, getBounds().width, 2);	}}	