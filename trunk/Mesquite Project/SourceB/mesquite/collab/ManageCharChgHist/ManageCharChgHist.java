/* Mesquite source code.  Copyright 1997-2003 W. Maddison and D. Maddison. Version 0.996. June 2003.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.collab.ManageCharChgHist;/*~~  */import java.util.*;import java.awt.*;import java.io.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;public class ManageCharChgHist extends FileInit {	int numBlocks =0;	/*	static {		CharacterData.defaultSaveChangeHistory = true; //will set value to true on start		CharacterData.defaultRequireChangeAuthority = true;	}	/**/	public Class getDutyClass(){		return ManageCharChgHist.class;	}	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName) {		return true;  	 }	/*.................................................................................................................*/   	 public boolean isSubstantive(){   	 	return true;   	 }   	 public boolean isPrerelease(){   	 	return true;   	 }	/*.................................................................................................................*/ 	/** A method called immediately after the file has been read in or completely set up (if a new file).*/ 	public void fileReadIn(MesquiteFile f) { 		NexusBlock[] bs = getProject().getNexusBlocks(ChangeHistoryBlock.class, f); //added Dec 01		if (bs == null || bs.length ==0){ 			ChangeHistoryBlock ab = new ChangeHistoryBlock(f, this);			numBlocks++;			addNEXUSBlock(ab);		}			}	/*.................................................................................................................*/	public NexusBlockTest getNexusBlockTest(){ return new CharCghBlockTest();}	/*.................................................................................................................*/	public NexusBlock readNexusBlock(MesquiteFile file, String name, FileBlock block, StringBuffer blockComments, String fileReadingArguments, CommandRecord commandRec){		CharacterData data=null;		Parser commandParser = new Parser();		commandParser.setString(block.toString());		MesquiteInteger startCharC = new MesquiteInteger(0);		String title=null;		String commandString;		data = getProject().getCharacterMatrix(file, 0);  //default		if (data == null)			data = getProject().getCharacterMatrix(0);		if (data == null) //no matrices exist!!!			return null;		Taxa taxa= data.getTaxa();		NexusBlock b=new ChangeHistoryBlock(file, this);		NameReference changeHistoryRef = NameReference.getNameReference("ChangeHistory");		while (!commandParser.blankByCurrentWhitespace(commandString=commandParser.getNextCommand(startCharC))) {			String commandName = parser.getFirstToken(commandString);			if (commandName.equalsIgnoreCase("LINK")) {				if ("CHARACTERS".equalsIgnoreCase(parser.getTokenNumber(2))) {					String dataTitle = StringUtil.deTokenize(parser.getTokenNumber(4));					//logln("       for taxa " + taxaTitle);					CharacterData d = getProject().getCharacterData(file, dataTitle);					if (d == null)						d = getProject().getCharacterData(null, taxa, null, dataTitle);					if (d != null) {						data = d;					}				}			}			else if (commandName.equalsIgnoreCase("AUTHOR")) {				if (data==null) {					logln("Error in NEXUS file:  AUTHOR without data specified in change history");				}				else {					// author not yet handled				}			}			else if (commandName.equalsIgnoreCase("C")) {				if (data==null) {					logln("Error in NEXUS file:  CELL without data specified in change history");				}				else {					/*Author 0 'Joe Q.';					/* C 0 3  (0 time 'newState')   (1 time 'newState') 					*/					MesquiteInteger startCharF = new MesquiteInteger(0);					String tok = ParseUtil.getToken(commandString, startCharF);					int ic = MesquiteInteger.fromString(ParseUtil.getToken(commandString, startCharF)); //char code					int it = MesquiteInteger.fromString(ParseUtil.getToken(commandString, startCharF)); //taxon code										ChangeHistory ch = new ChangeHistory();					tok = ParseUtil.getToken(commandString, startCharF); //eat up "("					while (tok != null && !tok.equals(";")) {						String aCode = ParseUtil.getToken(commandString, startCharF);						Author author = getProject().findAuthor(aCode, false); //author code						if (author == null){							logln("   Unrecognized author code: " + aCode + ".");							author = new Author();							author.setCode(aCode);							author.setName("Anonymous");							if (aCode != null && aCode.length()>12 && NexusBlock.getTimeFromNEXUS(aCode)>0)								file.setOpenAsUntitled("Apparent misformat in CHARCHANGEHISTORY block; author code appears to be a date (ic " + ic + " it " + it + " aCode " + aCode + " t " + tok + ").  Please turn on automatic NEXUS backups in Defaults menu, and report this problem.");							getProject().getAuthors().addElement(author, false);						}						long time = NexusBlock.getTimeFromNEXUS(ParseUtil.getToken(commandString, startCharF)); //time code						String s = ParseUtil.getToken(commandString, startCharF); //change string						tok = ParseUtil.getToken(commandString, startCharF); 						String authority = null;						if (!(")".equals(tok))){							authority = tok;							tok = ParseUtil.getToken(commandString, startCharF); //eat up ")"						}						ChangeEvent e = ch.addEvent(author, time, s);						if (authority != null) {							ChangeAuthority ca = new ChangeAuthority();							ca.set("read " + MesquiteTrunk.startupTime);							e.setAuthority(ca);						}						tok = ParseUtil.getToken(commandString, startCharF); //eat up ";" or "("					}					data.setCellObject(changeHistoryRef, ic, it, ch);					}			}			else if (!(commandName.equalsIgnoreCase("BEGIN") || commandName.equalsIgnoreCase("END")  || commandName.equalsIgnoreCase("ENDBLOCK"))) {				boolean success = false;								if (!success && b != null) 					readUnrecognizedCommand(file,b, "CHARCHANGEHISTORY", block, commandName, commandString, blockComments, null);			}		}		return b;	}	/*.................................................................................................................*/    	 public String getName() {		return "Manage CHARCHANGEHISTORY blocks";   	 }   	 	/*.................................................................................................................*/ 	/** returns an explanation of what the module does.*/ 	public String getExplanation() { 		return "Manages CHARCHANGEHISTORY block in NEXUS file." ;   	 }}			/* ======================================================================== */class CharCghBlockTest extends NexusBlockTest  {	public CharCghBlockTest () {	}	public  boolean readsWritesBlock(String blockName, FileBlock block){ //returns whether or not can deal with block		return blockName.equalsIgnoreCase("CHARCHANGEHISTORY");	}}/* ======================================================================== *//**A NEXUS block that records change history of a character matrix.  Not yet available for public use */class ChangeHistoryBlock extends NexusBlock {	static NameReference changeHistoryRef = NameReference.getNameReference("ChangeHistory");		public ChangeHistoryBlock(MesquiteFile f, MesquiteModule mb){		super(f, mb);	}	public boolean contains(FileElement e) {		return false;  	}		public void written() {	}	public String getName(){		return "CHARCHANGEHISTORY block";	}	public boolean mustBeAfter(NexusBlock block){		if (block==null)			return false;		return (block.getBlockName().equalsIgnoreCase("TAXA") ||  block.getBlockName().equalsIgnoreCase("CHARACTERS"));			}	public String getBlockName(){		return "CHARCHANGEHISTORY";	}	public String getNEXUSBlock(){		StringBuffer contents = new StringBuffer(1000);		MesquiteProject proj = getFile().getProject();		int num = proj.getNumberCharMatrices(getFile());		String LE =  ";" +  StringUtil.lineEnding();		for (int i = 0; i<num; i++){			CharacterData data =  proj.getCharacterMatrix(getFile(), i); 			if (num>1) {				contents.append("LINK CHARACTERS = ");				contents.append(ParseUtil.tokenize(data.getName()));				contents.append(LE);			}			for (int ic = 0; ic < data.getNumChars(); ic++) {				for (int it = 0; it < data.getNumTaxa(); it++) {					ChangeHistory ch = (ChangeHistory)data.getCellObject(changeHistoryRef, ic, it);					if (ch!=null && ch.getNexusString()!=null){						contents.append("C ");						contents.append(Integer.toString(ic));						contents.append("  ");						contents.append(Integer.toString(it));						contents.append("  ");						ch.getNexusString(contents);						contents.append(LE);					}				}			}		}		String unrec = getUnrecognizedCommands();		if (StringUtil.blank(contents) && StringUtil.blank(unrec))			return null;		String blocks="BEGIN CHARCHANGEHISTORY;" + StringUtil.lineEnding();		blocks += contents.toString();		if (!StringUtil.blank(unrec)) {			blocks += StringUtil.lineEnding()+ unrec + StringUtil.lineEnding();		}		blocks += "END;" + StringUtil.lineEnding();		return blocks;	}}