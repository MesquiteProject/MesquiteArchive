/* Mesquite source code.  Copyright 1997-2002 W. Maddison & D. Maddison. Version 0.992.  September 2002.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.collab.CellImages; import java.util.*;import java.awt.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.lib.table.*;import mesquite.collab.lib.*;import mesquite.categ.lib.*;/** ======================================================================== */public class CellImages extends DataWindowAssistantI implements CellColorer, PanelOwner {	CharacterData data;	Taxa taxa;	CellDWPanel panel;	CellDWImagePanel iPanel;	MesquiteBoolean showPanel;	CellImageSource imageSource = null;	MesquiteTable table;	int[][] cache;	TableTool statesPageTool;		/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName){		showPanel = new MesquiteBoolean(false);				addCheckMenuItem(null, "Show Cell Images Panel", makeCommand("togglePanel", this), showPanel);		if (containerOfModule() instanceof MesquiteWindow) {			statesPageTool = new TableTool(this, "statesPageTool", getPath(), "states.gif", 7, 8, "Show States Page", "This tool shows state of character touched.", MesquiteModule.makeCommand("showStates", this), null, null); 			((MesquiteWindow)containerOfModule()).addTool(statesPageTool);		}		return true;	}	/*.................................................................................................................*/  	 public Snapshot getSnapshot(MesquiteFile file) {   	 	Snapshot temp = new Snapshot();  	 	temp.addLine("togglePanel " + showPanel.toOffOnString());  	 	//todo here: set source of images, and split as separate command below  	 	return temp;  	 }	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {    	 	if (checker.compare(this.getClass(), "Sets whether or not the image panel is shown", "[on = shown; off]", commandName, "togglePanel")) {    	 		showPanel.toggleValue(parser.getFirstToken(arguments));    	 		if (showPanel.getValue() && imageSource == null) {    	 			imageSource = (CellImageSource)hireEmployee(commandRec, CellImageSource.class, "Source of images");    	 			if (imageSource == null)    	 				showPanel.setValue(false);			}			setPanel(commandRec);    	 	}    	 	else if (checker.compare(this.getClass(),  "Shows states for that character", "[column touched][row touched]", commandName, "showStates")) {	   	 		if (data == null || !(data instanceof CategoricalData))	   	 			return null;	   	 		MesquiteInteger io = new MesquiteInteger(0);	   			int column= MesquiteInteger.fromString(arguments, io);	   			int row= MesquiteInteger.fromString(arguments, io);				if (MesquiteInteger.isNonNegative(column)&& (MesquiteInteger.isNonNegative(row))) {					CategoricalData cData = ((CategoricalData)data);					long state = cData.getState(column, row);					if (CategoricalState.cardinality(state)==1){						showStatePage(cData, column, CategoricalState.minimum(state), commandRec);					}		   	 	}   	 	}    	 	else    	 		return super.doCommand(commandName, arguments, commandRec, checker);		return null;   	 }	public void showStatePage(CategoricalData cData, int ic, int state, CommandRecord commandRec){		if (imageSource == null)			return;		Vector locations = new Vector();		Vector names = new Vector();		MesquiteString comment = new MesquiteString(); 		for (int it=0; it<cData.getNumTaxa(); it++){	 		long otherState = cData.getState(ic, it);	 		if (CategoricalState.cardinality(otherState)==1 && CategoricalState.minimum(otherState) == state){		 		int[] images = imageSource.getNumCellImages(cData, ic, it, commandRec);		 		int numImages = 0;		 		if (images != null)		 			numImages = images.length;		   				   		for(int i=0; i<numImages; i++) {   					String location = imageSource.getCellImageLocation( i, cData, ic, it,  comment,  commandRec);		   			locations.addElement(location);		   			names.addElement(cData.getTaxa().getTaxonName(it)+ ": " + comment);		   		}		   			   		}   		}   		if (locations.size() == 0)   			return;   		StringBuffer html = new StringBuffer(100);   		html.append("<html><body><table>");   		for (int i=0; i<locations.size(); i++){   			if (i % 3 == 0)   				html.append("<tr>");   			   			html.append("<td width = 100><img src=\"" + locations.elementAt(i) + "\"><br>" + names.elementAt(i) + "</td>");   			if (i % 3 == 0)   				html.append("</tr>");   		}   		html.append("</table></body></html>");   		String page = MesquiteModule.prefsDirectory + MesquiteFile.fileSeparator + "stateImages" + state + ".html";		MesquiteFile.putFileContents(page, html.toString(), true);		showWebPage(page, false);	}	/*.................................................................................................................*/   	 public void setActiveColors(boolean active, CommandRecord commandRec){   	 	setActive(active);   	 }   	ColorRecord[] legend;   	public ColorRecord[] getLegendColors(CommandRecord commandRec){   		if (legend == null) {   			legend = new ColorRecord[4];   			legend[0] = new ColorRecord(Color.white, "No Images");   			legend[1] = new ColorRecord(ColorDistribution.veryLightBlue, "One image");   			legend[2] = new ColorRecord(ColorDistribution.lightBlue, "Two Images");   			legend[3] = new ColorRecord(Color.blue, "More than Two");   		}   		return legend;   	}   	public String getColorsExplanation(CommandRecord commandRec){   		return null;   	}   			private int getNumImages(int ic, int it){		try{			if (ic<0 || it < 0)				return 0;			if (cache == null){				cache = new int[data.getNumChars()][data.getTaxa().getNumTaxa()];				for (int ic2 = 0; ic2<data.getNumChars(); ic2++)					for (int it2=0; it2<data.getTaxa().getNumTaxa(); it2++)						cache[ic2][it2] = -1;			}			if (cache[ic][it] < 0){		   		int[] nums = imageSource.getNumCellImages(data, ic, it, CommandRecord.nonscriptingRecord);		   		cache[ic][it] = 0;		   		if (nums != null)		   			cache[ic][it] = nums.length;	   		}	   		return cache[ic][it];   		}   		catch (Exception e){   		}   		return 0;   			}	public Color getCellColor(int ic, int it){		if (data == null || imageSource == null)			return null;		int num = getNumImages(ic, it);   		   		if (num <= 0)   			return Color.white;   		if (num== 1)   			return ColorDistribution.veryLightBlue;   		if (num== 2)   			return ColorDistribution.lightBlue;   		return Color.blue;	}	public String getCellString(int ic, int it){		if (data == null || imageSource == null)			return null;		int num = getNumImages(ic, it);   		if (num == 0)   			return "No images for this cell";   		if (num == 1)   			return "One image for this cell";   		if (num == 2)   			return "Two images for this cell";   		return "More than two images for this cell";	}	/*.................................................................................................................*/   	 public boolean isSubstantive(){   	 	return false;   	 }   	 public void viewChanged(CommandRecord commandRec){   	 }   	 	public void setTableAndData(MesquiteTable table, CharacterData data, CommandRecord commandRec){		if (data != this.data){			if (this.data != null)				this.data.removeListener(this);			data.addListener(this);		}		if (data != null && data.getTaxa() != this.taxa){			if (this.taxa != null)				this.taxa.removeListener(this);			data.getTaxa().addListener(this);			this.taxa = data.getTaxa();		}		this.table = table;		this.data = data;				setPanel(commandRec);	}	public void endJob(){		if (this.data != null)			this.data.removeListener(this);		if (this.taxa != null)			this.taxa.removeListener(this);		super.endJob();	}			/*.................................................................................................................*/	/** passes which object changed, along with optional integer (e.g. for character) (from MesquiteListener interface)*/	public void changed(Object caller, Object obj, Notification notification, CommandRecord commandRec){		int code = Notification.getCode(notification);		int[] parameters = Notification.getParameters(notification);		if (obj instanceof CharacterData && (CharacterData)obj ==data) {			if (code==MesquiteListener.NAMES_CHANGED || code==MesquiteListener.SELECTION_CHANGED || code==MesquiteListener.DATA_CHANGED) {			}			else if (code==MesquiteListener.PARTS_DELETED || code==MesquiteListener.PARTS_ADDED || code==MesquiteListener.PARTS_MOVED) {				cache = null;			}		}		else if (obj instanceof Taxa && (Taxa)obj ==taxa) {			if (code==MesquiteListener.NAMES_CHANGED || code==MesquiteListener.SELECTION_CHANGED || code==MesquiteListener.DATA_CHANGED) {			}			else if (code==MesquiteListener.PARTS_DELETED || code==MesquiteListener.PARTS_ADDED || code==MesquiteListener.PARTS_MOVED) {				cache = null;			}		}		super.changed(caller, obj, notification, commandRec);	}		/*.................................................................................................................*/	void setPanel(CommandRecord commandRec){		Frame f = containerOfModule();		if (f instanceof TableWindow){			if (showPanel.getValue()){				if (panel == null) {					panel = new CellDWPanel(this);					MesquiteModule mb = findEmployerWithDuty(DataWindowMaker.class);					if (mb != null && mb instanceof DataWindowMaker)						((DataWindowMaker)mb).requestCellColorer(this,"Do you want the cells to be colored to show whether or not images are present?", commandRec);				}								((TableWindow)f).addSidePanel(panel, DWPanel.width);				iPanel = (CellDWImagePanel)panel.getPanel();				iPanel.setData(data);				iPanel.setImageSource(imageSource);			}			else {				if (panel != null)					((TableWindow)f).removeSidePanel(panel);			}		}			}	/*.................................................................................................................*/   	public boolean hasDisplayModifications(){   		return false;   	}   	 public void employeeParametersChanged(MesquiteModule employee, MesquiteModule source, Notification notification, CommandRecord commandRec) {   	 	if (employee == imageSource){   	 		cache = null;   	 		if (table != null)   	 			table.repaintAll();   	 		parametersChanged(null, commandRec);   	 		focusInCell(previousChar, previousTax);   	 	}   	 	   	 }   	 int previousChar = -1;   	 int previousTax = -1;   	 	/*.................................................................................................................*/   	public void focusInCell(int ic, int it){   		if (data == null || iPanel == null)   			return;   		previousChar = ic;   		previousTax = it; //  Debugg.println("panel " + panel + " data " + data);   		panel.setCell(ic, it, data.getTaxa().getTaxonName(it), imageSource.getNumCellImages(data, ic, it, CommandRecord.nonscriptingRecord));		//iPanel.repaint();		//panel.repaint();   	}	/*.................................................................................................................*/    	 public String getName() {		return "Matrix Cell Images";   	 }	/*.................................................................................................................*/    	 public String getNameForMenuItem() {		return "*Indexed Images Present";   	 }	/*.................................................................................................................*/  	 public String getVersion() {		return null;   	 }   	 	public void panelGoAway(){		showPanel.setValue(false);		setPanel(CommandRecord.nonscriptingRecord);	}	/*.................................................................................................................*/  	 public String getExplanation() {		return "Installs a panel with images for a character matrix.";   	 }}class CellDWPanel extends DWPanel{	int ic = -1;	int it = -1;	String taxonName = null;	public CellDWPanel (CellImages pw){		super(pw);		setBackground(ColorDistribution.paleGoldenRod);	}	public DWImagePanel makePanel(){		return new CellDWImagePanel();	}	void setCell(int ic, int it, String name, int[] numImages){		if (ic == this.ic && it == this.it || numImages == null){			return;		}		this.ic = ic;		this.it = it;		this.numImagesVertical = numImages.length;		//scroll.setMaximumValue(numImages-1);		taxonName = name;				((CellDWImagePanel)getPanel()).showImages(ic, it, numImages);		repaint();		getPanel().repaint();			}	public String getTitleString(){		if (taxonName == null)			return "Images for cells of matrix";		return  "Character " + (ic+1) + " in taxon " + taxonName;	}}class CellDWImagePanel extends DWImagePanel{	CellImageSource source;	CharacterData data;	int currentIC = 0;	int currentIT = 0;		public CellDWImagePanel (){		super();	}	public void setData(CharacterData data){		this.data = data;	}	public void setImageSource(CellImageSource source){		this.source = source;	}	public void showImages(int ic, int it, int[] numImages){		if (source == null)			return;   		prepareMemory(numImages);   		   		currentIC = ic;   		currentIT = it;   		for(int i=0; i<numImages.length; i++) {   			location.setValue("");   			images[i][0] = source.getCellImage(i, data, ic, it, comment, location, CommandRecord.nonscriptingRecord);   			comments[i][0] = new StringInABox(comment.getValue(), font, getBounds().width-8);   			locations[i][0] = new StringInABox(location.getValue(), font, getBounds().width-8);   		}   			}	  	public void mouseDown (int modifiers, int clickCount, long when, int x, int y, MesquiteTool tool) {   		int im = findImage(y);   		if (clickCount>1 && source != null){   			source.showCloseupCellImage(im,  data, currentIC, currentIT, modifiers, CommandRecord.nonscriptingRecord);   		}   		   	}			}