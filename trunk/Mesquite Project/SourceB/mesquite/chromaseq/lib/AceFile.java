/* Mesquite.chromaseq source code.  Copyright 2005 D. Maddison, W. Maddison. Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.chromaseq.lib; import java.awt.*;import mesquite.lib.*;import mesquite.categ.lib.*;import mesquite.cont.lib.*;/* ======================================================================== */public class AceFile { 	public static final String ACENAMEREF = "aceFile";		public static final NameReference WHICHCONTIGREF = NameReference.getNameReference("whichContig");		NameReference qualityNameRef = NameReference.getNameReference("phredPhrapQuality");		int numContigs = 0;	int numReads = 0;		String aceFilePath = null;	String directoryPath = null;	String relativeAceFilePath = null;	String processedRelativeAceFilePath = null;	String fileName = null;	String baseName = null;	String longSequenceName = null;	boolean processPolymorphisms = false;	MesquiteModule ownerModule;	String aceFile=null;	StringBuffer remainingTags = new StringBuffer();	double polyThreshold = 0.5;	Contig[] contigs;	Read[] reads;	public static ColorRecord colorHighQuality, colorMediumQuality, colorLowQuality, colorInapplicable, colorChromNoSeq, colorAmbiguous;	public static ColorRecord colorTrimmable, colorTouched, colorPleaseRecheck, colorNoQuality;		static{	   		colorHighQuality = new ColorRecord(ColorDistribution.veryLightGreen, "Higher quality (50 or above; paler = better)");	  		colorMediumQuality = new ColorRecord(Color.green, "Medium quality (30 to 50; darker = worse)");	  		colorLowQuality = new ColorRecord(ColorDistribution.lightBlue, "Lower quality (20 to 30; darker = worse)");	  		colorInapplicable = new ColorRecord(ColorDistribution.straw, "Inapplicable or no data (Gaps)");	  		colorChromNoSeq = new ColorRecord(Color.pink, "No sequence retrieved, but chromatograms are available.");	  		colorAmbiguous = new ColorRecord(Color.darkGray, "Ambiguous coding");	  		colorTrimmable = new ColorRecord(Color.red, "To Be Trimmed");	  		colorTouched = new ColorRecord(Color.yellow, "Modified by hand");	  		colorPleaseRecheck = new ColorRecord(Color.magenta, "Please Recheck");	  		colorNoQuality = new ColorRecord(Color.gray, "Sequence present but no quality score");	}	/*.................................................................................................................*/	public  AceFile (String aceFilePath,  String processedAceFilePath,  String dataFilePath, MesquiteModule ownerModule, CommandRecord commandRec, boolean processPolymorphisms, double polyThreshold){//  Debugg.println("||| aceFilePath: " + aceFilePath);//  Debugg.println("|||    processedAceFilePath: " + processedAceFilePath);		if (StringUtil.blank(dataFilePath))			relativeAceFilePath = aceFilePath;		else			relativeAceFilePath = MesquiteFile.decomposePath(dataFilePath, aceFilePath);		if (StringUtil.blank(processedAceFilePath))			processedRelativeAceFilePath = relativeAceFilePath;		else if (StringUtil.blank(dataFilePath))			processedRelativeAceFilePath = processedAceFilePath;		else 			processedRelativeAceFilePath = MesquiteFile.decomposePath(dataFilePath, processedAceFilePath);		this.aceFilePath = aceFilePath;		this.ownerModule = ownerModule;		this.polyThreshold = polyThreshold;		this.processPolymorphisms = processPolymorphisms;		aceFile = MesquiteFile.getFileContentsAsString(aceFilePath);		directoryPath = MesquiteFile.getDirectoryPathFromFilePath(aceFilePath);		fileName = MesquiteFile.getFileNameFromFilePath(aceFilePath);		readAceFile(commandRec);	}	/*.................................................................................................................*/   	 public void setBaseName(String name){   	 	baseName = name;   	 }	/*.................................................................................................................*/   	 public void setLongSequenceName(String name){   	 	longSequenceName = name;   	 }	/*.................................................................................................................*/   	 public void readAceFile(CommandRecord commandRec){//MesquiteTimer timer;  long time=0;  long cumulTime=0;//timer = new MesquiteTimer();//timer.start();//		String baseName = fileName.substring(0,fileName.length()-4);  //this is the name of the sequence		Parser aceParser = new Parser(aceFile);		Parser lineParser = new Parser(); 		lineParser.setPunctuationString("");		String line;		aceParser.setPosition(0);//		int count = 1;		line = aceParser.getRawNextLine();  // get first line		int currentContig = -1;		int currentRead = -1;				while (aceParser.getPosition()<aceParser.getString().length() || !StringUtil.blank(line)) {			if (!StringUtil.blank(line)) {				lineParser.setString(line);				String firstToken = lineParser.getFirstToken();				 if (firstToken.equals("AS")) {					numContigs = MesquiteInteger.fromString(lineParser.getNextToken());  					numReads = MesquiteInteger.fromString(lineParser.getNextToken());  					contigs = new Contig[numContigs];					//reads = new Read[numReads];					currentContig = -1;					currentRead = -1;				}				else if (firstToken.equals("CO")) {  //contig					currentContig++;					String contigName = lineParser.getNextToken();  //contigName					String s = lineParser.getNextToken();					int numBases = MesquiteInteger.fromString(s);     //DRM: are padded positions included?				//	int numBases = 873;					int numReadsInContig = MesquiteInteger.fromString(lineParser.getNextToken());  					int numBaseSegmentsInContig = MesquiteInteger.fromString(lineParser.getNextToken());  					s = lineParser.getNextToken();  // U or C					if (MesquiteInteger.isCombinable(numBases)) {						String bases = aceParser.getNextDarkChars(numBases);// Debugg.println("bases: " + bases);						contigs[currentContig] = new Contig(contigName, numBases, numReadsInContig, numBaseSegmentsInContig, bases);					}				}				else if (firstToken.equals("BQ")) {  //baseQuality					contigs[currentContig].processBQ(aceParser);				}				else if (firstToken.equals("AF")) {    // first time details about reading frame have been encountered					String readName = lineParser.getNextToken();  					boolean complemented = "C".equalsIgnoreCase(lineParser.getNextToken());					int frameStart = MesquiteInteger.fromString(lineParser);					contigs[currentContig].processAF(readName, complemented,frameStart);					//now enter this into contigs				}				else if (firstToken.equals("BS")) {  					int firstBase = MesquiteInteger.fromString(lineParser.getNextToken());					int lastBase = MesquiteInteger.fromString(lineParser.getNextToken());					String name = lineParser.getNextToken();  					contigs[currentContig].processBS(name, firstBase, lastBase);				}				else if (firstToken.equals("RD")) {   //read					String readName = lineParser.getNextToken();  //readName					int numPaddedBases = MesquiteInteger.fromString(lineParser.getNextToken());     					int numWholeReadInfoItems = MesquiteInteger.fromString(lineParser.getNextToken());  					int numReadTags = MesquiteInteger.fromString(lineParser.getNextToken());  					currentRead = -1;					if (MesquiteInteger.isCombinable(numPaddedBases)) {						String bases = aceParser.getNextDarkChars(numPaddedBases);						contigs[currentContig].processRD(readName, numPaddedBases, numWholeReadInfoItems, numReadTags, bases);						currentRead = contigs[currentContig].getReadNumber(readName);					}				}				else if (firstToken.equals("QA")) {					int qualClipStart = MesquiteInteger.fromString(lineParser.getNextToken());     					int qualClipEnd = MesquiteInteger.fromString(lineParser.getNextToken());     					int alignClipStart = MesquiteInteger.fromString(lineParser.getNextToken());     					int alignClipEnd = MesquiteInteger.fromString(lineParser.getNextToken());     					if (currentRead>=0) {						contigs[currentContig].processQA(currentRead, qualClipStart, qualClipEnd, alignClipStart, alignClipEnd);					}				}				else if (firstToken.equals("DS")) {//time  += timer.timeSinceLast();					lineParser.getNextToken();  // skip over "CHROMAT_FILE:"					String chromFileName = lineParser.getNextToken();  					lineParser.getNextToken();  // skip over "PHD_FILE:"					String phdFile = lineParser.getNextToken();  					String DSRemainder = lineParser.getRemaining();					if (currentRead>=0)						contigs[currentContig].processDS(currentRead, chromFileName, directoryPath, phdFile, DSRemainder, processPolymorphisms, polyThreshold);//cumulTime  += timer.timeSinceLast();					//MesquiteModule windowServer = ownerModule.hireNamedEmployee (commandRec, WindowHolder.class, "#WindowBabysitter");					//ChromatogramWindow.showChromatogram(new MesquiteString(directoryPath), new MesquiteString(chromFileName), windowServer, ownerModule, commandRec);				}				else {					remainingTags.append(line+StringUtil.lineEnding());				}			}			//else			//	remainingTags.append(line + StringUtil.lineEnding());						line = aceParser.getRawNextLine();  // get next line		}  	 	for (int i = 0; i<numContigs; i++) {   	 		contigs[i].postReadProcessing();   	 	}		   	 }	/*.................................................................................................................*/   	 public String toString(CommandRecord commandRec, boolean usePolyBases){   	 	StringBuffer sb = new StringBuffer(1000);   	 	sb.append("AS " + numContigs + " " + numReads + StringUtil.lineEnding()+StringUtil.lineEnding());   	 	for (int i = 0; i<numContigs; i++) {   	 		sb.append(contigs[i].toString(usePolyBases)+StringUtil.lineEnding()+StringUtil.lineEnding());   	 		sb.append(contigs[i].extrasToString());   	 		sb.append(StringUtil.lineEnding());   	 	}   	 	sb.append(remainingTags.toString());   	 	return sb.toString();   	 }	/*.................................................................................................................*/   	 public String toFASTAString(CommandRecord commandRec, boolean usePolyBases, int qualThresholdForTrim){   	 	StringBuffer sb = new StringBuffer(1000);   	 	if (numContigs==1)   	 		sb.append(contigs[0].toFASTAString(usePolyBases, qualThresholdForTrim, longSequenceName)+StringUtil.lineEnding()+StringUtil.lineEnding());		else   	 	for (int i = 0; i<numContigs; i++) {   	 		String name = longSequenceName;   	 		if (i > 0)   	 			name +=" contig " +  Integer.toString(i+1);   	 		sb.append(contigs[i].toFASTAString(usePolyBases, qualThresholdForTrim, name)+StringUtil.lineEnding()+StringUtil.lineEnding());   	 	}   	 	return sb.toString();   	 }	/*.................................................................................................................*/   	 public int getNumContigs(){		return numContigs;	} 	/*.................................................................................................................*/   	   	public void setNameTranslation(String[][] fileNameTranslation){   	  	 	for (int i = 0; i<numContigs; i++) {   	   	 		for (int j=0; j<contigs[i].getNumReadsToShow(); j++){   	   	 			Read read = contigs[i].getRead(j);   	   	 			if (read!=null) {   	   	 				String s = read.getName();   	   	 				for (int k = 0; k<fileNameTranslation[0].length; k++)   	   	 					if (fileNameTranslation[0][k]!=null && fileNameTranslation[0][k].equalsIgnoreCase(s)) {   	   	 						read.setOriginalName(fileNameTranslation[1][k]);   	   	 				}//						fileNameTranslation[0][i] = newFileName;//						fileNameTranslation[1][i] = chromFileName;  	   	 			}   	   	 				    	   	 	}   	  	 	}  	}   	/*.................................................................................................................*/   	 public void createEmptyContig(int numReads){   		 numContigs = 1;   		contigs = new Contig[numContigs];   		contigs[0] = new Contig("contig", 0, numReads, 0, "");  //   		= new Contig(contigName, numBases, numReadsInContig, numBaseSegmentsInContig, bases);   	 }   	/*.................................................................................................................*/   	 public void addPhdFileAsRead(int currentRead, String directoryPath, String phdFileName, boolean processPolymorphisms, double polyThreshold){   		 if (numContigs>=1){   			 contigs[0].processAF("",false,0);   			 contigs[0].processDS(currentRead, null, directoryPath+MesquiteFile.fileSeparator, phdFileName, "", processPolymorphisms, polyThreshold);   		 	numReads++;   		 }   		    	 }	/*.................................................................................................................*/   	 public void importSequence(Taxa taxa, DNAData data, DNAData originalData, ContinuousData qualityData, boolean useExistingTaxonIfFound, NameReference aceRef, boolean usePolyBases, MesquiteInteger maxChar){//  Debugg.println("relativeAceFilePath: " + relativeAceFilePath);//  Debugg.println("   processedRelativeAceFilePath: " + processedRelativeAceFilePath);//  Debugg.println("   usePolyBases: " + usePolyBases);//		String sequenceName = longSequenceName;   	 	if (numContigs>1)	   	 	for (int i = 0; i<numContigs; i++) {  	   	 		String name = longSequenceName;	   	 		if (i > 0)	   	 			name += " contig " +  Integer.toString(i+1);	  	 		contigs[i].importSequence(taxa, i, data, originalData, qualityData, useExistingTaxonIfFound, processedRelativeAceFilePath, name,  aceRef, qualityNameRef, usePolyBases, maxChar);	   	 	}	   	 else	   	 	contigs[0].importSequence(taxa, 0, data,originalData, qualityData, useExistingTaxonIfFound,  processedRelativeAceFilePath, longSequenceName, aceRef, qualityNameRef, usePolyBases,maxChar);	}	/*.................................................................................................................*/   	 public void renameContigs(String baseName, boolean addFragName, String fragName){   	 	String s = baseName;   	 	if (addFragName)   	 		s+= "."+fragName;   	 	if (numContigs==1)   	 		contigs[0].setName(s);   	 	else  		for (int i = 0; i<numContigs; i++) {  	 		contigs[i].setName(s+(i+1));   	 	}   	 }	/*.................................................................................................................*/   	 public String contigListForLog(){   	 	StringBuffer sb = new StringBuffer(100);   	 	for (int i = 0; i<numContigs; i++) {  	 		if (numContigs>1)  	 			sb.append("   " + contigs[i].getName()+StringUtil.lineEnding());  	 		sb.append(contigs[i].getReadListForLog());   	 	}   	 	return sb.toString();   	 }	/*.................................................................................................................*/   	 public Contig getContig(int i){   	 	if (i>=0 && i<numContigs)  	 		return contigs[i];  	 	return null;   	 }	/*.................................................................................................................*/   	 public void unTrimQA(){   	 	for (int i = 0; i<numContigs; i++) {  	 		contigs[i].unTrimQA();   	 	}   	 }	/*.................................................................................................................*/   	 public void trimMixedEnds(int mixedEndThreshold, int mixedEndWindow, int qualThresholdForTrim){   	 	for (int i = 0; i<numContigs; i++) {  	 		contigs[i].trimMixedEnds(mixedEndThreshold, mixedEndWindow, qualThresholdForTrim);   	 	}   	 }	/*.................................................................................................................*/   	 public void processPolys(CommandRecord commandRec){//  Debugg.println("numContigs:  " + numContigs);//  Debugg.println("contigs.length:  " + contigs.length);   	 	for (int i = 0; i<numContigs; i++) {//  Debugg.println("i: " + i);  	 		contigs[i].processPolys(commandRec,polyThreshold);   	 	}   	 }	/*.................................................................................................................*/   	 public void setLowQualityToLowerCase(CommandRecord commandRec, int qualThreshold){   	 	for (int i = 0; i<numContigs; i++) {  	 		contigs[i].setLowQualityToLowerCase(qualThreshold);   	 	}   	 }   	 	/*.................................................................................................................*/   	public static Color getColorOfQuality(int quality){   		if (quality < 0 || !MesquiteInteger.isCombinable(quality))    			return colorNoQuality.getColor();    		else if (quality>=50)     			return MesquiteColorTable.getDefaultColor(50, (100-quality)/2, MesquiteColorTable.GREENSCALE);   		else if (quality>= 30)   			return MesquiteColorTable.getDefaultColor(50, (100-quality + 29)/2, MesquiteColorTable.GREENSCALE);   		else    			return MesquiteColorTable.getDefaultColor(50, (100-quality)/2, MesquiteColorTable.BLUESCALE);  	}   	/*.................................................................................................................*/   	public void dispose(){   		if (contigs!=null)   			for (int i = 0; i<numContigs; i++) {   				if (contigs[i]!=null)   					contigs[i].dispose();   				contigs[i] = null;   			}   		contigs=null;//  	 	for (int i = 0; i<numReads && i<reads.length; i++) {   	 		//reads[i] = null;//   	 	}   	 }						}