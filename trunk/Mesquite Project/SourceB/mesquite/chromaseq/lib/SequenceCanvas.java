/* Mesquite.chromaseq source code.  Copyright 2005 D. Maddison, W. Maddison. Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.chromaseq.lib; import java.awt.*;import java.awt.event.*;import mesquite.lib.*;import mesquite.categ.lib.*;public abstract class SequenceCanvas extends MousePanel implements KeyListener, FocusListener { 	protected MesquiteSequence sequence;//	int[] A,C,G,T;	protected int maxValue;	protected int centerBase, centerPixel;	protected boolean colorByQuality = true;//	int startOffset=0;	protected ChromatogramWindow window;	protected boolean[] selected;  // uses local read as index	protected SequencePanel sequencePanel;	protected int id = -1;  	/*..........................*/	public SequenceCanvas(SequencePanel sequencePanel, MesquiteSequence sequence, ChromatogramWindow window) {		super();		this.sequence = sequence;		setBackground(sequencePanel.getBackground());		this.sequencePanel = sequencePanel;		this.window = window;		String sequenceString = sequence.getSequence();		selected = new boolean[sequenceString.length()];   		for (int i=0;i<selected.length;i++) {			selected[i] = false;		}//		startOffset = window.getContig().getReadExcessAtStart();		reCalcCenterBase();		addKeyListener(this);   // we need to add these listeners for all SequenceCanvases, not just the editable ones, so that they can pick up arrow keys and the like 		addFocusListener(this); 	}	public abstract int getConsensusFromLocalIndex(int i);	public abstract int getLocalIndexFromConsensus(int i);	public abstract int matrixBaseFromSequenceBase(int i);	/*	public int getMatrixFromLocalIndex(int i){		return i;	}	/* Returns the number of padded bases that are missing from this sequence (i.e. are in the consensus but not in this sequence) in front of the given consensus position */ //	public abstract  int paddedMissingBeforeConsensus(int ic);	  	   	public boolean getEditable(){    		return true; //override if not editable   	}   	boolean hasFocus = false;    	public void focusLost(FocusEvent e){  		hasFocus = false;   		repaint();   	}   	public void focusGained(FocusEvent e){  		hasFocus = true;   		repaint();   	}   		public void keyReleased(KeyEvent e){  	}	public void keyTyped(KeyEvent e){		if (!getEditable()){			window.keyTyped(e);			return;		}		int mod = MesquiteEvent.getModifiers(e);		if (MesquiteEvent.optionKeyDown(mod) || MesquiteEvent.commandOrControlKeyDown(mod)){			window.keyTyped(e);			return;		}		int sel = oneSelected();		char k = e.getKeyChar();		if (hasFocus && sel>=0) {			enterState(sel, k);		}		else 			window.keyTyped(e);	}	public void keyPressed(KeyEvent e){		window.keyPressed(e);  //pass this off to the window so that it can deal with arrow keys, etc.	}	public void enterState(int ic, char k){	}	/*.................................................................................................................*	public int nextLowQuality(boolean right, int threshold) {		reCalcCenterBase();		for (int i=centerBase+1;i < sequence.getLength();i++) {			if (i>=0) {				int qual = sequence.getQualityOfBase(i); // using index of local sequence 				if (qual<threshold)					return getConsensusFromLocalIndex(i);			}		}		return -1;	}	/*.................................................................................................................*	public void goToNextLowQuality(boolean right) {		int nextLow = nextLowQuality(right, 30);		if (nextLow>=0 && nextLow<sequence.getLength())			window.scrollToConsensusBase(nextLow);	}	/*.................................................................................................................*/	public void setColorByQuality(boolean colorByQuality) {		this.colorByQuality = colorByQuality;	}	/*.................................................................................................................*/	public int oneSelected(){		int sel = -1;		if (hasFocus){			int count = 0;			for (int i=0; i<selected.length; i++) {				if (selected[i]) {					count++;					sel = i;				}			}			if (count!=1)				sel = -1;		}		return sel;	}	public abstract String getName();	/*...........................................................................*/	protected int getBaseCenterPixel(char c, Graphics g){		return getFontMetrics(g.getFont()).stringWidth(""+c) / 2;	}	/*...........................................................................*/	protected void reCalcCenterBase(){		centerBase = sequencePanel.centerBase;   //number of centered base		centerPixel = window.getCenterPixelFromCenterBase(centerBase);   //number of pixels over this scrolled base is	}	/*..........................*/	private int findLocalPosition(int x, MesquiteInteger consensusPos, boolean inBetween) {			int cwidth = getBounds().width;		reCalcCenterBase();		int leftPixel=centerPixel-cwidth/2;		int length = sequence.getLength();		int halfPeaks = window.getApproximateNumberOfPeaksVisible()/2;		int centerConsensusBase = centerBase-window.getContig().getReadExcessAtStart();		int firstConsensusBase = centerConsensusBase-halfPeaks;		int firstSequenceBase = getLocalIndexFromConsensus(firstConsensusBase);		int count = 0;		while (window.getFullPixelValueOfConsensusBase(getConsensusFromLocalIndex(firstSequenceBase))-leftPixel >0 && firstSequenceBase>0 && count++<200)				firstSequenceBase--; //correcting for error in numpeaksvisible for this sequence		firstSequenceBase--;		if (consensusPos != null)			consensusPos.setValue(MesquiteInteger.unassigned);				int offsetForInserted = 0;		for (int i=firstSequenceBase;i < length;i++) {			if (i>=0) {				int cons = getConsensusFromLocalIndex(i);				offsetForInserted += window.getSpaceInsertedBeforeConsensusBase(cons);				int pixels = window.getFullPixelValueOfConsensusBase(cons)-leftPixel + offsetForInserted;				int halfSpace = (int)(window.getAveragePeakDistance()/2.0);				int fullSpace = (int)(window.getAveragePeakDistance());				int pixelsNextCons = window.getFullPixelValueOfConsensusBase(cons+1)-leftPixel+ offsetForInserted + window.getSpaceInsertedBeforeConsensusBase(cons+1);				if (!inBetween){					if (x < pixels+halfSpace){							if (consensusPos != null)								consensusPos.setValue(cons);							return i;					}					else if (x< pixelsNextCons-halfSpace){ //within region of inserted bases; find which one and return						int insert = 0;						while (x >= pixels+halfSpace){							insert++;							pixels += fullSpace;						}							if (consensusPos != null)								consensusPos.setValue(MesquiteInteger.unassigned);						return insert + i;					}				}				else {					if (x < pixels){							if (consensusPos != null)								consensusPos.setValue(cons);							return i;					}					else if (x< pixelsNextCons){ //within region of inserted bases						int insert = 0;						while (x >= pixels){							insert++;							pixels += fullSpace;						}							if (consensusPos != null)								consensusPos.setValue(MesquiteInteger.unassigned);						return insert + i;					}				}			}		}		return MesquiteInteger.unassigned;	}	/*..........................*/	int topOfBase = 15;	int baseHeight = 16;	int notesHeight = 12;	/*..........................*/	public void paint(Graphics g) {			int sel = oneSelected();		Font curFont = g.getFont(); 		Font boldFont12 = new Font (curFont.getName(), Font.BOLD, 12);		Font plainFont10 = new Font (curFont.getName(), Font.PLAIN, 10);		FontMetrics fMB12 = getFontMetrics(boldFont12);		FontMetrics fMP10 = getFontMetrics(plainFont10);						int cheight = getBounds().height;		int cwidth = getBounds().width;		reCalcCenterBase();		int leftPixel=centerPixel-cwidth/2;		int halfPeaks = window.getApproximateNumberOfPeaksVisible()/2;		int centerConsensusBase = centerBase-window.getContig().getReadExcessAtStart();		int firstConsensusBase = centerConsensusBase-halfPeaks;		int lastConsensusBase = centerConsensusBase+halfPeaks;		int firstSequenceBase = getLocalIndexFromConsensus(firstConsensusBase);		int lastSequenceBase = getLocalIndexFromConsensus(lastConsensusBase);				String sequenceString = sequence.getSequence();		int count = 0;		while (window.getFullPixelValueOfConsensusBase(getConsensusFromLocalIndex(firstSequenceBase))-leftPixel >0 && firstSequenceBase>0 && count++<200)				firstSequenceBase--; //correcting for error in numpeaksvisible for this sequence		count = 0;		while (window.getFullPixelValueOfConsensusBase(getConsensusFromLocalIndex(lastSequenceBase))-leftPixel <cwidth && count++<200)				lastSequenceBase++; //correcting for error in numpeaksvisible for this sequence		firstSequenceBase--;		lastSequenceBase++;		//Drawing the top line		g.setColor(Color.lightGray);		g.drawLine(0,0,cwidth,0);		// Draw center gray line		g.setColor(Color.lightGray);		g.drawLine(cwidth/2,0,cwidth/2,cheight);				int pixels = 0;		int offsetForInserted = 0;		int prevPixels = 0;		int prevPixels2 = 0;		int prevPixelsUsed = 0;		int prevIC = 0;		int halfSpace = (int)(window.getAveragePeakDistance()/2.0);				// Now to color the bases ==========================		if (colorByQuality & getColorBaseBackground()) {			for (int i=firstSequenceBase;i < sequenceString.length() && (i< lastSequenceBase || lastSequenceBase<0);i++) {				if (i>=0){					int cons = getConsensusFromLocalIndex(i);					offsetForInserted +=  window.getSpaceInsertedBeforeConsensusBase(cons);					pixels = window.getFullPixelValueOfConsensusBase(cons)-leftPixel + offsetForInserted;					if (prevPixels == pixels){						pixels += window.getAveragePeakDistance()*(i-prevIC);					}					else {						prevPixels = pixels;						prevIC = i;					}					int pixels2 = pixels + (int)window.getAveragePeakDistance();										int nmid = halfSpace;						Color c = sequence.getQualityColorOfBase(i);					if (c != null){						g.setColor(c);						g.fillRect(pixels - nmid, topOfBase, pixels2 - pixels+1, baseHeight);					}				}			}		}		offsetForInserted = 0; 		//Now to draw a bar beneath the highlighted bases  ==========================		if (sequencePanel.getShowReadReadConflict())			for (int i=firstSequenceBase;i < sequenceString.length() && (i< lastSequenceBase || lastSequenceBase<0);i++) {				if (i>=0){					int cons = getConsensusFromLocalIndex(i);					Color c = sequence.getHighlightColor(i, cons);					offsetForInserted +=  window.getSpaceInsertedBeforeConsensusBase(cons);					pixels = window.getFullPixelValueOfConsensusBase(cons)-leftPixel + offsetForInserted;					if (prevPixels == pixels){						pixels += window.getAveragePeakDistance()*(i-prevIC);					}					else {						prevPixels = pixels;						prevIC = i;					}					int pixels2 = pixels + (int)window.getAveragePeakDistance();										int nmid = getBaseCenterPixel(sequenceString.charAt(i),g);										if (c != null){						g.setColor(c);						g.fillRect(pixels - nmid - 2, topOfBase+ baseHeight-1, pixels2 - pixels+1, 6);					}									}							}		//Now draw box around those bases that have source with relatively low quality  ==========================		if (sequencePanel.getShowLowerQualSourceConflictsWithHigherQualRead()) {			MesquiteBoolean higherReadConflicts = new MesquiteBoolean(false);			MesquiteBoolean muchHigherReadConflicts = new MesquiteBoolean(false);			for (int i=firstSequenceBase;i < sequenceString.length() && (i< lastSequenceBase || lastSequenceBase<0);i++) {				if (i>=0){					int cons = getConsensusFromLocalIndex(i);					if (sequence.sourceReadIsLowerQuality(cons, 10, higherReadConflicts, 20, muchHigherReadConflicts)) {						offsetForInserted +=  window.getSpaceInsertedBeforeConsensusBase(cons);						pixels = window.getFullPixelValueOfConsensusBase(cons)-leftPixel + offsetForInserted;						if (prevPixels == pixels){							pixels += window.getAveragePeakDistance()*(i-prevIC);						}						else {							prevPixels = pixels;							prevIC = i;						}						int nmid = halfSpace;						if (muchHigherReadConflicts.getValue()) {							g.setColor(Color.blue);							g.drawRect(pixels-nmid, topOfBase, nmid*2, baseHeight);							g.drawRect(pixels-nmid-1, topOfBase-1, nmid*2+2, baseHeight+2);						}						else {							g.setColor(Color.black);							g.drawRect(pixels-nmid, topOfBase, nmid*2, baseHeight);						}					}									}							}		}		offsetForInserted = 0;		g.setFont(boldFont12);				// Now to show the selection  ==========================		if (MesquiteWindow.Java2Davailable){			int firstSel = MesquiteInteger.unassigned;			ColorDistribution.setTransparentGraphics(g);					g.setColor(Color.gray);			int lastSel = MesquiteInteger.unassigned;			for (int i=firstSequenceBase;i < sequenceString.length() && (i< lastSequenceBase || lastSequenceBase<0);i++) {				if (i>=0){					int cons = getConsensusFromLocalIndex(i);					offsetForInserted +=  window.getSpaceInsertedBeforeConsensusBase(cons);					pixels = window.getFullPixelValueOfConsensusBase(cons)-leftPixel + offsetForInserted;					if (prevPixels == pixels){						pixels += window.getAveragePeakDistance()*(i-prevIC);					}					else {						prevPixels = pixels;						prevIC = i;					}					int nmid = halfSpace;					if (i< selected.length && selected[i]){						if (firstSel == MesquiteInteger.unassigned)							firstSel = pixels-nmid;						lastSel = pixels + nmid;					}					else if (firstSel != MesquiteInteger.unassigned){						g.fillRect(firstSel, 0, lastSel - firstSel, cheight);						firstSel = MesquiteInteger.unassigned;					}								}							}			if (firstSel != MesquiteInteger.unassigned){  //uncompleted selection; select to end 						g.fillRect(firstSel, 0, lastSel - firstSel, cheight);						firstSel = MesquiteInteger.unassigned;			}			ColorDistribution.setOpaqueGraphics(g);				}				offsetForInserted = 0;		prevPixels = 0;			// Now to draw the text for bases  ==========================		for (int i=firstSequenceBase;i < sequenceString.length() && (i< lastSequenceBase || lastSequenceBase<0);i++) {			if (i>=0){				int cons = getConsensusFromLocalIndex(i);				offsetForInserted +=  window.getSpaceInsertedBeforeConsensusBase(cons);				pixels = window.getFullPixelValueOfConsensusBase(cons)-leftPixel + offsetForInserted;				if (prevPixels == pixels){					pixels += window.getAveragePeakDistance()*(i-prevIC);				}				else {					prevPixels = pixels;					prevIC = i;				}				char c = sequenceString.charAt(i);				Color textC = window.getBaseColor(c);						g.setColor(textC);				g.setFont(boldFont12);				int nmid = fMB12.stringWidth(""+c) / 2;				if (sel== i && getEditable()){ //showing text edit box					g.setColor(Color.yellow);					int top = 2 + topOfBase;					int h = baseHeight;					g.drawRect(pixels-nmid-1, top -3, nmid*2 +3, h+2);					g.setColor(Color.blue);					g.drawRect(pixels-nmid-2, top -4, nmid*2 +5, h+4);					g.drawRect(pixels-nmid-3, top -5, nmid*2 +7, h+6);					g.setColor(Color.yellow);					g.drawRect(pixels-nmid-4, top -6, nmid*2 +9, h+8);					g.drawRect(pixels-nmid-5, top -7, nmid*2 +11, h+10);												}				g.drawString(""+c,pixels-nmid, topOfBase + 12);				g.setColor(Color.black);							if ((i+1) % 10 == 0 && pixels - nmid > 100) {					g.setColor(Color.gray);					g.setFont(plainFont10);					nmid = fMP10.stringWidth(String.valueOf(i+1)) / 2;					g.drawString(String.valueOf(i+1),pixels - nmid,notesHeight);				}						}					}		g.setFont(plainFont10);		GraphicsUtil.setFontSize(10,g);		g.setColor(Color.gray);		g.drawString(getName(),4,notesHeight);	}	 /*--------------------------------------*/   	public boolean getColorBaseBackground(){    		return true;    	}   	 /*--------@@@------------------------------*/   	 /*--------------------------------------*/	//uses index in consensus	public boolean setSelectedConsensus(int i, boolean sel, boolean repaint){		localFirstTouched = MesquiteInteger.unassigned;		localSecondTouched = MesquiteInteger.unassigned;		int ji = getLocalIndexFromConsensus(i);		if (selected != null && ji >= 0 && ji<selected.length) {			if (selected[ji] == sel)				return false;			selected[ji] = sel;  //selected uses index in consensus			if (repaint)				repaint();			return true;		}		return false;	}	public boolean getSelectedConsensus(int i){		int ji = getLocalIndexFromConsensus(i);		if (selected != null && ji >= 0 && ji<selected.length)							return selected[ji] ;		return false;	}	public void deselectAll(){		localFirstTouched = MesquiteInteger.unassigned;		localSecondTouched = MesquiteInteger.unassigned;		for (int i=0; i<selected.length; i++)			selected[i] = false; 	}  	 /*--------------------------------------*/	//this is consensus position	private void selectConsensusRange(int i, int k){		int iLoc = getLocalIndexFromConsensus(i);		int kLoc = getLocalIndexFromConsensus(k);		for (int j= iLoc; j<=kLoc; j++)			if (j >=0 && j< selected.length)				selected[j] = true;		for (int j = i; j<=k; j++)			sequencePanel.exportSelectConsensusPosition(j);	}	//this is local position	protected void selectLocalRange(int i, int k){		for (int j= i; j<=k; j++)			if (j >=0 && j< selected.length)				selected[j] = true;		for (int j = i; j<=k; j++){			if (!isInsertedBase(j))				sequencePanel.exportSelectConsensusPosition(getConsensusFromLocalIndex(j));		}			}	//this is local position	private void deselectLocalRange(int i, int k){		for (int j= i; j<=k; j++)			if (j >=0 && j< selected.length)				selected[j] = false;		for (int j = i; j<=k; j++){			if (!isInsertedBase(j))				sequencePanel.exportDeselectConsensusPosition(getConsensusFromLocalIndex(j));		}			}	private void deselectAllWithExport(){		for (int i=0;i<selected.length;i++)			selected[i] = false;		sequencePanel.exportDeselectAll();	}		public void selectAndFocusConsensusPosition(int ic){		window.setFirstTouchedOverall(window.getOverallBaseFromConsensusBase(ic));		deselectAllWithExport();		selectConsensusRange(ic, ic);		window.repaintPanels();	}	public void selectAndFocusLocalPosition(int ic){		window.setFirstTouchedOverall(window.getOverallBaseFromConsensusBase(ic));		localFirstTouched = ic;		deselectAllWithExport();		selectLocalRange(ic, ic);		window.repaintPanels();	}		boolean isInsertedBase(int iloc){			return getConsensusFromLocalIndex(iloc) == getConsensusFromLocalIndex(iloc-1);	}		int localFirstTouched = MesquiteInteger.unassigned;	int localSecondTouched = MesquiteInteger.unassigned;	int firstConsensusTouched = MesquiteInteger.unassigned;		/* to be used by subclasses to tell that panel touched */  	public void mouseDown (int modifiers, int clickCount, long when, int x, int y, MesquiteTool tool) {  		MesquiteInteger consensusPos = new MesquiteInteger();		ChromatogramTool chromTool = (ChromatogramTool)tool;		int iloc = findLocalPosition(x, consensusPos, chromTool.getIsInBetween());		int ic = consensusPos.getValue();		firstConsensusTouched = ic;						if (!tool.isArrowTool() && ((chromTool.getWorksOnEditableSequencePanel() && getEditable()) || (chromTool.getWorksOnOtherSequencePanels() && !getEditable()))){			((ChromatogramTool)tool).touched(ic, iloc, false, id, modifiers);			return;		}  		if (MesquiteEvent.shiftKeyDown(modifiers)){	   		if (MesquiteInteger.isCombinable(iloc)){	   			if (!MesquiteInteger.isCombinable(ic))	   				ic = getConsensusFromLocalIndex(iloc);	  			window.setSecondTouchedOverall(window.getOverallBaseFromConsensusBase(getConsensusFromLocalIndex(iloc)));	   			deselectAllWithExport();	  			localSecondTouched = iloc;	  			if (!MesquiteInteger.isCombinable(localFirstTouched))	  				localFirstTouched = getLocalIndexFromConsensus(window.getFirstTouchedConsensus());	   			if (MesquiteInteger.isCombinable(localFirstTouched)) {	   				if (localFirstTouched>iloc){		   				selectLocalRange(iloc, localFirstTouched);	   				}	   				else {		   				selectLocalRange(localFirstTouched, iloc);	   				}	  			}	  			else {		  			selectLocalRange(iloc, iloc);	  			}	   			window.repaintPanels();	  		} 		}  		else if (MesquiteEvent.commandOrControlKeyDown(modifiers)){	   		if (MesquiteInteger.isCombinable(iloc)){	  			selectLocalRange(iloc, iloc);	  			window.repaintPanels();	  		} 		} 		else {	   		if (MesquiteInteger.isCombinable(iloc)){				window.setFirstTouchedOverall(window.getOverallBaseFromConsensusBase( getConsensusFromLocalIndex(iloc)));	   			deselectAllWithExport();	  			selectLocalRange(iloc, iloc);	   			localFirstTouched = iloc;	   			if (clickCount>1)	   				window.scrollToConsensusBase(ic);	  			window.repaintPanels();	  			requestFocus();	  		} 		}	}   		public void mouseDrag (int modifiers, int x, int y, MesquiteTool tool) {  		ChromatogramTool chromTool = (ChromatogramTool)tool;		if (!tool.isArrowTool() && ((chromTool.getWorksOnEditableSequencePanel() && getEditable()) || (chromTool.getWorksOnOtherSequencePanels() && !getEditable()))){	 		MesquiteInteger consensusPos = new MesquiteInteger();			int iloc = findLocalPosition(x, consensusPos, ((ChromatogramTool)tool).getIsInBetween());			int ic = consensusPos.getValue();			((ChromatogramTool)tool).dragged(ic, iloc, false, id, modifiers);			return;		}  		MesquiteInteger consensusPos = new MesquiteInteger();		int iloc = findLocalPosition(x, consensusPos, ((ChromatogramTool)tool).getIsInBetween());		int ic = consensusPos.getValue();   		if (MesquiteInteger.isCombinable(ic)){  			if (!MesquiteInteger.isCombinable(localFirstTouched))  				localFirstTouched = getLocalIndexFromConsensus(window.getFirstTouchedConsensus());   			if (!MesquiteInteger.isCombinable(localSecondTouched))  				localSecondTouched = getLocalIndexFromConsensus(window.getSecondTouchedConsensus()); 			//deselectAll(); //this isn't correct behaviour!  If shift down should remember previously sleected pieces   			if (MesquiteInteger.isCombinable(localFirstTouched)) {				if (localFirstTouched>iloc){	   				if (MesquiteInteger.isCombinable(localSecondTouched) && localSecondTouched<localFirstTouched && iloc>localSecondTouched){ //retracting	   					deselectLocalRange(localSecondTouched+1, iloc);		   			}	   				else 	   					selectLocalRange(iloc, localFirstTouched);	  				}   				else {		    			if (MesquiteInteger.isCombinable(localSecondTouched) && localSecondTouched>localFirstTouched && iloc<localSecondTouched){ //retracting	   					deselectLocalRange(iloc+1, localSecondTouched);		   			}	   				else 	   					selectLocalRange(localFirstTouched, iloc);   				}  			}  			else {	  			selectLocalRange(iloc, iloc);  			}   			window.repaintPanels();	  		window.setSecondTouchedOverall(window.getOverallBaseFromConsensusBase( getConsensusFromLocalIndex(iloc)));	  		localSecondTouched = iloc;	 		}	}	/* to be used by subclasses to tell that panel touched */   	public void mouseUp(int modifiers, int x, int y, MesquiteTool tool) {   		ChromatogramTool chromTool = (ChromatogramTool)tool;		if (!tool.isArrowTool() && ((chromTool.getWorksOnEditableSequencePanel() && getEditable()) || (chromTool.getWorksOnOtherSequencePanels() && !getEditable()))){	 		MesquiteInteger consensusPos = new MesquiteInteger();			int iloc = findLocalPosition(x, consensusPos, ((ChromatogramTool)tool).getIsInBetween());			int ic = consensusPos.getValue();			((ChromatogramTool)tool).dropped(ic, iloc, false, id, modifiers);			return;		}	    if (MesquiteInteger.isCombinable(window.getFirstTouchedConsensus())){   			if (!MesquiteInteger.isCombinable(window.getSecondTouchedConsensus()))   				window.focusMatrixOn(window.getFirstTouchedConsensus(), MesquiteInteger.unassigned);   			else   				window.focusMatrixOn(window.getFirstTouchedConsensus(), window.getSecondTouchedConsensus());   		}	  	window.setSecondTouchedOverall(MesquiteInteger.unassigned);	  	localSecondTouched = MesquiteInteger.unassigned;	  	firstConsensusTouched = MesquiteInteger.unassigned; 	}   		/*...............................................................................................................*/	public void setCurrentCursor(int modifiers, int x, int y, ChromatogramTool tool) {		if (tool == null)			setCursor(getDisabledCursor());		else if ((tool.getWorksOnEditableSequencePanel() && getEditable()) || (tool.getWorksOnOtherSequencePanels() && !getEditable()))			setCursor(tool.getCursor());		else			setCursor(getDisabledCursor());	}	/*_________________________________________________*/   	public void mouseMoved(int modifiers, int x, int y, MesquiteTool tool) {   		if (tool == null)			return; 		MesquiteInteger consensusPos = new MesquiteInteger();		int iloc = findLocalPosition(x, consensusPos, ((ChromatogramTool)tool).getIsInBetween());		int ic = consensusPos.getValue();   		String s = getSequenceExplanation(ic);  		window.setExplanation( s);     }   	  	/*...............................................................................................................*/   	public abstract String getSequenceExplanation (int consensusBase);  	/*...............................................................................................................*/   	public void mouseExited(int modifiers, int x, int y, MesquiteTool tool) {		setCursor(Cursor.getDefaultCursor());	}	/*...............................................................................................................*/	public void mouseEntered(int modifiers, int x, int y, MesquiteTool tool) {		if (tool == null)			return;		setCurrentCursor(modifiers, x, y, (ChromatogramTool)tool);	}}