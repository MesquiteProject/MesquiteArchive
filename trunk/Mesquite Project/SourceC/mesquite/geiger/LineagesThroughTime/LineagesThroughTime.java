/* Mesquite source code.  Copyright 1997-2002 W. Maddison & D. Maddison. Version 0.992.  September 2002.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.geiger.LineagesThroughTime;import java.util.*;import java.awt.*;import mesquite.lib.*;import mesquite.lib.duties.*;/** ======================================================================== */public class LineagesThroughTime extends FileAssistantT {	public NumbersForNodes numForNodesTask;	public TreeSource treeSourceTask;	LineagesWindow lineagesWindow;	MesquiteString treeSourceName;	Taxa taxa;	MesquiteCommand tstC;	public DrawChart charterTask;	int numTrees = MesquiteInteger.unassigned;	MesquiteString numberTaskName;	MesquiteCommand nfntC;		/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName) { 		charterTask = (DrawChart)hireNamedEmployee(commandRec, DrawChart.class, "Histogram");		if (charterTask == null)			return sorry(commandRec, getName() + " couldn't start because no charting module was obtained.");		treeSourceTask= (TreeSource)hireEmployee(commandRec, TreeSource.class, "Source of trees (for Lineages through time)");		if (treeSourceTask == null)			return sorry(commandRec, getName() + " couldn't start because no source of trees obtained.");		tstC = makeCommand("setTreeSource",  (Commandable)this);		treeSourceTask.setHiringCommand(tstC); 		makeMenu("Lineages");		treeSourceName = new MesquiteString(treeSourceTask.getName());		if (numModulesAvailable(TreeSource.class)>1){			MesquiteSubmenuSpec mss = addSubmenu(null, "Tree Source", tstC, TreeSource.class);			mss.setSelected(treeSourceName);		}		addMenuItem("Number of Trees...", makeCommand("setNumTrees",  (Commandable)this));				taxa = getProject().chooseTaxa(containerOfModule(), "For which block of taxa do you want to show Lineages through time?",commandRec); 		numForNodesTask = (NumbersForNodes)hireEmployee(commandRec, NumbersForNodes.class, "Lineages through Time"); 		if (numForNodesTask == null) { 			return sorry(commandRec, getName() + " cannot start because no appropriate module to calculate values was obtained."); 		}		nfntC = makeCommand("setNumForNodes",  this);		 numForNodesTask.setHiringCommand(nfntC);		numberTaskName = new MesquiteString(numForNodesTask.getName());		if (numModulesAvailable(NumbersForNodes.class)>1){			MesquiteSubmenuSpec mss = addSubmenu(null, "Value at nodes", nfntC, NumbersForNodes.class); 			mss.setSelected(numberTaskName);		}		if (!commandRec.scripting()) {			if (taxa==null)				return sorry(commandRec, getName() + " couldn't start because no block of taxa found."); 						treeSourceTask.initialize(taxa, commandRec);			numTrees = treeSourceTask.getNumberOfTrees(taxa, commandRec); 			if (!MesquiteInteger.isCombinable(numTrees)) 				numTrees = MesquiteInteger.queryInteger(containerOfModule(), "Number of Trees", "Number of Trees", 100);	 		lineagesWindow= new LineagesWindow( this, treeSourceTask, commandRec);	 		setModuleWindow(lineagesWindow);	 		lineagesWindow.setVisible(true);	 		resetContainingMenuBar();			resetAllWindowsMenus();	 	} 		return true;  	 }	   	 public void employeeQuit(MesquiteModule m){  	 	if (m == charterTask)  	 		iQuit();  	 }	/*.................................................................................................................*/	/** passes which object is being disposed (from MesquiteListener interface)*/	public void disposing(Object obj){		if (obj instanceof Taxa && (Taxa)obj == taxa) {			iQuit();		}	}	/*.................................................................................................................*/	/** Query module as to whether conditions are such that it will have to quit soon -- e.g. if its taxa block has been doomed.  The tree window, data window, 	etc. override this to return true if their object is doomed. This is useful in case MesquiteListener disposing method is not called for an employer before one of its	employees discovers that it needs to quit.  If the employer is going to quit anyway,there is no use to use auto rehire for the quit employee.*/	public boolean quittingConditions(){		return (taxa.isDoomed());	}	public void endJob(){			if (taxa!=null)				taxa.removeListener(this);			super.endJob();	}	/*.................................................................................................................*/ 	public void employeeParametersChanged(MesquiteModule employee, MesquiteModule source, Notification notification, CommandRecord commandRec) {			if ((lineagesWindow!=null) ) 				lineagesWindow.renew(commandRec);	}	/*.................................................................................................................*/  	 public Snapshot getSnapshot(MesquiteFile file) {  	 	if (lineagesWindow ==null)  	 		return null;  	 	Snapshot fromWindow = lineagesWindow.getSnapshot(file);    	 	Snapshot temp = new Snapshot();  	 			temp.addLine("setTaxa " + getProject().getTaxaReference(taxa));		temp.addLine("setNumTrees " + numTrees);		temp.addLine("setTreeSource " , treeSourceTask);  	 	temp.addLine("setNumForNodes", numForNodesTask);  	  	temp.addLine("makeWindow");		temp.addLine("getWindow");		temp.addLine("tell It");		temp.incorporate(fromWindow, true);		temp.addLine("endTell");		temp.addLine("showWindow");  	 	return temp;  	 }	MesquiteInteger pos = new MesquiteInteger();	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {     	 	 if (checker.compare(this.getClass(), "Sets the taxa block", "[block reference, number, or name]", commandName, "setTaxa")){   	 		Taxa t = getProject().getTaxa(checker.getFile(), parser.getFirstToken(arguments));   	 		if (t!=null){	   	 		taxa = t;	   	 		return taxa;   	 		}      	 	 }      	 	 else if (checker.compare(this.getClass(), "Sets the module calculating the numbers for the nodes", "[name of module]", commandName, "setNumForNodes")) {        	 		NumbersForNodes temp=  (NumbersForNodes)replaceEmployee(commandRec, NumbersForNodes.class, arguments, "Value to calculate for Lineages through time", numForNodesTask);    	 			if (temp!=null) {    	 				numForNodesTask= temp;    			 		numForNodesTask.setHiringCommand(nfntC);    	 				numberTaskName.setValue(numForNodesTask.getName());    	 				if (!commandRec.scripting())    	 					lineagesWindow.renew(commandRec);    	 			}    	 			return numForNodesTask;        	 	}        	 	else if (checker.compare(this.getClass(), "Sets the total number of trees", "[number]", commandName, "setNumTrees")) {    	 		pos.setValue(0);    	 		int s = MesquiteInteger.fromString(arguments, pos);    	 		if (!MesquiteInteger.isCombinable(s))    	 			s = MesquiteInteger.queryInteger(containerOfModule(), "Number of Trees", "Number of Trees", numTrees);    	 		if (MesquiteInteger.isCombinable(s)) {	 			numTrees = s;				if (lineagesWindow!=null){		 			lineagesWindow.numTrees = s;	 				lineagesWindow.renew(commandRec);		 		}	 		}    		}    	 	else if (checker.compare(this.getClass(), "Makes but doesn't show the window", null, commandName, "makeWindow")) {	 		if (getModuleWindow()==null) {	 			lineagesWindow= new LineagesWindow( this, treeSourceTask, commandRec);	 			setModuleWindow(lineagesWindow);		 		resetContainingMenuBar();				resetAllWindowsMenus();	 		}	 		return lineagesWindow;    	 	}    	 	else if (checker.compare(this.getClass(), "Shows the window", null, commandName, "showWindow")) {	 		if (lineagesWindow!=null)	 			lineagesWindow.setVisible(true);	 		return lineagesWindow;    	 	}    	 	else if (checker.compare(this.getClass(), "Sets the tree source", "[name of module]", commandName, "setTreeSource")) {    	 		TreeSource temp=  (TreeSource)replaceEmployee(commandRec, TreeSource.class, arguments, "Source of trees", treeSourceTask);    	 		if (temp!= null) {    	 			treeSourceTask=temp;				treeSourceTask.setHiringCommand(tstC);				treeSourceName.setValue(treeSourceTask.getName());    	 			if (lineagesWindow!=null)    	 				lineagesWindow.setTreeSource(treeSourceTask, commandRec);    	 		}    	 		return treeSourceTask;    	 	}    	 	else    	 		return super.doCommand(commandName, arguments, commandRec, checker);    	 		return null;   	 }	/*.................................................................................................................*/    	 public String getName() {		return "Lineages Through Time";   	 }	/*.................................................................................................................*/ 	public void windowGoAway(MesquiteWindow whichWindow) {			whichWindow.hide();			whichWindow.dispose();			iQuit();	}	/*.................................................................................................................*/  	 public String getVersion() {		return null;   	 }   	 	/*.................................................................................................................*/ 	/** returns an explanation of what the module does.*/ 	public String getExplanation() { 		return "Displays a window showing plot of lineages through time averaged over many trees." ;   	 }}	/** ======================================================================== */class LineagesWindow extends ChartWindow implements ChartListener  {	TreeSource treeSourceTask;	LineagesThroughTime MTWmodule;	Taxa taxa;	int totalWidth;	int totalHeight;	MessagePanel messagePanel;	MesquiteChart chart;	int numTrees;	private NumberArray valuesX, valuesY, valuesZ;		public LineagesWindow (LineagesThroughTime ownerModule, TreeSource treeSourceTask, CommandRecord commandRec){		super(ownerModule, true); //infobar      		setWindowSize(500,400);		valuesX = new NumberArray(0);		valuesY = new NumberArray(0);  		MTWmodule=ownerModule;		taxa = ownerModule.taxa;		if (taxa==null) {			taxa = ownerModule.getProject().chooseTaxa(this, "For which block of taxa do you want to show a Multi-tree window?",commandRec);		}		setBackground(Color.white);				messagePanel=new MessagePanel(getColorScheme());		addToWindow(messagePanel);		messagePanel.setVisible(true);		chart=new MesquiteChart(ownerModule, 100, 0, ownerModule.charterTask.createCharter(this), commandRec);		chart.deassignChart();		chart.setUseAverage(true);		addToWindow(chart);		setChart(chart);		setTreeSource(treeSourceTask, commandRec);		sizeDisplays(false);		resetTitle();	}	/*.................................................................................................................*/	/** When called the window will determine its own title.  MesquiteWindows need	to be self-titling so that when things change (names of files, tree blocks, etc.)	they can reset their titles properly*/	public void resetTitle(){		setTitle("Lineages through time"); //TODO: what tree?	}	/*...................................................................................................................*/	public void pointMouseUp(MesquiteChart chart, int whichPoint, int x, int y, int modifiers, String message){	}	public void pointMouseDown(MesquiteChart chart, int whichPoint, MesquiteNumber valueX, MesquiteNumber valueY, int x, int y, int modifiers, String message){	}	/*.................................................................................................................*/		public void renew(CommandRecord commandRec) {			if (treeSourceTask!=null)				messagePanel.setMessage("Trees from " + treeSourceTask.getNameAndParameters());			doCalcs(commandRec);	}	/*.................................................................................................................*/		public void setTreeSource(TreeSource tsTask, CommandRecord commandRec) {		treeSourceTask = tsTask;		tsTask.initialize(taxa, commandRec);		numTrees = MTWmodule.numTrees;		if (!MesquiteInteger.isCombinable(MTWmodule.numTrees)){			numTrees = treeSourceTask.getNumberOfTrees(taxa, commandRec);			if (!MesquiteInteger.isCombinable(numTrees)) { 				numTrees = MesquiteInteger.queryInteger(this, "Number of Trees", "Number of Trees", numTrees);				if (!MesquiteInteger.isCombinable(numTrees)) 					numTrees = 100; 			} 			MTWmodule.numTrees = numTrees;		}		messagePanel.setMessage("Trees from " + treeSourceTask.getNameAndParameters());    	 	doCalcs(commandRec);	}	public void setWindowSize(int width, int height){		super.setWindowSize(width,height);		sizeDisplays(false);	}	/*.................................................................................................................*/	public void sizeDisplays(boolean hide){		if (messagePanel == null)			return;		totalWidth = getWidth()-16;		totalHeight = getHeight() - 16;		chart.setBounds(0,0, totalWidth, totalHeight);		chart.setLocation(32, 32);		chart.setChartSize(getWidth()-64, getHeight()-64);		messagePanel.setSize(totalWidth, 16);		messagePanel.setLocation(0, totalHeight);		messagePanel.repaint();	}	/*.................................................................................................................*/	NumberArray numbersAtNodes;	double getCladeValue(Tree tree, int node){				return numbersAtNodes.getDouble(node);	}	/*.................................................................................................................*/	public void doCalcs(CommandRecord commandRec){		int numTaxa = taxa.getNumTaxa();		valuesX.resetSize(numTrees*numTaxa);  		valuesY.resetSize(numTrees*numTaxa); 		valuesX.deassignArray();		valuesY.deassignArray();		numbersAtNodes = new NumberArray();		MesquiteInteger count = new MesquiteInteger(0); 		double[] splits = new double[numTaxa];		double[] stemAge = new double[numTaxa];		double[] nodeAge = new double[numTaxa];		double[] disp = new double[numTaxa];		double[] timeDisp;		int point = 0;		boolean doAverage = false;				for (int itree=0; itree<numTrees; itree++) {			Tree tree = treeSourceTask.getTree(taxa, itree, commandRec);			if (numbersAtNodes.getSize() < tree.getNumNodeSpaces()) 				numbersAtNodes = new NumberArray(tree.getNumNodeSpaces());			else				numbersAtNodes.deassignArray();						MTWmodule.numForNodesTask.calculateNumbers(tree, numbersAtNodes, null, commandRec);			commandRec.tick("Assessing lineage plot for tree " + itree);			if (tree!=null && tree.allLengthsAssigned(false)) {				double height = tree.tallestPathAboveNode(tree.getRoot());				if (height>0){					DoubleArray.zeroArray(splits);					DoubleArray.zeroArray(disp);					count.setValue(0);					getSplits(tree, tree.getRoot(), splits, 0.0, count);					count.setValue(0);					getStemNodeAges(tree, tree.getRoot(), stemAge, nodeAge, 0.0, count);					count.setValue(0);					getDisps(tree, tree.getRoot(), disp, count);					DoubleArray.sort(splits);					timeDisp=getTimeDispar(disp, splits, stemAge, nodeAge, numTaxa);					int c = 1;					for (int i = 0; i < splits.length; i++) {						if (splits[i]>0){							c++;							valuesX.setValue(point, splits[i]/height);							valuesY.setValue(point, timeDisp[i]);							point++;						}					}									}			}		}		recalcChart(commandRec);	}  	void getSplits(Tree tree, int node, double[] splits, double distanceFromRoot, MesquiteInteger count){  	 	if (tree.nodeIsInternal(node)) {   	 		if (tree.getRoot() != node) {  	 			distanceFromRoot += tree.getBranchLength(node);  	 			splits[count.getValue()] = distanceFromRoot;  	 			count.increment();  	 		}	  	 	for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter)) {	  			getSplits(tree, daughter, splits, distanceFromRoot, count);	   	 	} 		}  	}  	void getStemNodeAges(Tree tree, int node, double[] stemAge, double[] nodeAge, double distanceFromRoot, MesquiteInteger count){  	 	if (tree.nodeIsInternal(node)) {   	 		if (tree.getRoot() != node) {  	 			stemAge[count.getValue()] = distanceFromRoot;  	 			distanceFromRoot += tree.getBranchLength(node);  	 			nodeAge[count.getValue()] = distanceFromRoot;  	 			count.increment();  	 		}	  	 	for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter)) {	  			getStemNodeAges(tree, daughter, stemAge, nodeAge, distanceFromRoot, count);	   	 	} 		}  	}  	  	void getDisps(Tree tree, int node, double[] disp, MesquiteInteger count){  	 	if (tree.nodeIsInternal(node)) {   	 			disp[count.getValue()] = getCladeValue(tree, node);  	 			count.increment();  	 			  	 	for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter)) {	  			getDisps(tree, daughter, disp, count);	   	 	} 		}  	}  	  	/* get_time_dispar - creates disparity-through-time plot */  	/* returns array with average disparity of nodes alive at that time */  	double[] getTimeDispar(double[] disp, double[] splits, double[] stemAge, double[] nodeAge, int nspecies){  		  		double[] result;  		result=new double[nspecies];  		for(int i=0; i<nspecies; i++)  		{  			double sum=0;  			int count=0;  			for(int j=0; j<nspecies; j++)  				if(stemAge[j]<=splits[i] && nodeAge[j]>splits[i])  				{  					sum += disp[j];  					count++;  				}  			  			result[i]=sum/(double)count;  		}  		return(result);  	}  	/* End get_time_dispar */	/*.................................................................................................................*/	public void recalcChart(CommandRecord commandRec){		chart.deassignChart();		chart.getCharter().setShowNames(true);		chart.setXAxisName("Length from root");		chart.setYAxisName("Average disparity / log number of lineages");				MesquiteNumber resultX = new MesquiteNumber();		MesquiteNumber resultY = new MesquiteNumber();		for (int i=0; i<valuesX.getSize(); i++) {			valuesX.placeValue(i, resultX);			valuesY.placeValue(i, resultY);			chart.addPoint(resultX, resultY);		}		chart.munch(commandRec);	}	/*.................................................................................................................*/	public void windowResized() {	   	if (MesquiteWindow.checkDoomed(this))	   		return;		sizeDisplays(false);				MesquiteWindow.uncheckDoomed(this);	}}class LinPanel extends MesquitePanel {	LineagesWindow window;	public LinPanel (LineagesWindow window) {		this.window = window;		setBackground(Color.blue);	}}