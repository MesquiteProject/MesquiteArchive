/* Mesquite source code.  Copyright 1997-2005 W. Maddison and D. Maddison. Version 1.06, August 2005.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.categ.lib;import mesquite.lib.*;import mesquite.lib.characters.CharacterData;import mesquite.lib.characters.CharacterState;import mesquite.lib.duties.*;import mesquite.molec.lib.*;import java.util.*;/* ======================================================================== *//** A subclass of CharacterData for molecular data */public class MolecularData extends CategoricalData {	GenCodeModelSet genCodeModelSet =null;		/*vectors, one for each taxon, of 3D Points indicating inversions in sequence	x = site marking left boundary of inverted region	y = site marking right boundary of inverted region	z = not yet used	*/	protected Vector[] inversions;  	boolean trackInversions = false;		public MolecularData(CharMatrixManager manager, int numTaxa, int numChars, Taxa taxa){		super(manager, numTaxa, numChars, taxa);		saveChangeHistory = false;//turned off for now		inventUniqueIDs = false; //turned off for now		rememberDefaultOrder = false;	}	public void setInventUniqueIDs(boolean invent){		//inventUniqueIDs = invent; to prevent this from turning on for molecular	}	public boolean getInventUniqueIDs(){		return inventUniqueIDs;	}	public void setTrackInversions(boolean dt){		trackInversions = dt;	}	public boolean getTrackInversions(){		return trackInversions;	}	/*..........................................    ..................................................*/	public CategoricalState getNewState(){  		return (CategoricalState) new MolecularState();	}	public Vector getInversions(int it){		if (inversions == null || it >= inversions.length)			return null;		return inversions[it];	}	//true if inverted	public boolean isReverseDirectionAtSite(int ic, int it){		if (inversions == null || it >= inversions.length)			return false;		boolean inverted = false;		//look for inversions containing this site, starting at last one		int siteEquiv = ic;		for (int ip = inversions[it].size()-1; ip>=0; ip--){			Mesquite3DIntPoint p = (Mesquite3DIntPoint)inversions[it].elementAt(ip);			if (siteEquiv >= p.x && siteEquiv <= p.y){ //contains this site				inverted = !inverted;				siteEquiv = p.y - (siteEquiv-p.x);			}		}		return inverted;	}	//returns original (pre-inversion) position of current site ic, which may be within an inversion	public int findOriginalPositionOfInvertedSite(int ic, int it){		if (inversions == null || it >= inversions.length)			return ic;		//look for inversions containing this site, starting at last one		int siteEquiv = ic;		for (int ip = inversions[it].size()-1; ip>=0; ip--){			Mesquite3DIntPoint p = (Mesquite3DIntPoint)inversions[it].elementAt(ip);			if (siteEquiv >= p.x && siteEquiv <= p.y){ //contains this site				siteEquiv = p.y - (siteEquiv-p.x);			}		}		return siteEquiv;	}	//returns current (post-inversion) position of an original site ic	public int findInvertedPositionOfOriginalSite(int ic, int it){		if (inversions == null || it >= inversions.length)			return ic;		//look for inversions containing this site, starting at last one		int siteEquiv = ic;		for (int ip = 0; ip< inversions[it].size(); ip++){			Mesquite3DIntPoint p = (Mesquite3DIntPoint)inversions[it].elementAt(ip);			if (siteEquiv >= p.x && siteEquiv <= p.y){ //contains this site				siteEquiv = p.y - (siteEquiv-p.x);			}		}		return siteEquiv;	}	/*-----------------------------------------------------------*/	/**Adds num characters after position "starting".  If "starting" = -1, then inserts at start.  If "starting" >	number of characters, adds to end.  Any linked CharacterDatas are	to be adjusted separately.  Returns true iff successful.*/	public boolean addParts(int starting, int num){		//adding characters; deal with inversions		if (inversions != null){			for (int it = 0; it<inversions.length && it< getNumTaxa(); it++){				for (int ip = 0; ip< inversions[it].size(); ip++){					Mesquite3DIntPoint p = (Mesquite3DIntPoint)inversions[it].elementAt(ip);					if (starting < p.x) //added before x; need to push to right						p.x += num;					if (starting < p.y)//added before y; need to push to right						p.y += num;				}			}		}		return super.addParts(starting, num);	}	/*-----------------------------------------------------------*/	/** deletes num characters from (and including) position "starting"; returns true iff successful.  Should be overridden by particular subclasses, but this called via super so it can clean up.*/	public boolean deleteParts(int starting, int num){		//deleting characters; deal with inversions		if (inversions != null){			for (int it = 0; it<inversions.length && it< getNumTaxa(); it++){				for (int ip = 0; ip< inversions[it].size(); ip++){					Mesquite3DIntPoint p = (Mesquite3DIntPoint)inversions[it].elementAt(ip);					if (starting <= p.x){//deletion will affect point						if (p.x < starting+num) //point is being deleted also							p.x = starting;  //snap left edge of flip to right margin of deleted area						else							p.x -= num; //push to left					}					if (starting <= p.y){//deletion will affect point						if (p.y < starting+num) //point is being deleted also							p.y = starting-1;   //snap right edge of flip to left margin of deleted area-1						else							p.y -= num; //push to left					}				}			}		}		return super.deleteParts(starting, num);	}	private int newPosAfterMove(int orig, int starting, int num, int justAfter){			if (starting < justAfter){ //moving forward				if (orig > starting){					if (orig <= starting + num) //will be moved forward						orig = orig + (justAfter-starting) - num;					else if (orig < justAfter) //in chunk shifted left because of move						orig -= num;				}			}			else if (orig > justAfter){				if (orig < starting + num) //will be moved backward					orig = orig + (starting-justAfter);				else if (orig < starting)					orig+= num;			}			return orig;	}	/*-----------------------------------------------------------*/	/**Moves num characters from position "first" to just after position "justAfter"; returns true iff successful.*/	public boolean moveParts(int starting, int num, int justAfter){		//moving characters; deal with inversions		if (inversions != null){			for (int it = 0; it<inversions.length && it< getNumTaxa(); it++){				for (int ip = 0; ip< inversions[it].size(); ip++){					Mesquite3DIntPoint p = (Mesquite3DIntPoint)inversions[it].elementAt(ip);					p.x = newPosAfterMove(p.x, starting, num, justAfter);					p.y = newPosAfterMove(p.y, starting, num, justAfter);				}			}		}		return super.moveParts(starting, num, justAfter);	}	/*-----------------------------------------------------------*/	/**Swaps characters first and second.*/	public boolean swapParts(int first, int second){		//swapping characters; deal with inversions		if (inversions != null){			MesquiteMessage.warnProgrammer("Swapping characters and strand inversions not yet fully supported");		}		return super.swapParts(first, second);	}	/*.................................................................................................................*/	protected CharacterState moveOne(int i, int distance, int it, CharacterState cs,  MesquiteBoolean dataChanged){		//moving contents of cells; deal with inversions		if (inversions != null && it < inversions.length){				for (int ip = 0; ip< inversions[it].size(); ip++){					Mesquite3DIntPoint p = (Mesquite3DIntPoint)inversions[it].elementAt(ip);					if (p.x == i) //this point being moved						p.x += distance;					if (p.y == i) //sister point being moved						p.y += distance;				}		}		return super.moveOne(i, distance, it, cs, dataChanged);	}	/*-----------------------------------------------------------*/	/**Adds num taxa after position "starting"; returns true iff successful.  Assumes details already handled in subclasses, and numTaxa reset there.*/	public boolean addTaxa(int starting, int num){		//adding taxa; deal with inversions		if (inversions != null && num >0){			if (starting<0) 				starting = -1;			if (starting>inversions.length) 				starting = inversions.length-1;			int newNumParts = inversions.length+num;			Vector[] newValues = new Vector[newNumParts];			for (int i=0; i<= starting; i++) 				newValues[i] = inversions[i];			for (int i=0; i<num ; i++) 				newValues[starting + i + 1] = null;			for (int i=0; i<inversions.length-starting-1; i++)				newValues[i +starting+num+1] = inversions[starting + i+1];			inversions = newValues;		}		return super.addTaxa(starting, num);	}	/*-----------------------------------------------------------*/	/**Deletes num taxa from position "starting"; returns true iff successful.  Assumes details already handled in subclasses, and numTaxa reset there.*/	public boolean deleteTaxa(int starting, int num){		//deleting taxa; deal with inversions		if (inversions != null && num> 0){			if (num+starting>inversions.length)				num = inversions.length-starting;			int newNumParts = inversions.length-num;			Vector[] newValues = new Vector[newNumParts];			for (int i=0; i<starting; i++)				newValues[i] = inversions[i];			for (int i=starting+num; i<inversions.length; i++)				newValues[i-num ] = inversions[i];			inversions = newValues;		}		return super.deleteTaxa(starting, num);	}	/**moves num taxa from position "starting" to just after position "justAfter"; returns true iff successful.*/	public boolean moveTaxa(int starting, int num, int justAfter){		//moving taxa; deal with inversions		if (inversions != null && num>0 && starting >=0 && starting <= inversions.length){			Vector[] newValues = new Vector [inversions.length];						if (starting>justAfter){				int count =0;				for (int i=0; i<=justAfter; i++)					newValues[count++]=inversions[i];								for (int i=starting; i<=starting+num-1; i++)					newValues[count++]=inversions[i];				for (int i=justAfter+1; i<=starting-1; i++)					newValues[count++]=inversions[i];				for (int i=starting+num; i<inversions.length; i++)					newValues[count++]=inversions[i];			}			else {				int count =0;				for (int i=0; i<=starting-1; i++)					newValues[count++]=inversions[i];								for (int i=starting+num; i<=justAfter; i++)					newValues[count++]=inversions[i];				for (int i=starting; i<=starting+num-1; i++)					newValues[count++]=inversions[i];				for (int i=justAfter+1; i<inversions.length; i++)					newValues[count++]=inversions[i];			}			for (int i=0; i<inversions.length; i++)				inversions[i]=newValues[i];			inversions = newValues;		}		return super.moveTaxa(starting, num, justAfter);	}   	/** trades the states of character ic and ic2 in taxon it.  Used for reversing sequences (for example).*/	protected void tradeStatesBetweenCharactersInternal(int ic, int ic2, int it, boolean adjustCellLinked, boolean adjustDirections){		//trading states; deal with inversions 		super.tradeStatesBetweenCharactersInternal(ic, ic2, it, adjustCellLinked, adjustDirections);		if (adjustDirections && trackInversions)			MesquiteMessage.warnProgrammer("tradeStatesBetweenCharactersInternal does not yet handle direction tracking!"); //deal with inversions	}	/*..........................................  CategoricalData  ..................................................*/	/**Reverses the data from character icStart to icEnd in taxon it. */	public void reverse(int icStart, int icEnd, int it, boolean reverseTerminalGaps, boolean adjustCellLinked){		//reversing; deal with inversions		if (trackInversions){			if (inversions == null){				inversions = new Vector[numTaxa];				for (int itt = 0; itt<numTaxa; itt++)					inversions[itt] = new Vector();			}			//Wayne: should see if there is a matching element and simply flip it!			inversions[it].addElement(new Mesquite3DIntPoint(icStart, icEnd, 0));		}		super.reverse(icStart, icEnd, it, reverseTerminalGaps, adjustCellLinked);	}	/*..........................................    ..................................................*/   	/** returns the genetic code model of character ic in taxon it*/   	public GenCodeModel getGenCodeModel(int ic){		if (genCodeModelSet==null)			genCodeModelSet = (GenCodeModelSet)getCurrentSpecsSet(GenCodeModelSet.class);		if (genCodeModelSet != null && ic<genCodeModelSet.getNumberOfParts() && ic>=0)			return (GenCodeModel)genCodeModelSet.getModel(ic);		return null;   	}   	/*..........................................    ..................................................*/   	/** returns the genetic code of character ic in taxon it*/   	public GeneticCode getGeneticCode(int ic){		if (genCodeModelSet==null)			genCodeModelSet = (GenCodeModelSet)getCurrentSpecsSet(GenCodeModelSet.class);		if (genCodeModelSet != null && ic<genCodeModelSet.getNumberOfParts() && ic>=0) {			GenCodeModel genCodeModel=  (GenCodeModel)genCodeModelSet.getModel(ic);			if (genCodeModel != null)				return genCodeModel.getGeneticCode();		}		return null;   	}	public boolean stripRightTerminalGaps(boolean notify){		int ic = getNumChars();		for (ic = getNumChars()-1; ic>=0; ic--){			if (!entirelyInapplicable(ic))				break;		}		if (ic< getNumChars()) {			deleteCharacters(ic+1, getNumChars()-ic, notify);			return true;		}		return false;	}	public boolean stripLeftTerminalGaps(boolean notify){		int ic = -1;		for (ic = 0; ic<getNumChars(); ic++){			if (!entirelyInapplicable(ic))				break;		}		if (ic>=0) {			deleteCharacters(0, ic, notify);			return true;		}		return false;	}	public boolean removeCharactersThatAreEntirelyGaps(boolean notify){		boolean removedSome = false;		int ic = getNumChars();		for (ic = getNumChars()-1; ic>=0; ic--){			if (entirelyInapplicable(ic)) {				deleteCharacters(ic, 1, notify);				removedSome=true;			}		}		return removedSome;	}}