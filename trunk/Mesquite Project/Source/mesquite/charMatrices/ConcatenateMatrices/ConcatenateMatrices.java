/* Mesquite source code.  Copyright 1997-2006 W. Maddison and D. Maddison.Version 1.11, June 2006.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.charMatrices.ConcatenateMatrices; import java.util.*;import java.awt.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;/* ======================================================================== */public class ConcatenateMatrices extends DataUtility { 	CharacterData data;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName){		return true;	}	/*.................................................................................................................*/	/** returns whether this module is requesting to appear as a primary choice */	public boolean requestPrimaryChoice(){		return true;  	}	/*.................................................................................................................*/	public boolean isSubstantive(){		return true;	}	/*.................................................................................................................*/	public boolean isPrerelease(){		return false;	}	/** Called to operate on the data in all cells.  Returns true if data altered*/	public boolean operateOnData(CharacterData data){ 		this.data = data;		CharacterData oData =getProject().getDifferentButCompatibleMatrix(data, true,  "Sorry, there are no other compatible data matrices available for concatenation.  If the other matrix is in another file, open the file as a linked file before attempting to concatenate.", "Concatenate which matrix?", true);		//modified v. 1.05 to allow matrix of a subclass to be merged into a matrix (e.g. DNA into categorical).		//modivied v. 1.2 to allow enlargment of taxa block from new taxa in concatenated matrix		if (oData==null)			return false;		if (oData.isLinked(data) || data.isLinked(oData)) {			discreetAlert( "Sorry, those two matrices cannot be concatenated because they are linked");			return false;		}		if (!oData.getTaxa().equals(data.getTaxa(), true, true)){			Taxa oTaxa = oData.getTaxa();			Taxa taxa = data.getTaxa();			boolean extra = false;			for (int oit = 0; oit<oTaxa.getNumTaxa() && !extra; oit++)				if (taxa.findEquivalentTaxon(oTaxa, oit)<0)					extra = true;			//different taxa block, with different names.  Offer to add names			if (extra){				if (AlertDialog.query(containerOfModule(), "Import taxa from other matrix?", "The matrix you are concatenating to this one is based on a different block of taxa, and includes taxa not in this matrix.  Do you want to add these taxa to this matrix before concatenating?")){					String names = "";					for (int oit = 0; oit<oTaxa.getNumTaxa(); oit++){						if (taxa.findEquivalentTaxon(oTaxa, oit)<0){							taxa.addTaxa(taxa.getNumTaxa(), 1, true);							taxa.equalizeTaxon(oTaxa, oit, taxa.getNumTaxa()-1);							names += taxa.getTaxonName(taxa.getNumTaxa()-1) + "\n";													}					}					if (!StringUtil.blank(names))						logln("Added to taxa block were:\n" + names);				}			}		}		int origNumChars = data.getNumChars();		data.addParts(data.getNumChars()+1, oData.getNumChars());		data.addInLinked(data.getNumChars()+1, oData.getNumChars(), true);		CharacterState cs = null;		for (int ic = 0; ic<oData.getNumChars(); ic++){			CommandRecord.tick("Moving character " + (ic+1) + " in concatenation");			data.equalizeCharacter(oData, ic, ic+origNumChars);		}		data.notifyListeners(this, new Notification(MesquiteListener.PARTS_ADDED, new int[] {origNumChars, oData.getNumChars()}));		return true;	}	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot temp = new Snapshot();		return temp;	}	/*.................................................................................................................*/	public String getName() {		return "Concatenate Other Matrix";	}	/*.................................................................................................................*/	public String getExplanation() {		return "Concatenates matrix onto one in data editor.  Assumptions like weights and character models are NOT transferred.  For categorical data, state names are not included.  For continuous data, new items may need to be created to accommodate differences in items between the matrices.";	}}