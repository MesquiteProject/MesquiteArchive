/* Mesquite module ~~ Copyright 1997-2001 W. & D. Maddison*/package mesquite.diverse.MatricesAttachedToTree;/*~~  */import java.applet.*;import java.util.*;import java.awt.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;/** ======================================================================== *//* */public class MatricesAttachedToTree extends CharMatrixSource {	int currentChar=0;	Taxa taxa=null;	MCharactersDistribution data;	Object condition;	Tree lastTree;	TreeSource treeTask;	int lastMatrixNumber =0;	/*.................................................................................................................*/	/** condition passed to this module must be subclass of CharacterState */	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName) { 		if (condition!=null && condition instanceof Class) {						this.condition = condition;	 	} 		treeTask = (TreeSource)hireEmployee(commandRec, TreeSource.class, "Source of tree from which to seek attached matrices"); 		if (treeTask == null)  { 			return sorry(commandRec, getName() + " could not be started because no tree was found from which to seek attached matrices"); 		} 		return true;  	 }	/*.................................................................................................................*/	/*.................................................................................................................*/	/** Generated by an employee who quit.  The MesquiteModule should act accordingly. */ 	public void employeeQuit(MesquiteModule employee) { 		if (employee == treeTask) 			iQuit();	}	/*.................................................................................................................*/  	 public Snapshot getSnapshot(MesquiteFile file) {   	 	Snapshot temp = new Snapshot();  	 	//temp.addLine("setDataSet " + getProject().getCharMatrixReference(data));  	 	return temp;  	 }	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {    	 	if (checker.compare(this.getClass(), "Sets which stored data matrix to use", "[matrix reference]", commandName, "setDataSet")) {    	 		//remember which of several attached to use???    	 	}    	 	else    	 		return super.doCommand(commandName, arguments, commandRec, checker);		return null;   	 }   	/** Called to provoke any necessary initialization.  This helps prevent the module's intialization queries to the user from   	happening at inopportune times (e.g., while a long chart calculation is in mid-progress)*/   	public void initialize(Taxa taxa, CommandRecord commandRec){		treeTask.initialize(taxa, commandRec);   	}   		public boolean checkMatrix(CommandRecord commandRec, Tree tree) {   		if (tree == null)   			return false;  		if (data==null || data.getTaxa() != tree.getTaxa() || tree !=lastTree) {			if (tree instanceof MesquiteTree){				lastTree = tree;			 	MesquiteTree mTree = ((MesquiteTree)lastTree);			 	data = (MCharactersDistribution)mTree.getAttachedSensitive(MCharactersDistribution.class, 0); //should use condition for data class			 	if (data == null)			 		MesquiteMessage.warnProgrammer("Error in MatricesAttachedToTree: no matrix attached to tree");			}			   			   			if (data == null)   				return false;   			return true;   		}   		else   			return true;   	} 	public boolean usesTree()  { 		return true; 	}	/*.................................................................................................................*/   	private MCharactersDistribution getM(Tree tree, CommandRecord commandRec) {   		if (checkMatrix(commandRec, tree)){	   		return data;   		}   		else   			return null;   	}   	/** gets the indicated matrix.*/	/*.................................................................................................................*/  	public MCharactersDistribution getCurrentMatrix(Taxa taxa, CommandRecord commandRec){  Debugg.println("getMatrix by tree");   		return getM(treeTask.getTree(taxa, lastMatrixNumber, commandRec), commandRec);   	}	/*.................................................................................................................*/  	public MCharactersDistribution getMatrix(Taxa taxa, int im, CommandRecord commandRec){  Debugg.println("getMatrix by taxa");		lastMatrixNumber = im;   		return getM(treeTask.getTree(taxa, im, commandRec), commandRec);   	}	/*.................................................................................................................*/   	public int getNumberOfMatrices(Tree tree, CommandRecord commandRec) {   		if (checkMatrix(commandRec, tree))   		   	return 1;   		else   			return 0;   	}	/*.................................................................................................................*/   	public int getNumberOfMatrices(Taxa taxa, CommandRecord commandRec) {   		return treeTask.getNumberOfTrees(taxa, commandRec);   	}   	/*.................................................................................................................*/   	public int getNumberCurrentMatrix() {   		return lastMatrixNumber;   	}	/*.................................................................................................................*/   	/** returns the name of character ic*/   	public String getMatrixName(Tree tree, int ic, CommandRecord commandRec){   		if (checkMatrix(commandRec, tree)) {	   		return "Matrix attached to tree " + tree.getName();     		}   		return null;   	}	/*.................................................................................................................*/   	/** returns the name of character ic*/   	public String getMatrixName(Taxa taxa, int ic, CommandRecord commandRec){	   		return "Matrix attached to tree ";     	}	/*.................................................................................................................*    	private  int getNumberOfMatrices(Taxa taxa){    		    	}	CharacterPartition colorSet;	/*.................................................................................................................*   	public void prepareItemColors(Taxa taxa, CommandRecord commandRec){		if (taxa==null || data == null || data.getTaxa()!=taxa)			colorSet=null;		else			colorSet = (CharacterPartition)data.getCurrentSpecsSet(CharacterPartition.class);    	}   	public Color getItemColor(Taxa taxa, int ic, CommandRecord commandRec){   		if (colorSet==null || taxa == null)   			return null;		CharactersGroup mi = (CharactersGroup)colorSet.getProperty(ic);		if (mi!=null && mi.getColor()!=null) {			return mi.getColor();		}		return null;   	}	/*.................................................................................................................*/    	 public String getName() {		return "Matrices attached to trees";     	 }	/*.................................................................................................................*/  	 public String getVersion() {		return null;   	 }   	 	/*.................................................................................................................*/   	  	/** returns an explanation of what the module does.*/ 	public String getExplanation() { 		return "Supplies matrices that are attached to trees." ;   	 }	/*.................................................................................................................*/ 	/** returns current parameters, for logging etc..* 	public String getParameters() {		String s = "Characters stored in: " + getProject().getName();		if (data!=null)			s +=  " (current matrix: " + data.getName() + ")";		return s;   	 }   	 */   	 }