package mesquite.align.lib;

import mesquite.align.lib.*;
import mesquite.categ.lib.*;
import mesquite.lib.*;
import mesquite.lib.characters.*;
import mesquite.lib.duties.*;

/* TODO: 
 *   have it so the reference sequence can be chosen
 *   report pairwise alignment parameters
 *   snapshot, etc.
 */

public abstract class AlignScoreForTaxonGen extends NumberForTaxon {
	protected MatrixSourceCoord matrixSourceTask;
	protected Taxa currentTaxa = null;
	protected MCharactersDistribution observedStates =null;
	protected PairwiseAligner aligner;
	protected int alphabetLength;
	 
	/*.................................................................................................................*/
	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName) {
 		matrixSourceTask = (MatrixSourceCoord)hireEmployee(commandRec, MatrixSourceCoord.class, "Source of character matrix (for number of stops)"); 
 		if (matrixSourceTask==null)
 			return sorry(commandRec, getName() + " couldn't start because no source of character matrices was obtained.");
/*
 		pairwiseTask = (TwoSequenceAligner)hireEmployee(commandRec, TwoSequenceAligner.class, "Pairwise Aligner");
		if (pairwiseTask == null)
			return sorry(commandRec, getName() + " couldn't start because no pairwise aligner obtained.");
*/		return true;
  	 }
  	 
	/*.................................................................................................................*/
	/** Generated by an employee who quit.  The MesquiteModule should act accordingly. */
 	public void employeeQuit(MesquiteModule employee) {
 		if (employee == matrixSourceTask)  // character source quit and none rehired automatically
 			iQuit();
	}
	/*.................................................................................................................*/
 	/** Override if one wishes to modify the alignment costs away from the default. */
 	 	public int[][] modifyAlignmentCosts(int[][] defaultSubs) {
   		return defaultSubs;
	}
	/*.................................................................................................................*/
	public void initAligner() {
  		MesquiteInteger gapOpen = new MesquiteInteger();
   		MesquiteInteger gapExtend = new MesquiteInteger();
  		int[][] subs = AlignUtil.getDefaultCosts(gapOpen, gapExtend, alphabetLength);  
  		subs = modifyAlignmentCosts(subs);
   		aligner = new PairwiseAligner(false,subs,gapOpen.getValue(), gapExtend.getValue(), alphabetLength);
   		aligner.setUseLowMem(false);
	}
	/*.................................................................................................................*/
	/** returns whether this module is requesting to appear as a primary choice */
   	public boolean requestPrimaryChoice(){
   		return false;  
   	}

   	/** Called to provoke any necessary initialization.  This helps prevent the module's intialization queries to the user from
   	happening at inopportune times (e.g., while a long chart calculation is in mid-progress)*/
   	public void initialize(Taxa taxa, CommandRecord commandRec){
   		currentTaxa = taxa;
   		matrixSourceTask.initialize(currentTaxa, commandRec);
   		
   	}

	public void calculateNumber(Taxon taxon, MesquiteNumber result, MesquiteString resultString, CommandRecord commandRec){
		Debugg.print("*");
		if (result==null)
			return;
		result.setToUnassigned();
		Taxa taxa = taxon.getTaxa();
		int it = taxa.whichTaxonNumber(taxon);
		if (taxa != currentTaxa || observedStates == null ) {
			observedStates = matrixSourceTask.getCurrentMatrix(taxa, commandRec);
			currentTaxa = taxa;
		}
		if (observedStates==null)
			return;
		DNAData data = (DNAData)observedStates.getParentData();
		
		MesquiteNumber score = new MesquiteNumber();
		

		if (aligner==null) {
			alphabetLength = ((CategoricalState)data.makeCharacterState()).getMaxPossibleState()+1;	  
			initAligner();
		}

		getAlignmentScore(data, (MCategoricalDistribution)observedStates,0,it,score,commandRec);


		if (result !=null)
			result.setValue(score);
		if (resultString!=null)
			resultString.setValue(getScoreName() + " of sequence in matrix "+ observedStates.getName() + ": " + score.getIntValue());
	}
	/*.................................................................................................................*/
	protected abstract void getAlignmentScore(DNAData data, MCategoricalDistribution observedStates, int it1, int it2, MesquiteNumber score, CommandRecord commandRec) ;

	/*.................................................................................................................*/
	/** Returns CompatibilityTest so other modules know if this is compatible with some object. */
	public CompatibilityTest getCompatibilityTest(){
		return new MolecularStateTest();
	}
	/*.................................................................................................................*/
   	 public void employeeParametersChanged(MesquiteModule employee, MesquiteModule source, Notification notification, CommandRecord commandRec) {
   	 	observedStates = null;
   	 	super.employeeParametersChanged(employee, source, notification, commandRec);
   	 }
	/*.................................................................................................................*/
    	 public abstract String getScoreName() ;
    /*.................................................................................................................*/
       	 public boolean isSubstantive(){
       	 	return true;
       	 }
	/*.................................................................................................................*/
    	 public boolean isPrerelease() {
		return true;
   	 }
    	 
 	public String getParameters() {
 		return getScoreName() + " of sequence in matrix from: " + matrixSourceTask.getParameters();
   	 }
	/*.................................................................................................................*/
   	 
 	/** returns an explanation of what the module does.*/
 	public String getExplanation() {
 		return "Reports the " + getScoreName() + " for a taxon in a data matrix." ;
   	 }
   	 
}



