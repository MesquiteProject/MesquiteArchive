/* Mesquite source code.  Copyright 1997-2005 W. Maddison and D. Maddison. Version 1.06, September 2005.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.align.lib;/*~~  */import java.util.*;import java.util.zip.CRC32;import java.lang.*;import java.io.*;import java.awt.*;import java.awt.event.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.categ.lib.*;import mesquite.lib.table.*;/* ======================================================================== */public class AlignUtil {		StringBuffer sb = new StringBuffer();		private boolean checksumValid = false;		CRC32 checksum = new CRC32();			public long getChecksum(Object o, int it, int icStart, int icEnd){			if (o instanceof MolecularData){				MolecularData data = (MolecularData)o;				checksum.reset();				for (int ic = icStart; ic<=icEnd; ic++){					long s = data.getState(ic, it);					if (!CategoricalState.isInapplicable(s))						checksum.update(Long.toString(s).getBytes());				}				return checksum.getValue();			}			else if (o instanceof MCategoricalDistribution){				MCategoricalDistribution data = (MCategoricalDistribution)o;				checksum.reset();				for (int ic = icStart; ic<=icEnd; ic++){					long s = data.getState(ic, it);					if (!CategoricalState.isInapplicable(s))						checksum.update(Long.toString(s).getBytes());				}				return checksum.getValue();			}			else if (o instanceof long[][]){				long[][] states = (long[][])o;				checksum.reset();				for (int ic = 0; ic<states.length; ic++){					long s = states[ic][it];					if (!CategoricalState.isInapplicable(s))						checksum.update(Long.toString(s).getBytes());				}				return checksum.getValue();			}			else if (o instanceof long[]){				long[] states = (long[])o;				checksum.reset();				for (int ic = 0; ic<states.length; ic++){					long s = states[ic];					if (!CategoricalState.isInapplicable(s))						checksum.update(Long.toString(s).getBytes());				}				return checksum.getValue();			}			return 0;		}			/** given an original matrix, orig,  */			int findTaxonAligned(MolecularData orig, int itOrig, Object aligned){		if (aligned instanceof String[])			return itOrig;		if (aligned instanceof long[][])			return itOrig;		if (aligned instanceof long[])  //there is only one taxon here			return 0;		if (aligned instanceof CharacterData){			Taxa origTaxa = orig.getTaxa();			Taxa alignTaxa = ((CharacterData)aligned).getTaxa();			if (origTaxa == alignTaxa)				return itOrig;			else				return alignTaxa.whichTaxonNumber(origTaxa.getTaxonName(itOrig));		}		if (aligned instanceof MCategoricalDistribution){			Taxa origTaxa = orig.getTaxa();			Taxa alignTaxa = ((MCategoricalDistribution)aligned).getTaxa();			if (origTaxa == alignTaxa)				return itOrig;			else				return alignTaxa.whichTaxonNumber(origTaxa.getTaxonName(itOrig));		}				return itOrig;	}	int getNumChars(Object o){		if (o == null)			return 0;		if (o instanceof String[]){			String[] s = (String[])o;			if (s.length == 0)				return 0;			if (s[0] == null)				return 0;			return s[0].length();		}		if (o instanceof long[][])			return ((long[][])o).length;		if (o instanceof long[])			return ((long[])o).length;		if (o instanceof CharacterData){			CharacterData data = (CharacterData)o;			return data.getNumChars();		}		else if (o instanceof MCategoricalDistribution){			MCategoricalDistribution data = (MCategoricalDistribution)o;			return data.getNumChars();		}		return 0;	}	boolean isInapplicable(Object o, int ic, int it){		if (o == null)			return true;		if (o instanceof String[]){			String[] s = (String[])o;			if (it >= s.length)				return true;			if (s[it] == null)				return true;			if (ic >= s[it].length())				return true;			return s[it].charAt(ic) == '-';		}		if (o instanceof long[][] ){			long[][] s = (long[][])o;			if (ic >= s.length)				return true;			if (s[ic] == null)				return true;			if (it >= s[ic].length)				return true;			return CategoricalState.isInapplicable(s[ic][it]);		}		if (o instanceof long[]){			long[] s = (long[])o;			if (s == null)				return true;			if (ic >= s.length)				return true;			return CategoricalState.isInapplicable(s[ic]);		}		if (o instanceof CharacterData){			CharacterData data = (CharacterData)o;			if (it >= data.getNumTaxa() || ic >= data.getNumChars())				return true;			return data.isInapplicable(ic, it);		}		if (o instanceof MCategoricalDistribution){			MCategoricalDistribution data = (MCategoricalDistribution)o;			if (it >= data.getNumTaxa() || ic >= data.getNumChars())				return true;			return CategoricalState.isInapplicable(data.getState(ic, it));		}		return true;	}	boolean sameState(CategoricalData orig, int icOrig, int itOrig, Object o, int icAligned, int itAligned){		if (o == null)			return false;		if (o instanceof long[][] ){			long[][] s = (long[][])o;			if (icAligned >= s.length)				return false;			if (s[icAligned] == null)				return false;			if (itAligned >= s[icAligned].length)				return false;			return (CategoricalState.statesBitsMask & s[icAligned][itAligned]) == (CategoricalState.statesBitsMask & orig.getState(icOrig, itOrig));		}		if (o instanceof long[] ){			long[] s = (long[])o;			if (s == null)				return false;			if (icAligned >= s.length)				return false;			return (CategoricalState.statesBitsMask & s[icAligned]) == (CategoricalState.statesBitsMask & orig.getState(icOrig, itOrig));		}		if (o instanceof String[]){			String[] s = (String[])o;			if (itAligned >= s.length)				return false;			if (s[itAligned] == null)				return false;			if (icAligned >= s[itAligned].length())				return false;			sb.setLength(0);			orig.statesIntoStringBuffer(icOrig, itOrig, sb, true);			if (sb.length()!= 1)				return false;			return s[itAligned].charAt(icAligned) == sb.charAt(0);		}		else if (o instanceof CategoricalData){			CategoricalData aligned = (CategoricalData)o;			return aligned.getState(icAligned, itAligned) == orig.getState(icOrig, itOrig);		}		else if (o instanceof MCategoricalDistribution){			MCategoricalDistribution aligned = (MCategoricalDistribution)o;			return aligned.getState(icAligned, itAligned) == orig.getState(icOrig, itOrig);		}		return false;	}		public Rectangle forceAlignment(MolecularData orig, int icStart, int icEnd, int itStart, int itEnd, Object aligned){		if (!MesquiteInteger.isCombinable(icStart) || icStart<0)			icStart = 0;		if (!MesquiteInteger.isCombinable(icEnd) || icEnd<0)			icEnd = orig.getNumChars()-1;		if (!MesquiteInteger.isCombinable(itStart) || itStart<0)			itStart = 0;		if (!MesquiteInteger.isCombinable(itEnd) || itEnd<0)			itEnd = orig.getNumTaxa()-1;		int numCharsAligned = getNumChars(aligned);		int numCharsOrig = icEnd-icStart+1;		int csproblem = -1;		int numTaxaInOrig = itEnd - itStart+1;  //numtaxa within the matrix.  this should match the number of taxa in "aligned"		long[] checkSums = new long[numTaxaInOrig];		//checksums on original matrix		for (int it = 0; it<numTaxaInOrig; it++)			checkSums[it] = getChecksum(orig, it+itStart,  0, orig.getNumChars()-1);				if (numCharsAligned>numCharsOrig) {			orig.addCharacters(icEnd, numCharsAligned-numCharsOrig, false);			orig.addInLinked(icEnd, numCharsAligned-numCharsOrig, false);			numCharsOrig = numCharsAligned;		}		Rectangle rect = null;		boolean failed = false;		for (int itOrig = itStart; itOrig<=itEnd; itOrig++){   //cycle through taxa in "aligned"			int itAligned = findTaxonAligned(orig, itOrig-itStart, aligned);  //this gives one the taxon number within "aligned"			if (itAligned>=0){				int icAligned = 0;				int icOrig = icStart;				int icOrigEnd = icStart+numCharsOrig-1;				while(icAligned < numCharsAligned && icOrig <= icOrigEnd){ //keep marching along looking for mismatch of gaps									// start at left side; proceed as long as both gaps or both nucleotides.  					while (icAligned< numCharsAligned && icOrig <= icOrigEnd && ((isInapplicable(aligned, icAligned, itAligned) && isInapplicable(orig, icOrig, itOrig)) || (!isInapplicable(aligned, icAligned, itAligned) && !isInapplicable(orig, icOrig, itOrig)))){						icAligned++;						icOrig++;					}					//aligned and orig differ at this point on whether gap or nucleotide; push or pull original accordingly					if (icAligned < numCharsAligned && icOrig <= icOrigEnd) {						// if aligned has gap, need to open up gap in orig.  						if (isInapplicable(aligned, icAligned, itAligned)) {							int startOfGapAligned = icAligned;							//first, find end of gap in aligned to know how much has to be opened in original							while(icAligned < numCharsAligned && isInapplicable(aligned, icAligned, itAligned))								icAligned++;														if (icAligned<numCharsAligned){								int gapSize = icAligned-startOfGapAligned;								//now know how big of a gap is needed; push original to match								//in case gaps that can be eated up in orig are not all at end, but push block by block until a big enough gap has opened								int spaceNeeded = gapSize;								while (spaceNeeded >0){									int startOfGapOrig = icOrig;									int endOfGapOrig = -1;									while (startOfGapOrig <= icOrigEnd && !orig.isInapplicable(startOfGapOrig, itOrig))										startOfGapOrig++;									if (orig.isInapplicable(startOfGapOrig, itOrig)){ //actually is gap										endOfGapOrig = startOfGapOrig;										while (endOfGapOrig <= icOrigEnd && orig.isInapplicable(endOfGapOrig, itOrig))											endOfGapOrig++;										endOfGapOrig--;										if (orig.isInapplicable(endOfGapOrig, itOrig)){											int spaceAvailable = endOfGapOrig-startOfGapOrig +1;											int gapToUse = spaceNeeded;											if (spaceAvailable<spaceNeeded)												gapToUse = spaceAvailable;											int added = orig.moveCells(icOrig, startOfGapOrig-1, gapToUse, itOrig, false, true, true, false,null);											icOrig += gapToUse;											spaceNeeded -= gapToUse;											if (added>0)												MesquiteMessage.warnProgrammer("Alignment added characters when shouldn't have");										}										else 											spaceNeeded = 0;									}									else 										spaceNeeded = 0; 								}							}						}						// if original has gap, pull accordingly from end of chunk forward						else {							int startOfGap = icOrig;							//findEndOf gap							while(icOrig <= icOrigEnd && isInapplicable(orig, icOrig, itOrig))								icOrig++;							if (icOrig<=icOrigEnd){								int gapSize = icOrig-startOfGap;								//now know how big of a gap must be closed								int added = orig.moveCells(icOrig, icOrigEnd, -gapSize, itOrig, false, true, true, false,null);								icOrig -= gapSize;								if (added>0)									MesquiteMessage.warnProgrammer("Alignment added characters when shouldn't have");							}						}					}				}				for (int ic = 0; ic < numCharsAligned; ic++)					if (!sameState(orig, ic+icStart, itOrig, aligned, ic, itAligned)) {						if (!failed){ //firsttime							rect = new Rectangle(ic+icStart, itOrig , ic, itAligned);						}						failed = true;						break;					}							}		}		//checksums on alignment		for (int it = 0; it<numTaxaInOrig && csproblem == -1; it++){			long cs = getChecksum(orig, it+itStart,  0, orig.getNumChars()-1);			if (cs != checkSums[it])				csproblem = it;		}		if (csproblem >=0){					rect = new Rectangle(0, csproblem , orig.getNumChars()-1, csproblem);					failed = true;		}		if (failed)			MesquiteTrunk.mesquiteTrunk.alert("ERROR: alignment incorporation failed to recover states as in aligned matrix.");		else {			MesquiteTrunk.mesquiteTrunk.logln("Data check passed. ");			if (numCharsAligned< icEnd-icStart+1 && numTaxaInOrig == orig.getNumTaxa()) {  // the aligned section has fewer characters than the old section				int ic = icEnd;  //set ic to the end of the piece aligned in the original matrix				int numToDelete=0;				int firstDelete = -1;				while (orig.entirelyInapplicable(ic) && ic >= icStart + numCharsAligned) {					if (orig.entirelyInapplicable(ic)) {						numToDelete++;						firstDelete=ic;					}					ic--;				}				if (firstDelete>=0)					orig.deleteCharacters(firstDelete, numToDelete, false); 			}		}		return rect;			}		public static int[][] getDefaultCosts(MesquiteInteger gapOpen, MesquiteInteger gapExtend,int alphabetLength){		if (gapOpen!=null)			gapOpen.setValue(8);		if (gapExtend!=null)			gapExtend.setValue(3);				int subs[][] =  new int[alphabetLength][alphabetLength];			for (int i = 0; i<alphabetLength; i++) 			for (int j = 0; j<alphabetLength; j++) {				if (i!=j)					subs[i][j] = 5;				else					subs[i][j] = 0;			}		if (alphabetLength==4) {  //then  it should be DNA			subs[0][1] = subs[1][0] = subs[0][3] = subs[3][0] = 10; //transversions involving A			subs[2][3] = subs[3][2] = subs[1][2] = subs[2][1]= 10; //transversions involving G		}		return subs;	}	/** Given a matrix, int[][] subs, containing costs for going from state i to state j, 	 *  and two int a and b representing 32-bit state sets, and the alphabetLength, this	 *  method calculates the minimum cost for going between the two statesets. 	 *  Note that this presumes multiple states in each state set represents ambiguity!	 */	public static int getCost(int[][] subs, int a, int b, int alphabetLength) {		if ((a & b) != 0)  //  the sets intersect, so there is no cost			return 0;		int minCost = Integer.MAX_VALUE;		for (int elementA=0; elementA<alphabetLength; elementA++)   			if (((1<<elementA)&a)!=0) //then e is in set a				for (int elementB=0; elementB<alphabetLength; elementB++)					if (((1<<elementB)&b)!=0) //then e is in set b						if (minCost>subs[elementA][elementB])							minCost = subs[elementA][elementB];   // find the minimum cost between a member of a and a member of b		if (minCost==Integer.MAX_VALUE)			return 0;		return minCost;			}}