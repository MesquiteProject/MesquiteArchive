/* Mesquite source code.  Copyright 1997-2008 W. Maddison and D. Maddison.Version 2.5, June 2008.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.trees.BasicTreeWindowMaker;/*~~  */import java.util.*;import java.awt.*;import java.awt.event.*;import mesquite.lib.*;import mesquite.lib.duties.*;import java.awt.datatransfer.*;import mesquite.trees.lib.TreeInfoExtraPanel;/** Makes and manages a Tree Window for tree editing and visualization */public class BasicTreeWindowMaker extends TreeWindowMaker implements CommandableOwner, TreeContext, TreeDisplayActive {	public String getName() {		return "Tree Window";	}	/** returns an explanation of what the module does.*/	public String getExplanation() {		return "Makes a basic tree window, which contains a tool palette.  Hires assistants for the tree window (e.g., Trace Character)." ;	}	public void getEmployeeNeeds(){  //This gets called on startup to harvest information; override this and inside, call registerEmployeeNeed		EmployeeNeed e = registerEmployeeNeed(TreeDisplayAssistantA.class, "A Tree Window displays trees, and can use various assistants to do analyses.",		"You can request this under the <strong>Analysis</strong> menu of the <strong>Tree Window.</strong>");		e.setPriority(2);		e.setAsEntryPoint("newAssistant");		EmployeeNeed e111 = registerEmployeeNeed(TreeDisplayAssistantAO.class, "A Tree Window displays trees, and can use various assistants to do analyses.",		"You can request this under the <strong>Analysis (Other)</strong> submenu of the <strong>Tree Window.</strong>");		e111.setPriority(2);		e111.setAsEntryPoint("newAssistant");		EmployeeNeed e2 = registerEmployeeNeed(TreeDisplayAssistantD.class, "A Tree Window displays trees, and can use various assistants to modify the display.",		"You can request this under the <strong>Tree</strong> menu of the <strong>Tree Window.</strong>");		e2.setAsEntryPoint("newAssistant");		EmployeeNeed e3 = registerEmployeeNeed(TreeWindowAssistantA.class, "A Tree Window displays trees, and can use various assistants to do analyses.",		"You can request this under the <strong>Analysis</strong> menu of the <strong>Tree Window.</strong>");		e3.setAsEntryPoint("newWindowAssistant");		EmployeeNeed e4 = registerEmployeeNeed(TreeWindowAssistantC.class, "A Tree Window displays trees, and can use various assistants to do analyses.",		"You can request this under the <strong>New Chart for Tree submenu of the Analysis</strong> menu of the <strong>Tree Window. </strong>");		e4.setAsEntryPoint("newWindowAssistant");		EmployeeNeed e5 = registerEmployeeNeed(TreeWindowAssistantN.class, "A Tree Window displays trees, and can use various assistants.",		"You can request this under the <strong>Tree</strong> menu of the <strong>Tree Window.</strong>");		e5.setAsEntryPoint("newWindowAssistant");		EmployeeNeed e6 = registerEmployeeNeed(TreeSource.class, "A Tree Window needs a source of trees.",		"You can request the source of trees when the Tree Window starts, or later using the Tree Source submenu of the Tree menu of the Tree Window.");		e6.setPriority(2);		e6.setAsEntryPoint("setTreeSource");		EmployeeNeed e20 = registerEmployeeNeed(TreeDisplayAssistantDI.class, "A Tree Window uses various assistants.",		"This is activated automatically.");		EmployeeNeed e7 = registerEmployeeNeed(TreeDisplayAssistantI.class, "A Tree Window uses various assistants.",		"This is activated automatically.");		EmployeeNeed e8 = registerEmployeeNeed(TreeWindowAssistantI.class, "A Tree Window uses various assistants.",		"This is activated automatically.");		EmployeeNeed e9 = registerEmployeeNeed(DrawTreeCoordinator.class, "A Tree Window displays a tree drawn in various possible styles.",		"This is activated automatically.");		e9.setPriority(2);		EmployeeNeed e10 = registerEmployeeNeed(TreeAlterer.class, "Trees can be altered within the Tree Window.",		"Tree altering methods are available in the Alter/Transform Tree submenu of the Tree menu.");		e10.setAsEntryPoint("alterTree");		EmployeeNeed e11 = registerEmployeeNeed(BranchLengthsAlterer.class, "The branch lengths of trees can be altered within the Tree Window.",		"Methods to alter branch lengths are available in the Alter/Transform Branch Lengths submenu of the Tree menu.");		e11.setAsEntryPoint("alterBranchLengths");	}	public void getSubfunctions(){		registerSubfunction(new FunctionExplanation("Interchange branches", "(A tool of the Tree Window) Exchanges the position of two branches in a tree in a tree window", null, getPath() + "interchange.gif"));		registerSubfunction(new FunctionExplanation("Collapse branch", "(A tool of the Tree Window) Destroys a branch, thus collapsing its daughter branches into a polytomy", null, getPath() + "collapse.gif"));		registerSubfunction(new FunctionExplanation("Collapse all branches", "(A tool of the Tree Window) Destroys all internal branches in a clade, thus collapsing the entire clade to a polytomous bush", null, getPath() + "collapseall.gif"));		registerSubfunction(new FunctionExplanation("Reroot at branch", "(A tool of the Tree Window) Reroots the tree along the branch touched", null, getPath() + "reroot.gif"));		registerSubfunction(new FunctionExplanation("Prune clade", "(A tool of the Tree Window) Deletes the clade of the node touched.  Only the tree being operated on is affected (that is, the terminal taxa are not deleted from the data file)", "scissors delete", getPath() + "scissors.gif"));		registerSubfunction(new FunctionExplanation("Ladderize clade", "(A tool of the Tree Window) Ladderizes a clade by rotating branches until largest of sister clades on right (or left, if the Option key is held down)", null, getPath() + "ladderize.gif"));		super.getSubfunctions();	}	/*.................................................................................................................*/	public DrawTreeCoordinator treeDrawCoordTask;	public TreeSource treeSourceTask;	public Vector contextListeners;	Taxa taxa;	static boolean warnUnsaved;	BasicTreeWindow basicTreeWindow;	MesquiteString treeSourceName;	MagnifyExtra magnifyExtra;	MesquiteCommand tsC;	static {		warnUnsaved = true;	}	/*...................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		loadPreferences();		makeMenu("Tree");		if (condition !=null && condition instanceof Taxa) {			taxa = (Taxa)condition;		}		resetContainingMenuBar();		treeSourceTask= (TreeSource)hireCompatibleEmployee(TreeSource.class, condition, "Source of trees (Tree window)");		if (treeSourceTask == null)			return sorry(getName() + " couldn't start because no source of trees was obtained.");		treeSourceName = new MesquiteString(treeSourceTask.getName());		tsC = makeCommand("setTreeSource",  this);		treeSourceTask.setHiringCommand(tsC);		defineMenus(false);		// for each of these employees, do same as in newAssistant below. 		contextListeners = new Vector();		//setAutoSaveMacros(true);		return true;	}	public Taxa getTaxa(){		return taxa;	}	/*.................................................................................................................*/	public DrawTreeCoordinator hireTreeDrawCoordTask() {		treeDrawCoordTask= (DrawTreeCoordinator)hireEmployee(DrawTreeCoordinator.class, null);		if (treeDrawCoordTask== null) {			sorry(getName() + " couldn't start because no tree draw coordinating module was obtained.");			return null;		}		treeDrawCoordTask.setToLastEmployee(true);		hireAllEmployees(TreeDisplayAssistantI.class);		hireAllEmployees(TreeDisplayAssistantDI.class);		resetContainingMenuBar();		return treeDrawCoordTask;	}	/*--------------------------------------*/	public boolean isPrerelease(){		return false;	}	public String getExpectedPath(){		return getPath() + "recent";	}	/*--------------------------------------*/	/*Menus defined in this method are visible to Mesquite's automatic documentation system  <b>(overrides method of MesquiteModule)</b>*/	public void defineMenus(boolean accumulating){		if (accumulating || numModulesAvailable(TreeSource.class)>1) {			MesquiteSubmenuSpec mss = addSubmenu(null, "Tree Source", tsC);			if (!accumulating){				mss.setSelected(treeSourceName);				mss.setList(TreeSource.class);				if (taxa !=null)					mss.setCompatibilityCheck(taxa);			}		}	}	public  Commandable[] getCommandablesForAccumulation(){		Commandable[] cs = new Commandable[1];		cs[0]= new BasicTreeWindow();		return cs;	}	public void employeeQuit(MesquiteModule m){		if (basicTreeWindow!=null)			basicTreeWindow.contentsChanged();	}	public void processPreferencesFromFile (String[] prefs) {		if (prefs!=null && prefs.length>0) {			if (prefs[0].equals("warned")) {				warnUnsaved = false;			}		}	}	/*.................................................................................................................*/	public String preparePreferencesForXML () {		StringBuffer buffer = new StringBuffer();		StringUtil.appendXMLTag(buffer, 2, "warnUnsaved", warnUnsaved);   		return buffer.toString();	}	public void processSingleXMLPreference (String tag, String content) {		if ("warnUnsaved".equalsIgnoreCase(tag))			warnUnsaved = MesquiteBoolean.fromTrueFalseString(content);	}	public boolean treeIsEdited(){		if (basicTreeWindow == null)			return false;		return basicTreeWindow.treeEdited;	}	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) {		if (basicTreeWindow==null)			return null;		Snapshot temp = new Snapshot();		Snapshot fromWindow = basicTreeWindow.getSnapshot(file);		temp.addLine("suppressEPCResponse");		temp.addLine("setTreeSource " , treeSourceTask);		temp.addLine("setAssignedID " + getPermanentIDString());  //for tree context		temp.addLine("getTreeWindow");		temp.addLine("tell It");		temp.incorporate(fromWindow, true);		for (int i = 0; i<getNumberOfEmployees(); i++) {			Object e=getEmployeeVector().elementAt(i);			if (e instanceof TreeDisplayAssistantD || e instanceof TreeDisplayAssistantA || e instanceof TreeDisplayAssistantAO) {				temp.addLine("\tnewAssistant " , ((MesquiteModule)e));			}		}		for (int i = 0; i<getNumberOfEmployees(); i++) {			Object e=getEmployeeVector().elementAt(i);			if (e instanceof TreeWindowAssistantC || e instanceof TreeWindowAssistantN || e instanceof TreeWindowAssistantA) {				temp.addLine("\tnewWindowAssistant " , ((MesquiteModule)e));			}		}		temp.addLine("endTell");		temp.addLine("desuppressEPCResponse");		return temp;	}	/*.................................................................................................................*/	/** Query module as to whether conditions are such that it will have to quit soon -- e.g. if its taxa block has been doomed.  The tree window, data window, 	etc. override this to return true if their object is doomed. This is useful in case MesquiteListener disposing method is not called for an employer before one of its	employees discovers that it needs to quit.  If the employer is going to quit anyway,there is no use to use auto rehire for the quit employee.*/	public boolean quittingConditions(){		return (taxa.isDoomed());	}	boolean suppressEPCResponse = false;	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Returns the block of taxa associated with this tree window", null, commandName, "getTaxa")) {			return taxa;		}		else if (checker.compare(this.getClass(), "Displays the tree window", null, commandName, "show")) {			displayTreeWindow();		}		else if (checker.compare(this.getClass(), "Suppresses responding to parameters changed.", null, commandName, "suppressEPCResponse")) {			suppressEPCResponse = true;		}		else if (checker.compare(this.getClass(), "Suppresses responding to parameters changed.", null, commandName, "desuppressEPCResponse")) {			suppressEPCResponse = false;			basicTreeWindow.resetForTreeSource(false, false);		}		else if (checker.compare(this.getClass(), "Sets the tree in the window to the description passed", "[standard tree description]", commandName, "setTree")) { //added 10 Jan 02 for use in Send Script dialog			if (basicTreeWindow!=null){				basicTreeWindow.doCommand(commandName, arguments, checker);			}		}		else if (checker.compare(this.getClass(), "Sets the source of trees", "[name of tree source module]", commandName, "setTreeSource")) {			if (basicTreeWindow!=null)				basicTreeWindow.hideTree();			TreeSource temp = (TreeSource)replaceEmployee(TreeSource.class, arguments, "Source of trees", treeSourceTask);			if (temp !=null){				treeSourceTask = temp;				treeSourceTask.setHiringCommand(tsC);				treeSourceName.setValue(treeSourceTask.getName());				if (basicTreeWindow!=null) {					basicTreeWindow.setTreeSource(treeSourceTask);					basicTreeWindow.showTree();				}				treeSourceTask.setPreferredTaxa(taxa);				resetContainingMenuBar();				resetAllWindowsMenus();				return treeSourceTask;			}			else if (basicTreeWindow!=null)				basicTreeWindow.showTree();		}		else if (checker.compare(this.getClass(), "Constructs a tree window referring to a block of taxa, or returns the existing window if this module has already made one.", "[number of block of taxa, 0 based]", commandName, "makeTreeWindow")) {			if (basicTreeWindow != null)				return basicTreeWindow;			String tRef = parser.getFirstToken(arguments);			int setNumber = MesquiteInteger.fromString(tRef);			Taxa taxa = null;			if (!MesquiteInteger.isCombinable(setNumber)) {				taxa = getProject().getTaxaLastFirst(tRef); 			}			else				taxa = getProject().getTaxa(checker.getFile(), setNumber);			if (taxa !=null) {				makeTreeWindow(taxa);				return basicTreeWindow;			}		}		else if (checker.compare(this.getClass(), "Returns the tree draw coordinating module", null, commandName, "getTreeDrawCoordinator")) {			return treeDrawCoordTask;		}		else if (checker.compare(this.getClass(), "Returns the tree window", null, commandName, "getTreeWindow")) {			return basicTreeWindow;		}		else if (checker.compare(this.getClass(), "Returns the tree", null, commandName, "getTree")) {			return getTree();		}		else if (checker.compare(this.getClass(), "Sets the tree as having been edited (thus showing it as \"untitled\"", null, commandName, "treeEdited")) {			basicTreeWindow.doCommand(commandName, arguments, checker);		}		else if (checker.compare(this.getClass(), "Hires a tree display assistant module", "[name of assistant module]", commandName, "newAssistant")) {			return basicTreeWindow.doCommand(commandName, arguments, checker);		}		else if (checker.compare(this.getClass(), "Hires a tree window assistant module", "[name of assistant module]", commandName, "newWindowAssistant")) {			return basicTreeWindow.doCommand(commandName, arguments, checker);		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	/*.................................................................................................................*/	public void employeeOutputInvalid(MesquiteModule employee, MesquiteModule source) {		if (basicTreeWindow==null)			return;		basicTreeWindow.contentsChanged();		basicTreeWindow.treeDisplay.pleaseUpdate(false);	}	/*.................................................................................................................*/	public void employeeParametersChanged(MesquiteModule employee, MesquiteModule source, Notification notification) {		if (basicTreeWindow==null)			return;		if (employee instanceof DrawTreeCoordinator){ 			Dimension d = treeDrawCoordTask.getPreferredSize();			if (d == null && basicTreeWindow.oldPreferred == null)				return;			if ((d == null && basicTreeWindow.oldPreferred !=null)|| (basicTreeWindow.oldPreferred == null && d != null) || (d.width != basicTreeWindow.oldPreferred.width && d.height != basicTreeWindow.oldPreferred.height)) {				if (basicTreeWindow.useSuggestedSize.getValue()){					basicTreeWindow.setSuggestedSize(false, true);					basicTreeWindow.treeDisplay.pleaseUpdate(true);				}			}		}		else if (employee instanceof TreeSource) {			if (suppressEPCResponse)				return;			if (Notification.getCode(notification) == MesquiteListener.ITEMS_ADDED){				if (basicTreeWindow.usingDefaultBush){					basicTreeWindow.resetForTreeSource(false, false); 					basicTreeWindow.contentsChanged();				}				else					basicTreeWindow.numTreesChanged(); 			}			else if (Notification.getCode(notification) == MesquiteListener.NUM_ITEMS_CHANGED){				basicTreeWindow.numTreesChanged(); 			}			else if (Notification.getCode(notification) != MesquiteListener.SELECTION_CHANGED){				basicTreeWindow.resetForTreeSource(false, false); //if switching between tree blocks, should reset to zero!  If storing tree in tree block, shouldn't!				basicTreeWindow.contentsChanged();			}		}		else  {			if (suppressEPCResponse)				return;			if (basicTreeWindow.treeDisplay!=null) {				basicTreeWindow.contentsChanged();				TreeDisplayExtra[] ee = basicTreeWindow.treeDisplay.getMyExtras(employee);				if (ee != null)					for (int i=0; i<ee.length; i++)						ee[i].setTree(basicTreeWindow.treeDisplay.getTree()); //done to force recalculations				basicTreeWindow.treeDisplay.pleaseUpdate(false);			}		}	}	/*.................................................................................................................*/	public TreeDisplay getTreeDisplay(){		return basicTreeWindow.treeDisplay;	}	/*.................................................................................................................*/	/** because TreeContext */	public Tree getTree(){		if (basicTreeWindow==null)			return null;		else			return basicTreeWindow.tree;	}	/*.................................................................................................................*/	/** because TreeContext */	public String getContextName(){		if (basicTreeWindow==null)			return "Tree Window";		return basicTreeWindow.getTitle();	}	/*.................................................................................................................*/	/** because TreeContext */	public void addTreeContextListener (TreeContextListener listener){		if (listener!=null && contextListeners.indexOf(listener)<0)			contextListeners.addElement(listener);	}	/*.................................................................................................................*/	/** because TreeContext */	public void removeTreeContextListener (TreeContextListener listener){		contextListeners.removeElement(listener);	}	/*.................................................................................................................*/	/** because TreeContext */	public MesquiteModule getTreeSource(){		return treeSourceTask;	}	/*.................................................................................................................*/	public void makeTreeWindow(Taxa taxa){		incrementMenuResetSuppression();		this.taxa = taxa;		treeSourceTask.setPreferredTaxa(taxa);		BasicTreeWindow btw = new BasicTreeWindow( this, treeSourceTask, taxa);		setModuleWindow(btw);		basicTreeWindow = (BasicTreeWindow) getModuleWindow();		Enumeration e = getEmployeeVector().elements();		while (e.hasMoreElements()) {			Object obj = e.nextElement();			if (obj instanceof TreeDisplayAssistantI || obj instanceof TreeDisplayAssistantDI) {				TreeDisplayAssistant tca = (TreeDisplayAssistant)obj;				basicTreeWindow.addAssistant(tca);			}		}		btw.sizeDisplay();		addMenuItem(MesquiteTrunk.analysisMenu, "-", null);		MesquiteCommand mC = makeCommand("newWindowAssistant",  basicTreeWindow);		MesquiteSubmenuSpec mms = addSubmenu(MesquiteTrunk.analysisMenu, "New Chart for Tree", mC); 		mms.setZone(0);		mms.setList(TreeWindowAssistantC.class);		addModuleMenuItems( MesquiteTrunk.analysisMenu, makeCommand("newAssistant",  basicTreeWindow), TreeDisplayAssistantA.class);		addModuleMenuItems( MesquiteTrunk.analysisMenu, makeCommand("newWindowAssistant",  basicTreeWindow), TreeWindowAssistantA.class);		MesquiteSubmenuSpec mmsO = addSubmenu(MesquiteTrunk.analysisMenu, "Other Analyses", makeCommand("newAssistant", basicTreeWindow)); 		mmsO.setList(TreeDisplayAssistantAO.class);		addMenuItem(MesquiteTrunk.analysisMenu, "-", null);		addMenuItem(null, "Force Repaint", makeCommand("forceRepaint", basicTreeWindow));		if (!MesquiteThread.isScripting()) {			displayTreeWindow();		}		decrementMenuResetSuppression();	}	void displayTreeWindow(){		if (getModuleWindow() == null)			return;		getModuleWindow().setVisible(true);		basicTreeWindow.showTree();		getModuleWindow().toFront();	}	/*.................................................................................................................*/	public void windowGoAway(MesquiteWindow whichWindow) {		iQuit();	}	public void endJob(){		if (contextListeners!=null){			Enumeration e = contextListeners.elements();			while (e.hasMoreElements()) {				Object obj = e.nextElement();				if (obj instanceof TreeContextListener) {					TreeContextListener tce = (TreeContextListener)obj;					tce.disposing(this);				}			}			contextListeners.removeAllElements();		}		treeDrawCoordTask=null;		treeSourceTask=null;		basicTreeWindow = null;		super.endJob();	}	/*.................................................................................................................*/	public String getParameters() {		String s = "";		;		if (getModuleWindow()!=null){			if (((BasicTreeWindow)getModuleWindow()).treeEdited)				s +=  "Tree shown is not directly from source, but rather is an edited tree. ";			if (((BasicTreeWindow)getModuleWindow()).getTaxa()!=null)				s+= "Taxa: " + ((BasicTreeWindow)getModuleWindow()).getTaxa().getName();		}		return s ;	}	/*.................................................................................................................*/	public boolean isSubstantive(){		return true;	}	/*.................................................................................................................*/	public boolean mouseDownInTreeDisplay(int modifiers, int x, int y, TreeDisplay treeDisplay, Graphics g) {		if (x>2000000 || y> 2000000)			return true; //here because of bug in Mac OS X 10.0.4		if (!treeDisplay.getTree().isLocked())			return basicTreeWindow.ScanTouch(g, x, y, modifiers);		return false;	}	/*.................................................................................................................*/	public boolean mouseUpInTreeDisplay(int modifiers, int x, int y, TreeDisplay treeDisplay, Graphics g) {		if (x>2000000 || y> 2000000)			return true; //here because of bug in Mac OS X 10.0.4		if (!treeDisplay.getTree().isLocked()) {			basicTreeWindow.ScanDrop( g, x, y, modifiers);			basicTreeWindow.branchFrom=0;		}		return true;	}	/*.................................................................................................................*/	public boolean mouseMoveInTreeDisplay(int modifiers, int x, int y, TreeDisplay treeDisplay, Graphics g) {		if (x>2000000 || y> 2000000)			return true; //here because of bug in Mac OS X 10.0.4		if (!treeDisplay.getTree().isLocked()) {			Shape c = g.getClip();			g.setClip(0,0,99999, 99999);			basicTreeWindow.ScanFlash(g, x, y, modifiers);			g.setClip(c);		}		//basicTreeWindow.setExplanation(basicTreeWindow.baseExplanation, false);		return true;	}	/*.................................................................................................................*/	public boolean mouseDragInTreeDisplay(int modifiers, int x, int y, TreeDisplay treeDisplay, Graphics g) {		if (x>2000000 || y> 2000000)			return true; //here because of bug in Mac OS X 10.0.4		if (!treeDisplay.getTree().isLocked()) {			Shape c = g.getClip();			g.setClip(0,0,99999, 99999);			basicTreeWindow.ScanDrag(g, x, y, modifiers);			g.setClip(c);		}		return true;	}	/*.................................................................................................................*/	/**Returns command to hire employee if clonable*/	public String getClonableEmployeeCommand(MesquiteModule employee){		if (employee!=null && employee.getEmployer()==this) {			if (employee.getHiredAs()==TreeWindowAssistant.class)				return ("newWindowAssistant " + StringUtil.tokenize(employee.getName()) + ";");//quote			if (employee.getHiredAs()==TreeDisplayAssistant.class)				return ("newAssistant " + StringUtil.tokenize(employee.getName()) + ";");//quote		}		return null;	}	public void transposeField(){		if (basicTreeWindow == null)			return;		int w =basicTreeWindow.totalTreeFieldWidth;		basicTreeWindow.totalTreeFieldWidth = basicTreeWindow.totalTreeFieldHeight ;		basicTreeWindow.totalTreeFieldHeight = w;		basicTreeWindow.sizeDisplay();	}	/*.................................................................................................................*  	 public CompatibilityTest getCompatibilityTest() {  	 	return new BTWCompatibilityTest();  	 }	/*.................................................................................................................*/}/*class BTWCompatibilityTest extends CompatibilityTest{	//should find out if available matrices of chosen sort	public  boolean isCompatible(Object obj, MesquiteProject project, EmployerEmployee prospectiveEmployer){		return true;	}}/* ======================================================================== */class BasicTreeWindow extends MesquiteWindow implements Fittable, MesquiteListener, AdjustmentListener {	MesquiteTree tree;  	TreeDisplay treeDisplay;	Taxa taxa;	DrawTreeCoordinator treeDrawCoordTask;	boolean treeEdited=false;	TreeScrollPane treePane;	Adjustable hAdjust, vAdjust;	TreeSource treeSourceTask;	boolean warningGivenForTreeSource = false;	static final int scrollWidth = 16;	static final int initalWindowHeight = 400;	static final int initalWindowWidth = 520;	static final int baseMessageWidth = 256;	int messageWidth = 256;	int totalTreeFieldWidth = 800;	int totalTreeFieldHeight  = 800;	TreeWindowPalette palette;	MessagePanel messagePanel;	/*New code added Feb.07 oliver*/ //TODO: delete new code comments	ControlStrip controlStrip;	/*End new code added Feb.07 oliver*/		boolean canUndo = true;	MesquiteCommand setTreeNumberCommand;	TreeTool currentTreeTool;	MesquiteBoolean sizeToFit;	MesquiteBoolean useSuggestedSize;	MesquiteBoolean infoPanelOn;	MesquiteBoolean floatLegends;	MesquiteBoolean textVersionDrawOnTree;	BasicTreeWindowMaker windowModule;	MesquiteInteger dropHighlightedBranch = new MesquiteInteger(0);	MesquiteInteger highlightedBranch = null;	int branchFrom;	int highlightedTaxon=-1;	int taxonTouched = -1;	int xFrom, yFrom, xTo, yTo, fieldTouchX, fieldTouchY, lastFieldDragX, lastFieldDragY;	boolean usingDefaultBush = false;	private int currentTreeNumber = 0;	MesquiteMenuItemSpec sizeItem;	static int numWindows=0;	private int windowNum=0;	MagnifyExtra magnifyExtra;	int initPosX = 0;	int initPosY = 0;	long treeVersion = 0;	MesquiteTree oldTree = null;	MesquiteTree undoTree = null;	MesquiteTree previousTree = null;	TreeVector recentEditedTrees;	int maxRecentEditedTrees = 20;	MesquiteCommand undoCommand, copyCommand, pasteCommand;	MesquiteString baseExplanation;	TreeReference treeReference = new TreeReference();	//MesquiteString currentTreeFootnote;	Tree originalTree;	boolean baseExplanationUsed=false;	boolean treeAnnotationShown = false;	MesquiteMenuItemSpec storeTreeMenuItem, storeTreeAsMenuItem;	MesquiteMenuItemSpec floatLegendsItem;	int oldH = 0;	int oldV = 0;	boolean showTreeListOnSave = false;  //have preference for this?	Dimension oldPreferred = null;	TreeInfoPanel treeInfoPanel;	boolean treeInfoPanelEverShown = false;	/*When lockStoredTrees is true (MacClade mode), editing a stored tree causes the tree to be treated as unsaved, and for the new tree to be saved, Store Tree or Replace Stored Tree must	be called.  When false, editing a stored tree changes the original in storage.*/ 	//boolean lockStoredTrees = false;	//LockPanel lockPanel;	public BasicTreeWindow(){	}	public BasicTreeWindow ( BasicTreeWindowMaker ownerModule, TreeSource tsT,  Taxa taxa){		super(ownerModule, true); //INFOBAR		//this.ownerModule = ownerModule;		setWindowSize(initalWindowWidth,initalWindowHeight);		ownerModule.setModuleWindow(this);		baseExplanation = new MesquiteString("");		numWindows++;		windowNum=numWindows;		windowModule = ownerModule;		this.taxa=taxa;		//1		treeDrawCoordTask = windowModule.hireTreeDrawCoordTask();  // do this here to ensure that any modules hired by the task have a window into which to put things		if (treeDrawCoordTask==null)			return;		recentEditedTrees = new TreeVector(taxa);		this.ownerModule = ownerModule;		this.treeSourceTask=tsT;		useSuggestedSize = new MesquiteBoolean(true);		infoPanelOn = new MesquiteBoolean(false);		sizeToFit = new MesquiteBoolean(true);		floatLegends = new MesquiteBoolean(true);		textVersionDrawOnTree = new MesquiteBoolean(false);		controlStrip = new ControlStrip((BasicTreeWindowMaker)ownerModule);		MesquiteButton listButton = new MesquiteButton(ownerModule, MesquiteModule.makeCommand("showTaxaList",  this), null, true, MesquiteModule.getRootImageDirectoryPath() + "listT.gif", 12, 16);		listButton.setShowBackground(false);		listButton.setUseWaitThread(false);		listButton.setButtonExplanation("Show List of Taxa window");		controlStrip.addButton(listButton);		MesquiteButton infoButton = new MesquiteButton(ownerModule, MesquiteModule.makeCommand("toggleInfoPanel",  this), null, true, MesquiteModule.getRootImageDirectoryPath() + "showInfo.gif", 12, 16);		infoBar.addExtraButton(MesquiteModule.getRootImageDirectoryPath() + "showInfo.gif", MesquiteModule.makeCommand("toggleInfoPanel",  this));		infoButton.setUseWaitThread(false);		infoButton.setShowBackground(false);		infoButton.setButtonExplanation("Show Tree Info Panel");		controlStrip.addButton(infoButton);		addToWindow(controlStrip);		ownerModule.addCheckMenuItem(null, "Show Tree Info Panel", ownerModule.makeCommand("toggleInfoPanel",  this), infoPanelOn);		tree = null;		Tree tempTree = treeSourceTask.getTree(taxa, 0);		//in case treeSourceTask quits at this point, will reset tree source task		if (tempTree == null || treeSourceTask != ownerModule.treeSourceTask){			treeSourceTask = ownerModule.treeSourceTask;			tempTree = treeSourceTask.getTree(taxa, 0);		}		originalTree = tempTree;		if (tempTree == null) {			tree = taxa.getDefaultTree();			usingDefaultBush = true;			ownerModule.discreetAlert(MesquiteThread.isScripting() || warningGivenForTreeSource,"Tree source \"" +treeSourceTask.getName() +  "\" is not supplying a tree; a default tree will be shown in Tree Window (c).");			if (!MesquiteThread.isScripting())				warningGivenForTreeSource = true;		}		else 			tree = tempTree.cloneTree();		//currentTreeFootnote = new MesquiteString(tree.getAnnotation());		//currentTreeFootnote.addListener(this);		treeAnnotationShown = true; //so that the base Explanation can refer to the annotation		treeVersion = tree.getVersionNumber();		oldTree = tree;		undoTree = tree.cloneTree();		previousTree = tree.cloneTree();		taxa.addListenerHighPriority(undoTree);		taxa.addListenerHighPriority(previousTree);		hookCurrentTree();		if (taxa!=null) {			taxa.addListener(this);		}		treeDisplay =treeDrawCoordTask.createOneTreeDisplay(taxa, this);		treeDisplay.textVersionDrawOnTree = textVersionDrawOnTree.getValue();		treeDisplay.setLocation(0, 0);		highlightedBranch = treeDisplay.getHighlightedBranchMI();		setSuggestedSize(false, false);		setTreeNumberCommand = ownerModule.makeCommand("setTreeNumber",  this);		storeTreeMenuItem = ownerModule.addMenuItem( "Store Tree", ownerModule.makeCommand("storeTree",  this));		if (treeSourceTask.nameMatches("StoredTrees"))			storeTreeAsMenuItem = ownerModule.addMenuItem( "Store Tree As...", ownerModule.makeCommand("storeTreeAs",  this));		else			storeTreeAsMenuItem = ownerModule.addMenuItem( "Store Copy of Tree As...", ownerModule.makeCommand("storeTreeAs",  this));		storeTreeMenuItem.setEnabled(!treeSourceLocked());		ownerModule.addMenuItem( "-", null);		ownerModule.addMenuItem( "Choose Tree...", ownerModule.makeCommand("chooseTree",  this));		MesquiteMenuItemSpec mm = ownerModule.addMenuItem( "Next Tree", ownerModule.makeCommand("nextTree",  this)); //DOES THIS WORK??		mm.setShortcut(KeyEvent.VK_UP); //right		mm = ownerModule.addMenuItem( "Previous Tree", ownerModule.makeCommand("previousTree",  this));		mm.setShortcut(KeyEvent.VK_DOWN); //right		ownerModule.addMenuItem( "Step Through Trees...", ownerModule.makeCommand("stepThroughTrees",  this));		ownerModule.addMenuItem( "-", null);		ownerModule.addSubmenu(null, "Alter/Transform Tree", ownerModule.makeCommand("alterTree",  this), TreeAlterer.class);		ownerModule.addSubmenu(null, "Alter/Transform Branch Lengths", ownerModule.makeCommand("alterBranchLengths",  this), BranchLengthsAlterer.class);		ownerModule.addMenuItem( "Cut Selected Taxa", ownerModule.makeCommand("cutSelectedTaxa",  this));		ownerModule.addMenuItem( "-", null);		ownerModule.addModuleMenuItems(null, ownerModule.makeCommand("newWindowAssistant", this), TreeWindowAssistantN.class);		ownerModule.addModuleMenuItems(null, ownerModule.makeCommand("newAssistant",  this), TreeDisplayAssistantD.class);		ownerModule.addMenuItem( "-", null);		MesquiteSubmenuSpec mBringToFrontAsst = ownerModule.addSubmenu(null, "Bring To Front");		mBringToFrontAsst.setList(treeDisplay.getExtras());		mBringToFrontAsst.setListableFilter(TreeDisplayDrawnExtra.class);		mBringToFrontAsst.setCommand(ownerModule.makeCommand("bringToFront",  this));		MesquiteSubmenuSpec mSaveMacroAsst = ownerModule.addSubmenu(null, "Save Tree Analysis as Macro");		mSaveMacroAsst.setList(ownerModule.getEmployeeVector());		mSaveMacroAsst.setListableFilter(TreeDisplayAssistantAD.class);		mSaveMacroAsst.setCommand(ownerModule.makeCommand("saveMacroDisplayAssistant",  this));		MesquiteSubmenuSpec mCloseAsst = ownerModule.addSubmenu(null, "Close/Remove");		mCloseAsst.setList(ownerModule.getEmployeeVector());		mCloseAsst.setListableFilter(TreeDisplayAssistantAD.class);		mCloseAsst.setCommand(ownerModule.makeCommand("closeDisplayAssistant",  this));		treeDrawCoordTask.addMenuItem("-", null);		treeDrawCoordTask.addCheckMenuItem(null, "Use Suggested Size", ownerModule.makeCommand("useSuggestedSize",  this), useSuggestedSize);		treeDrawCoordTask.addCheckMenuItem(null, "Size To Window", ownerModule.makeCommand("toggleSizeToFit",  this), sizeToFit);		sizeItem = treeDrawCoordTask.addMenuItem("Drawing Size...", MesquiteModule.makeCommand("sizeDrawing",  this));		floatLegendsItem = treeDrawCoordTask.addCheckMenuItem(null, "Float Legends", ownerModule.makeCommand("toggleLegendFloat",  this), floatLegends);		treeDrawCoordTask.addCheckMenuItem(null, "Text Extras On Trees", ownerModule.makeCommand("toggleTextOnTree",  this), textVersionDrawOnTree);		treeDrawCoordTask.addMenuItem("-", null);		undoCommand = MesquiteModule.makeCommand("undo", this);		copyCommand =MesquiteModule.makeCommand("copyTree", this);		pasteCommand = MesquiteModule.makeCommand("paste", this);		treeDisplay.setTaxonNameBuffer(30);		messagePanel=new MessagePanel(ownerModule);		addToWindow(messagePanel);		messagePanel.setVisible(true);		/*		lockPanel=new LockPanel(this);		addToWindow(lockPanel);		lockPanel.setLocation(0, getHeight()-scrollWidth);		lockPanel.setVisible(true);		 */		setBackground(Color.white);		/*Edited Feb.06 was (see commented out line below) oliver*/ //TODO: Delete new code comments	//		messagePanel.setLocation(0, getHeight()-scrollWidth);		messagePanel.setLocation(25, getHeight()-scrollWidth);		controlStrip.setLocation(0, getHeight()-scrollWidth);		/*End edited Feb.06 oliver*/		TreeTool tool1 = new TreeTool(this, "arrow", MesquiteModule.getRootImageDirectoryPath(), "arrow.gif", 4,2,"Move branch", "This tool is used for rearranging the tree by moving branches.  By clicking on one branch, then holding the mouse button down, one can drag the branch and drop it on another branch.  If a legal move, the first branch will be cut and grafted on the second branch.  A move is illegal if the first branch is a descendant of the second branch.");		tool1.setTransferredCommand(MesquiteModule.makeCommand("moveBranch",  this));		//tool1.setTouchedTaxonCommand(MesquiteModule.makeCommand("touchTaxon",  this)); //cut as of 1.02		currentTreeTool = tool1;		addTool(tool1);		setCurrentTool(currentTreeTool);		currentTreeTool.setInUse(true);		currentTreeTool.setIsArrowTool(true);		/*		TreeTool toolMAG = new TreeTool(this, "zoom", ownerModule.getPath(), "zoom.gif",  4,4,"Zoom image", "This tool magnifies (or shrinks, if Option/Alt is held down) the image of the whole tree.");		toolMAG.setTouchedCommand(MesquiteModule.makeCommand("zoomB",  this));		toolMAG.setTouchedFieldCommand(MesquiteModule.makeCommand("zoom",  this));		toolMAG.setOptionImageFileName("zoomOut.gif", 4, 4);		addTool(toolMAG);		 */		TreeTool tool2 = new TreeTool(this, "interchange", ownerModule.getPath(),"interchange.gif", 7,13,"Interchange branches", "This tool is used as is the Move Branch (arrow) tool, except that the result is to interchange the locations of the two branches.  It can be used to rotate a node.");		tool2.setTransferredCommand(MesquiteModule.makeCommand("exchangeBranches",  this));		addTool(tool2);		TreeTool tool3 = new TreeTool(this, "collapse", ownerModule.getPath(),"collapse.gif",  7,12, "Collapse branch", "This tool destroys a branch, thus collapsing its daughter branches into a polytomy.  It cannot be used on terminal branches.");		tool3.setTouchedCommand(MesquiteModule.makeCommand("collapseBranch",  this));		addTool(tool3);		TreeTool tool4 = new TreeTool(this, "collapseall", ownerModule.getPath(), "collapseall.gif", 8,13,"Collapse all branches", "This tool destroys all internal branches in a clade, thus collapsing the entire clade to a polytomous bush.");		tool4.setTouchedCommand(MesquiteModule.makeCommand("collapseAll",  this));		tool4.setOptionImageFileName("collapseAllBelow.gif", 14, 4);		addTool(tool4);		TreeTool tool6 = new TreeTool(this, "reroot", ownerModule.getPath(), "reroot.gif",  3,4,"Reroot at branch", "This tool reroots the tree along the branch touched.");		tool6.setTouchedCommand(MesquiteModule.makeCommand("rootAlongBranch",  this));		addTool(tool6);		TreeTool tool5 = new TreeTool(this, "scissors", ownerModule.getPath(), "scissors.gif" , 6,5,"Prune clade", "This tool deletes the clade of the node touched.  Only the tree being operated on is affected (that is, the terminal taxa are not deleted from the data file).");		tool5.setTouchedCommand(MesquiteModule.makeCommand("cutClade",  this));		addTool(tool5);		TreeTool tool7 = new TreeTool(this, "ladderize", ownerModule.getPath(), "ladderize.gif",  3,13,"Ladderize clade", "This tool ladderizes a clade by rotating branches until largest of sister clades on right (except if option key is held down, in which case, left).");		tool7.setTouchedCommand(MesquiteModule.makeCommand("ladderize",  this));		tool7.setTouchedTaxonCommand(MesquiteModule.makeCommand("focalLadderize",  this));		tool7.setOptionImageFileName("reverseLadderize.gif", 13, 13);		addTool(tool7);		TreeTool tool8 = new TreeTool(this, "triangle", ownerModule.getPath(), "triangle.gif", 7,13,"Draw clade as triangle", "This tool designates the clade of the node touched to be drawn in compact form, for instance as a triangle.  This affects only drawing; it does not affect calculations, as the clade (with its phylogenetic structure) is still present in the tree.  This can be used for large trees to hide temporarily details within some clades.");		tool8.setTouchedCommand(MesquiteModule.makeCommand("drawAsTriangle",  this)); 		addTool(tool8);		TreeTool tool9 = new TreeTool(this, "magnify", ownerModule.getPath(), "magnify.gif", 4,4,"Magnify Clade", "This tool fills the tree window with the clade of the node touched.  The rest of the tree is present, but not shown.  This can be use for large trees to focus on individual clades");		tool9.setTransferredCommand(MesquiteModule.makeCommand("magnifyClade",  this));		addTool(tool9);		magnifyExtra = new MagnifyExtra(ownerModule, treeDisplay, tool9);		ownerModule.magnifyExtra = magnifyExtra;		treeDisplay.addExtra(magnifyExtra); 		treeDisplay.setTree(tree);		togglePane(true);		treeDisplay.setVisible(true);		treeInfoPanel = new TreeInfoPanel(this);		TreeInfoPanelAssistant valuesAssistant = (TreeInfoPanelAssistant)ownerModule.hireNamedEmployee(TreeInfoPanelAssistant.class, "#TreeInfoValues");		treeInfoPanel.addExtraPanel(valuesAssistant.getPanel(treeInfoPanel));		setTreeName();		ownerModule.hireAllEmployees(TreeWindowAssistantI.class); 		Enumeration em = ownerModule.getEmployeeVector().elements();		if (tree != null)			while (em.hasMoreElements()) {				Object obj = em.nextElement();				MesquiteModule mb = (MesquiteModule)obj;				if (mb instanceof TreeWindowAssistant) {					((TreeWindowAssistant)mb).setTree(tree);  				}			}		setShowExplanation(true);		setShowAnnotation(true);		baseExplanation.setValue("This is a tree window.  In it you can view trees from various tree sources, edit trees, and store trees.");		setExplanation(baseExplanation, true);		sizeDisplay();		resetTitle();	}	/*.................................................................................................................*/	void setTreeInfoPanel(boolean show){		infoPanelOn.setValue(show);		if (show){			treeInfoPanelEverShown = true;			addSidePanel(treeInfoPanel, TreeInfoPanel.width);			treeInfoPanel.setVisible(true);			treeInfoPanel.setTree(tree);			String title = "Tree Information";			treeInfoPanel.repaint();		}		else {			if (treeInfoPanel != null)				removeSidePanel(treeInfoPanel);		}	}	void treeInfoPanelGoAway(){		setTreeInfoPanel(false);	}	/*.................................................................................................................*/	public String searchData(String s, MesquiteString commandResult) {		if (StringUtil.blank(s) || taxa == null)			return "<h2>Nothing to search for (searched: \"" + s + "\")</h2>";		if (commandResult != null)			commandResult.setValue((String)null);		String listData = taxa.searchData(s, commandResult);		if (!StringUtil.blank(listData))			return "<h2>Matches to search string: \"" + s + "\"</h2>" + listData;		else			return "<h2>No matches found (searched: \"" + s + "\")</h2>";	}	/*.................................................................................................................*/	private void makeTaxonVisible(int i){		if (sizeToFit.getValue())			return;		if (treePane != null){			TreeDrawing td = treeDisplay.getTreeDrawing();			int x = td.x[treeDisplay.getTree().nodeOfTaxonNumber(i)];			int y = td.y[treeDisplay.getTree().nodeOfTaxonNumber(i)];			//	treePane.setScrollPosition(x, y);			int w = treePane.getBounds().width;			int h = treePane.getBounds().height;			setOrigin(-x + w/2, -y + h/2);			treeDisplay.pleaseUpdate(true);		}	}	/*.................................................................................................................*/	protected ToolPalette makeToolPalette(){		palette = new TreeWindowPalette((BasicTreeWindowMaker)ownerModule, this);		palette.setFirstToolHeight(76);		return palette;	}	/*.................................................................................................................*/	/** When called the window will determine its own title.  MesquiteWindows need	to be self-titling so that when things change (names of files, tree blocks, etc.)	they can reset their titles properly*/	public void resetTitle(){		String t;		if (treeSourceTask==null)			t = "Tree Window " + windowNum + " for taxa \"" +taxa.getName() + "\"";		else			t = "Tree Window " + windowNum + " showing " + treeSourceTask.getNameForMenuItem();		setTitle(t);	}	void setSuggestedSize(boolean  setToDefault, boolean togglepane){		Dimension s = treeDrawCoordTask.getPreferredSize();		if (s == null)			s = treeDisplay.getSize();		if (s != null && s.width == 0 | s.height == 0)			s = null;		oldPreferred = s;		if (!setToDefault && s != null) { //if treedrawer has perferred size then put here			sizeToFit.setValue(false);			totalTreeFieldWidth = s.width;			totalTreeFieldHeight = s.height;			toggleLegendFloat();		}		else {			boolean canFit = taxa == null || s == null;			canFit = canFit && taxa.getNumTaxa()<50;			if (!canFit && s != null){				if (treeDisplay.getOrientation()== TreeDisplay.UP || treeDisplay.getOrientation()== TreeDisplay.DOWN) 					canFit = canFit || taxa.getNumTaxa()*12<s.width;				else if (treeDisplay.getOrientation()== TreeDisplay.RIGHT || treeDisplay.getOrientation()== TreeDisplay.LEFT) 					canFit = canFit || taxa.getNumTaxa()*12<s.height;			}			if (!canFit) {				sizeToFit.setValue(false);				if (treeDisplay.getOrientation()== TreeDisplay.UP || treeDisplay.getOrientation()== TreeDisplay.DOWN) {					totalTreeFieldWidth = taxa.getNumTaxa()*12;  					totalTreeFieldHeight  = taxa.getNumTaxa()*6;				}				else if (treeDisplay.getOrientation()== TreeDisplay.RIGHT || treeDisplay.getOrientation()== TreeDisplay.LEFT) {					totalTreeFieldWidth = taxa.getNumTaxa()*6;  					totalTreeFieldHeight  = taxa.getNumTaxa()*12;				}				else  {					totalTreeFieldWidth = taxa.getNumTaxa()*8;  					totalTreeFieldHeight  = taxa.getNumTaxa()*8;				}				toggleLegendFloat();			}			else {				sizeToFit.setValue(true);			}		}		if (togglepane)			togglePane(false);		sizeDisplay();			}	public MesquiteCommand getUndoCommand() {		return undoCommand; 	}	public MesquiteCommand getCopySpecialCommand() {		return copyCommand; 	}	public String getCopySpecialName() {		return "Copy Tree"; 	}	public MesquiteCommand getPasteSpecialCommand() {		return pasteCommand; 	}	public String getPasteSpecialName() {		return "Paste Tree"; 	}	private void toggleLegendFloat(){		if (treePane == null || sizeToFit.getValue() || floatLegends.getValue()) { //legends can't float			checkPanelPositionsLegal();		}		else {  //undoing floating			//get bounds on visible part of treeDisplay  			Point pt = treePane.getScrollPosition();			Dimension dim = treePane.getViewportSize();			//cycle through all components getting those that are Legends 			Component[] cc = treeDisplay.getComponents();			if (cc!=null && cc.length>0)				for (int i=0; i<cc.length; i++) {					if (cc[i] instanceof Legend){						//use getOffsetX(); for current and 						//adjustLocation						Legend legend = (Legend)cc[i];						Rectangle rect  = legend.getBounds();						int newOffsetX = 0;						int newOffsetY = 0;						boolean done = false;						if (rect.x - pt.x > dim.width /2) {							//move legend to right border							legend.setOffsetX(treeDisplay.getBounds().width - dim.width + legend.getOffsetX());							done = true;						}						else {							//move legend to left border							legend.setOffsetX(legend.getOffsetX() - pt.x);							done = true;						}						if (rect.y - pt.y > dim.height/2){							//move legend to bottom border							legend.setOffsetY(treeDisplay.getBounds().height - dim.height + legend.getOffsetY());							done = true;						}						else {							//move legend to left border							legend.setOffsetY(legend.getOffsetY() - pt.y);							done = true;						}						if (done) 							legend.adjustLocation();					}				}			checkPanelPositionsLegal();		}	}	public void checkPanelPositionsLegal(){		if (treeDisplay == null)			return;		try {			if (treePane == null || sizeToFit.getValue() || !floatLegends.getValue()) { //legends can't float or aren't floating				Component[] cc = treeDisplay.getComponents();				if (cc!=null && cc.length>0)					for (int i=0; i<cc.length; i++) {						if (cc[i] instanceof Legend){ //make sure legends are in bounds							//adjustLocation							Legend legend = (Legend)cc[i];							legend.setConstrainingContainer(null);							legend.adjustLocation();						}					}			}			else {				//get bounds on visible part of treeDisplay  				Point pt = treePane.getScrollPosition();				Dimension dim = treePane.getViewportSize();				//cycle through all components getting those that are Legends 				Component[] cc = treeDisplay.getComponents();				if (cc!=null && cc.length>0)					for (int i=0; i<cc.length; i++) {						if (cc[i] instanceof Legend){							//use getOffsetX(); for current and 							//adjustLocation							Legend legend = (Legend)cc[i];							legend.setConstrainingContainer(treePane);							Rectangle rect  = legend.getBounds();							int amountX = 0;							int amountY = 0;							if (rect.x + rect.width> pt.x+dim.width) {								//move legend left								amountX = - rect.x - rect.width + (pt.x+dim.width);							}							else if (rect.x<pt.x) {								//move legend right								amountX = pt.x- rect.x;							}							if (amountX!= 0)								legend.setOffsetX(legend.getOffsetX()+amountX);							if (rect.y + rect.height> pt.y+dim.height){								//move legend up								amountY = -rect.y - rect.height + ( pt.y+dim.height);							}							else if (rect.y<pt.y) {								//move legend down								amountY = pt.y - rect.y;							}							if (amountY!= 0)								legend.setOffsetY(legend.getOffsetY()+amountY);							if (amountX!=0 || amountY!=0) {								legend.adjustLocation();							}						}					}			}		}		catch (Exception ex){		}	}	/*.................................................................................................................*/	public void adjustmentValueChanged(AdjustmentEvent e) {		try {			if (treePane!=null && !sizeToFit.getValue() && treeDisplay!=null && floatLegends.getValue()){				if (e == null){					int changeH = hAdjust.getValue() - oldH;					int changeV = vAdjust.getValue() - oldV;					if (changeH !=0 || changeV != 0){						Component[] cc = treeDisplay.getComponents();						if (cc!=null && cc.length>0)							for (int i=0; i<cc.length; i++) {								if (cc[i] instanceof Legend){									Legend legend = (Legend)cc[i];									legend.setOffsetX( legend.getOffsetX() + changeH);									legend.setOffsetY( legend.getOffsetY() + changeV);									legend.adjustLocation();								}							}					}					oldH = hAdjust.getValue();					oldV = vAdjust.getValue();				}				else {					Adjustable a = e.getAdjustable();					if (a == hAdjust){						int change = a.getValue() - oldH;						if (change !=0){							Component[] cc = treeDisplay.getComponents();							if (cc!=null && cc.length>0)								for (int i=0; i<cc.length; i++) {									if (cc[i] instanceof Legend){										Legend legend = (Legend)cc[i];										legend.setOffsetX( legend.getOffsetX() + change);										legend.adjustLocation();									}								}						}						oldH = a.getValue();					}					else if (a == vAdjust){						int change = a.getValue() - oldV;						if (change !=0){							Component[] cc = treeDisplay.getComponents();							if (cc!=null && cc.length>0)								for (int i=0; i<cc.length; i++) {									if (cc[i] instanceof Legend){										Legend legend = (Legend)cc[i];										legend.setOffsetY( legend.getOffsetY() + change);										legend.adjustLocation();									}								}						}						oldV = a.getValue();					}				}			}		}		catch (Exception ex){		}		checkPanelPositionsLegal();	}	/*.................................................................................................................*/	public void togglePane(boolean initiating) {		togglePane(initiating, true);	}	/*.................................................................................................................*/	public void togglePane(boolean initiating, boolean resetOrigin) {		if (!sizeToFit.getValue()) {			if (treePane==null || initiating) {				if (!initiating)					removeFromWindow(treeDisplay);				messageWidth=baseMessageWidth;				if (palette !=null && palette.birdsEyeBox!=null)					palette.birdsEyeBox.setVisible(true);				treePane = new TreeScrollPane(ScrollPane.SCROLLBARS_ALWAYS, this);				treePane.setLocation(0, 0);				hAdjust = treePane.getHAdjustable();				oldH = hAdjust.getValue();				hAdjust.addAdjustmentListener(this);				vAdjust = treePane.getVAdjustable();				oldV = vAdjust.getValue();				vAdjust.addAdjustmentListener(this);				treePane.addTreeDisplay(treeDisplay);				addToWindow(treePane);				sizeDisplay();				treePane.setScrollPosition(-initPosX, -initPosY);				if (palette!=null)					palette.setFieldSize(totalTreeFieldWidth, totalTreeFieldHeight);				sizeItem.setEnabled(true);				floatLegendsItem.setEnabled(true);				if (!initiating) {					ownerModule.resetContainingMenuBar();					treePane.setVisible(true);					treeDisplay.pleaseUpdate(true);					messagePanel.repaint();					//lockPanel.repaint();				}			}		}		else {			if (treePane!=null || initiating)  {				if (!initiating)					removeFromWindow(treePane);				if (hAdjust!=null)					hAdjust.removeAdjustmentListener(this);				hAdjust = null;				if (vAdjust!=null)					vAdjust.removeAdjustmentListener(this);				vAdjust = null;				treePane = null;				treeDisplay.setLocation(0, 0);				sizeDisplay();				addToWindow(treeDisplay);				palette.birdsEyeBox.setVisible(false);				if (sizeItem!=null)					sizeItem.setEnabled(false);				if (floatLegendsItem!=null)					floatLegendsItem.setEnabled(false);				if (!initiating) {					ownerModule.resetContainingMenuBar();					treeDisplay.pleaseUpdate(true);					messagePanel.repaint();					/*New code added Feb.07 oliver*/ //TODO: Delete new code comments					controlStrip.repaint();					/*End new code added Feb.07 oliver*/					//lockPanel.repaint();				}			}			if (resetOrigin)				setOrigin(0, 0);		}	}	/*.................................................................................................................*/	/** Called in some circumstances (not all) when a component is added to a container in the window.  Currently used so that	the Tree window knows that a component has been added to the TreeDisplay.*/	public void componentAdded(Container cont, Component comp){		checkPanelPositionsLegal();	}	public void setVisible(boolean v){		super.setVisible(v);		if (v){			treeDisplay.redoCalculations(89);			treeDisplay.repaint(true);		}	}	/*.................................................................................................................*/	void sizeDisplay(){		if (palette==null|| treeDisplay==null  ||messagePanel==null || sizeToFit == null)			return;		palette.setFieldSize(totalTreeFieldWidth,totalTreeFieldHeight);		if (sizeToFit.getValue()) {			treeDisplay.setSize(getWidth(),getHeight()-scrollWidth);			treeDisplay.setFieldSize(getWidth(),getHeight()-scrollWidth);			treeDisplay.redoCalculations(8813);		}		else {			int useWidth = MesquiteInteger.maximum(totalTreeFieldWidth, getWidth());			int useHeight = MesquiteInteger.maximum(totalTreeFieldHeight, getHeight()-scrollWidth);			//	treeDisplay.setFieldSize(totalTreeFieldWidth, totalTreeFieldHeight);			treeDisplay.setFieldSize(useWidth,useHeight);			treeDisplay.setSize(useWidth,useHeight);			treeDisplay.redoCalculations(88);			if (treePane!=null){				treePane.setSize(getWidth(),getHeight()-scrollWidth);				treePane.setVisible(true);				treePane.doLayout();			}		}		int CONTROLWIDTH = 42;		messageWidth = getWidth() - CONTROLWIDTH;		messagePanel.setLocation(CONTROLWIDTH, getHeight()-scrollWidth);		controlStrip.setLocation(0, getHeight()-scrollWidth);		controlStrip.setSize(CONTROLWIDTH, scrollWidth);		messagePanel.setSize(messageWidth,scrollWidth);		checkPanelPositionsLegal();		treeDisplay.forceRepaint();	}	/*.................................................................................................................*/	public Taxa getTaxa() {		return taxa;	}	/*.................................................................................................................*/	public void hideTree() {		treeDisplay.setVisible(false);	}	/*.................................................................................................................*/	public void showTree() {		treeDisplay.setVisible(true);	}	/*.................................................................................................................*/	public void setTreeSource(TreeSource tsTask) {		boolean setToZero = tsTask != treeSourceTask;		treeSourceTask = tsTask;		if (treeSourceTask.nameMatches("StoredTrees"))			storeTreeAsMenuItem.setName("Store Tree As...");		else			storeTreeAsMenuItem.setName("Store Copy of Tree As...");		resetTitle();		if (!MesquiteThread.isScripting()){			resetForTreeSource(setToZero, true);			contentsChanged();			treeDisplay.repaint();		}		else {			resetForTreeSource(setToZero, true);		}	}	/*.................................................................................................................*/	public void resetForTreeSource(boolean setToZero, boolean firstTimeTreeSource) {		if (firstTimeTreeSource)			warningGivenForTreeSource = false;		MesquiteTree editedTree = null;		if (taxa !=null && taxa.isDoomed()) {			ownerModule.iQuit();			return;		}		if (tree!=null) {			if (treeEdited && !firstTimeTreeSource)				editedTree = tree;			unhookPreviousTree();			if (!treeEdited || firstTimeTreeSource)				tree.dispose();		}		treeAnnotationShown = false;		//	tree=null; //done to catch spurious redraws		treeVersion = 0;		treeDisplay.setTree(null); //done to catch spurious redraws		palette.paletteScroll.setMinimumValue(MesquiteTree.toExternal(0)); 		int numTrees = treeSourceTask.getNumberOfTrees(taxa);		palette.paletteScroll.setMaximumValue(MesquiteTree.toExternal(numTrees-1)); 		if (setToZero || currentTreeNumber>= numTrees)			goToTreeNumber(0);		else			goToTreeNumber(currentTreeNumber);		if (editedTree!=null) {			//originalTree = null;			setTree(editedTree);			if (firstTimeTreeSource)				originalTree = null;			treeEdited(false);		}		storeTreeMenuItem.setEnabled(!treeSourceLocked());		//resetLockImage();		checkPanelPositionsLegal();		resetBaseExplanation();	}	public void numTreesChanged() {		if (taxa !=null && taxa.isDoomed()) {			ownerModule.iQuit();			return;		}		palette.paletteScroll.setMinimumValue(MesquiteTree.toExternal(0)); 		int numTrees = treeSourceTask.getNumberOfTrees(taxa);		palette.paletteScroll.setMaximumValue(MesquiteTree.toExternal(numTrees-1)); 		if (currentTreeNumber>= numTrees && MesquiteInteger.isCombinable(numTrees)) {			currentTreeNumber = numTrees -1;			goToTreeNumber(currentTreeNumber);		}		checkPanelPositionsLegal();		resetBaseExplanation();	}	/*.................................................................................................................*/	public void addAssistant(TreeDisplayAssistant tda) {		tda.setEmployeesInStartup(true);  // normally used only within EmployerEmployee, this helps assistants know they are still in startup phase		treeDrawCoordTask.addAssistantTask(tda);		TreeDisplayExtra tce = tda.createTreeDisplayExtra(treeDisplay);		if (tce==null) 			return;		if (tree != null)			tce.setTree(tree);		treeDisplay.addExtra(tce);		checkPanelPositionsLegal();		treeDisplay.pleaseUpdate(false);		if (getMode()>0)			updateTextPage();		tda.setEmployeesInStartup(false);	}	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot temp = new Snapshot();		temp.incorporate(super.getSnapshot(file), false);		temp.addLine("getTreeDrawCoordinator", treeDrawCoordTask);		temp.addLine("setTreeNumber " +(MesquiteTree.toExternal(currentTreeNumber)));  		if (treeEdited && tree!=null) {			temp.addLine("setTree " + StringUtil.tokenize(tree.writeTree(Tree.BY_NUMBERS, false))); 			if (!StringUtil.blank(tree.getAnnotation()))				temp.addLine("setTreeAnnotation " + StringUtil.tokenize(tree.getAnnotation())); 			if (file !=null && BasicTreeWindowMaker.warnUnsaved){				BasicTreeWindowMaker.warnUnsaved = false;				ownerModule.storePreferences();				String s = "The tree in a tree window has been edited, and is a temporary tree associated with the window.  ";				s += "The fact that it is a temporary tree is indicated by the tree window\'s bar toward the bottom that indicates the tree name with a black diamond.  ";				s += "If you haven\'t stored it in the file using Store Tree from the Tree menu, then this temporary tree won't be stored in a public part of the file, ";				s += "and other programs won't be able to see the tree.\nIf you want other programs to see a temporary tree in a tree window, use Store Tree then resave the file.";				ownerModule.alert(s);			}		}		temp.addLine("useSuggestedSize " + useSuggestedSize.toOffOnString());		if (!useSuggestedSize.getValue()){			temp.addLine("toggleSizeToFit " + sizeToFit.toOffOnString());			if (!sizeToFit.getValue()) {				temp.addLine("sizeDrawing " + totalTreeFieldWidth + " " + totalTreeFieldHeight);				temp.addLine("toggleLegendFloat " + floatLegends.toOffOnString());				temp.addLine("setOrigin " + getOriginX() + " " + getOriginY());			}		}		temp.addLine("toggleTextOnTree " + textVersionDrawOnTree.toOffOnString());		if (treeInfoPanelEverShown){			if (treeInfoPanel != null){				temp.addLine("getInfoPanel");				temp.addLine("tell It");				temp.incorporate(treeInfoPanel.getSnapshot(file), true);				temp.addLine("endTell");			}			temp.addLine("toggleInfoPanel " + infoPanelOn.toOffOnString());		}		temp.addLine("showWindow");		return temp;	}	/** Returns menu location for item to bring the window to the for (0 = custom or don't show; 1 = system area of Windows menu; 2 = after system area of Windows menu)*/	public int getShowMenuLocation(){		return 0;	}	/*.................................................................................................................*/	public String getPrintMenuItem() {		return "Print Tree...";	}	/*.................................................................................................................*/	public String getPrintToFitMenuItemName() {		return "Print Tree To Fit Page...";	}	/*.................................................................................................................*/	/**	 * @author Peter Midford 	 */	public void windowToPDF(MesquitePDFFile pdfFile, int fitToPage) {		if (pdfFile != null) {			if (infoBar.getMode()>0)				super.windowToPDF(pdfFile, fitToPage);			else {				Graphics g2 = pdfFile.getPDFGraphicsForComponent(treeDisplay,null);				treeDisplay.printAll(g2);				pdfFile.end();			}		}	}	/*.................................................................................................................*/	/**	 * @author Peter Midford	 */	public String getPrintToPDFMenuItemName() {		return "Save Tree as PDF...";	}	/*.................................................................................................................*/	public void printWindow(MesquitePrintJob pjob) {		if (pjob != null) {			if (infoBar.getMode()>0) 				super.printWindow(pjob);			else 				pjob.printComponent(treeDisplay, null, currentFont);		}	}	/*.................................................................................................................*/	public void setCurrentTool(MesquiteTool tool){		if (tool!=null && !tool.getEnabled())			return;		if (tool instanceof TreeTool)			currentTreeTool = (TreeTool)tool;		super.setCurrentTool(tool);	}	/*...............................................................................................................*/	protected void setContentsCursor(Cursor c){		if (c == null)			MesquiteMessage.printStackTrace("Error: cursor of tree window null");		else if (treeDisplay !=null)			treeDisplay.setCursor(c);	}	/*.................................................................................................................*/	MesquiteInteger pos = new MesquiteInteger();	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Hires a tree display assistant module", "[name of assistant module]", commandName, "newAssistant")) {			ownerModule.incrementMenuResetSuppression();			TreeDisplayAssistant tda= (TreeDisplayAssistant)ownerModule.hireNamedEmployee(TreeDisplayAssistant.class, arguments);			if (tda!=null) {				addAssistant(tda);				if (!MesquiteThread.isScripting())					ownerModule.resetContainingMenuBar();			}			ownerModule.decrementMenuResetSuppression();			return tda;		}		else if (checker.compare(this.getClass(), "Returns the tree info panel", null, commandName, "getInfoPanel")) {			return treeInfoPanel;		}		else if (checker.compare(this.getClass(), "Selects taxon", "[number of taxon]", commandName, "selectTaxon")) {			int which = MesquiteInteger.fromFirstToken(arguments, pos);			if (which >= 0 && which < taxa.getNumTaxa()){				taxa.setSelected(which, !taxa.getSelected(which));				taxa.notifyListeners(this, new Notification(MesquiteListener.SELECTION_CHANGED));				makeTaxonVisible(which);			}			return null;		}		else if (checker.compare(this.getClass(), "Returns the tree draw coordinating module", null, commandName, "getTreeDrawCoordinator")) {			return treeDrawCoordTask;		}		else if (checker.compare(this.getClass(), "Forces a repaint", null, commandName, "forceRepaint")) {			treeDisplay.redoCalculations(33);			treeDisplay.forceRepaint();		}		else if (checker.compare(this.getClass(), "Hires a tree window assistant module", "[name of assistant module]", commandName, "newWindowAssistant")) {			TreeWindowAssistant tda= (TreeWindowAssistant)ownerModule.hireNamedEmployee(TreeWindowAssistant.class, arguments);			if (tda!=null && tree != null)				tda.setTree(tree);			return tda;		}		else if (checker.compare(this.getClass(), "Returns the tree", null, commandName, "getTree")) {			return tree;		}		else if (checker.compare(this.getClass(), "Brings the graphics of an assistant module to the front", "[number of assistant module among TreeDisplayDrawnExtra owners]", commandName, "bringToFront")) {			int which = MesquiteInteger.fromFirstToken(arguments, pos);			if (!MesquiteInteger.isCombinable(which))				return null;			ListableVector ev = treeDisplay.getExtras();			int count =0;			for (int i=0; i< ev.size(); i++){				TreeDisplayExtra extra = (TreeDisplayExtra)ev.elementAt(i);				if (extra!=null && extra instanceof TreeDisplayDrawnExtra) {					if (count== which) {						TreeDisplayExtra found = extra;						ownerModule.moveEmployeeToFront(extra.getOwnerModule());						treeDisplay.moveExtraToFront(extra);						ownerModule.resetContainingMenuBar();						return null;					}					count++;				}			}		}		else if (checker.compare(this.getClass(), "Closes an assistant module", "[number of assistant module]", commandName, "closeDisplayAssistant")) {			EmployeeVector ev = ownerModule.getEmployeeVector();			int which = MesquiteInteger.fromFirstToken(arguments, pos);			if (!MesquiteInteger.isCombinable(which))				return null;			int count =0;			for (int i=0; i< ev.size(); i++){				MesquiteModule mb = (MesquiteModule)ev.elementAt(i);				if (mb!=null && mb instanceof TreeDisplayAssistantAD) {					if (count== which) {						ownerModule.fireEmployee(mb);						return null;					}					count++;				}			}		}		else if (checker.compare(this.getClass(), "Saves a macro to redo the analysis of an assistant module", "[number of assistant module]", commandName, "saveMacroDisplayAssistant")) {			EmployeeVector ev = ownerModule.getEmployeeVector();			int which = MesquiteInteger.fromFirstToken(arguments, pos);			if (!MesquiteInteger.isCombinable(which))				return null;			int count =0;			for (int i=0; i< ev.size(); i++){				MesquiteModule mb = (MesquiteModule)ev.elementAt(i);				if (mb!=null && mb instanceof TreeDisplayAssistantAD) {					if (count== which) {						String recipe = "newAssistant #" + mb.getClass().getName() + ";" + StringUtil.lineEnding() + "tell It;"+ StringUtil.lineEnding();						recipe += Snapshot.getSnapshotCommands(mb, null, "");						recipe += "endTell;"+ StringUtil.lineEnding();						MesquiteMacro.saveMacro(ownerModule, "Macro to start " + mb.getNameForMenuItem(), 0, recipe);						return null;					}					count++;				}			}		}		else if (checker.compare(this.getClass(), "Sets the tree as having been edited (e.g. so that it can be treated as \"untitled\")", null, commandName, "treeEdited")) {			treeEdited(true);			treeChanged( true);			setTreeName();			setExplanation(baseExplanation, true);			if (getMode()>0)				updateTextPage();		}		/*   	 	else if (checker.compare(this.getClass(), "Sets the tree to that described by the string passed, and presented in a standard rotation.", null, commandName, "setStandardizedTree")) {     	 		Tree t = setTree(ParseUtil.getFirstToken(arguments, pos));    	 		if (t instanceof MesquiteTree)    	 			((MesquiteTree)t).standardize(t.getRoot(),false);    	 		if (t!=null){    	 			treeEdited(true);    	 			setTreeName();    	 			return t;    	 		}    	 	}		 */		else if (checker.compare(this.getClass(), "Sets the tree to that described by the string passed", "[Parenthesis notation string of tree]", commandName, "setTree")) {			String descr = ParseUtil.getFirstToken(arguments, pos);			Tree t = setTree(descr);  // process the tree fully, including [%color = 4]			if (t!=null){				treeEdited(true);				setTreeName();				return t;			}		}		else if (checker.compare(this.getClass(), "Sets the tree to a recently edited tree", "[number of edited tree]", commandName, "showRecentEdited")) {			int r = MesquiteInteger.fromFirstToken(arguments, pos);			if (MesquiteInteger.isCombinable(r) && r < recentEditedTrees.size()) {				setCloneOfTree(recentEditedTrees.getTree(r), false);				treeEdited(false);				setTreeName();			}		}		else if (checker.compare(this.getClass(), "Shows the window", null, commandName, "showWindow")) {			setVisible(true);			if (useSuggestedSize.getValue())				setSuggestedSize(false, true);		}		else if (checker.compare(this.getClass(), "Sets the annotation for the current tree", "[Annotation for tree in window]", commandName, "setTreeAnnotation")) {			String note = ParseUtil.getFirstToken(arguments, pos);			if (tree!=null && treeEdited) {				tree.setAnnotation(note, true);				showTreeAnnotation();			}		}		else if (checker.compare(this.getClass(), "Returns the number of trees", null, commandName, "getNumTrees")) {			return new MesquiteInteger(treeSourceTask.getNumberOfTrees(taxa));		}		else if (checker.compare(this.getClass(), "Returns the current tree number", null, commandName, "getTreeNumber")) {			return new MesquiteInteger(currentTreeNumber);		}		else if (checker.compare(this.getClass(), "Sets the tree to be the i'th one from the current tree source", "[number of tree to be shown]", commandName, "setTreeNumber")) {			return goToTreeNumber(MesquiteTree.toInternal(MesquiteInteger.fromFirstToken(arguments, pos)));		}		else if (checker.compare(this.getClass(), "Present a dialog box to choose a tree from the current tree source", null, commandName, "chooseTree")) {			int ic=treeSourceTask.queryUserChoose(taxa, "for tree window");			if (MesquiteInteger.isCombinable(ic)) {				return goToTreeNumber(ic);			}		}		else if (checker.compare(this.getClass(), "Stores the current tree as a new stored tree in a tree block", null, commandName, "storeTreeAs")) {			MesquiteTree tree = treeDisplay.getTree().cloneTree();			//if treeSourceTask is Stored Trees, and tree is saved into same block as being shown, then should change current tree to that one and jump to there???			String s = ParseUtil.getFirstToken(arguments, new MesquiteInteger(0));			if (StringUtil.blank(s))				s = MesquiteString.queryString(this, "Store Tree As" , "Name of tree: ", tree.getName() );			if (s!=null) {				tree.setName(s);				TreeVector trees =  ownerModule.getProject().storeTree(this, tree);				if (trees!=null) {					TreesManager manager = (TreesManager)ownerModule.findElementManager(TreeVector.class);					if (manager !=null){						int listNum = manager.getTreeBlockNumber(trees);						if (showTreeListOnSave)							manager.doCommand("showTrees", Integer.toString(listNum), checker);						showTreeListOnSave = false;						if (treeSourceTask!=null && "Stored Trees".equalsIgnoreCase(treeSourceTask.getName())){							TreeVector v = (TreeVector)treeSourceTask.doCommand("getTreeBlock", null, CommandChecker.defaultChecker);							if (v == trees) {								goToTreeNumber(trees.size()-1);							}						}						return trees;					}				}				/*TreeVector trees=null;				TreesManager manager = (TreesManager)ownerModule.findElementManager(TreeVector.class);				if (manager !=null){		    	 		int numLists = manager.getNumberTreeBlocks(tree.getTaxa());					int listNum = 0;					if (numLists==0) {	    	 				String treesListName = MesquiteString.queryString(this, "New Tree Block" , "Name of new Tree Block: ", "Untitled Tree Block");						MesquiteFile f = ownerModule.getProject().chooseFile(  "In which file should new tree block be placed?");  						trees = manager.makeNewTreeBlock(tree.getTaxa(), treesListName, f);					}					else if (numLists == 1){		    	 			trees = manager.getTreeBlock(tree.getTaxa(), 0);					}					else {		    	 			Listable[] lists = new Listable[numLists];		    	 			for (int i=0; i<numLists; i++)		    	 				lists[i] = manager.getTreeBlock(tree.getTaxa(), i);						Object obj = ListDialog.queryList(this, "Where to store tree?", "Choose tree block in which to store tree:",MesquiteString.helpString, lists, 0);						trees = (TreeVector)obj;	    	 			}	    	 			if (trees!=null) {						listNum = manager.getTreeBlockNumber(trees);	    	 				trees.addElement(tree, true);	    	 				if (showTreeListOnSave)	    	 					manager.doCommand("showTrees", Integer.toString(listNum), checker);	    	 				showTreeListOnSave = false;	    	 				if (treeSourceTask!=null && "Stored Trees".equalsIgnoreCase(treeSourceTask.getName())){	    	 					TreeVector v = (TreeVector)treeSourceTask.doCommand("getTreeBlock", null, CommandChecker.defaultChecker);	    	 					if (v == trees) {	    	 						goToTreeNumber(trees.size()-1);	    	 					}	    	 				}	    	 				return tree;	    	 			}    	 			}				 */			} 		}		else if (checker.compare(this.getClass(), "Stores the current tree back into the original stored tree from which it came", null, commandName, "storeTree")) {			//Tree tree = basicTreeWindow.tree; //should get this straight from tree window!!!!!!!			if (treeSourceLocked())				return null;			if (originalTree!=null && treeEdited) {				((MesquiteTree)originalTree).setToClone(tree);				((MesquiteTree)originalTree).notifyListeners(this, new Notification(MesquiteListener.BRANCHES_REARRANGED));				if (((MesquiteTree)originalTree).getTreeVector() !=null)					((MesquiteTree)originalTree).getTreeVector().notifyListeners(this, new Notification(MesquiteListener.PARTS_CHANGED));				messagePanel.setHighlighted(false, !treeSourceLocked());				if (treeInfoPanel != null)					treeInfoPanel.setHighlighted(false, !treeSourceLocked());				treeEdited=false;				resetBaseExplanation();			}			return originalTree;		}		else if (checker.compare(this.getClass(), "Gets tree vector being shown.", null, commandName, "getTreeVector")) {			if (originalTree!=null && ((MesquiteTree)originalTree).getTreeVector() !=null)				return ((MesquiteTree)originalTree).getTreeVector();		}		else if (checker.compare(this.getClass(), "Goes to the next tree in the tree source.  THIS RUNS ON GUI THREAD.", null, commandName, "nextTree")) {			palette.paletteScroll.increment();		}		else if (checker.compare(this.getClass(), "Goes to the previous tree in the tree source.  THIS RUNS ON GUI THREAD.", null, commandName, "previousTree")) {			palette.paletteScroll.decrement();		}		else if (checker.compare(this.getClass(), "Steps through the trees.", null, commandName, "stepThroughTrees")) {			stepThroughTrees();		}		else if (checker.compare(this.getClass(), "Goes to the next tree in the tree source.", null, commandName, "goToNextTree")) {			incrementTreeNumber();		}		else if (checker.compare(this.getClass(), "Undoes the previous tree change", null, commandName, "undo")) {			if (undoTree !=null && canUndo && undoTree.upToDateWithTaxa()) {				setCloneOfTree(undoTree, false);				treeEdited(false);				return tree;			}		}		else if (checker.compare(this.getClass(), "Copies a description of the tree", null, commandName, "copyTree")) {			if (tree != null) {				Clipboard clip = Toolkit.getDefaultToolkit().getSystemClipboard();				StringSelection ss = new StringSelection(tree.writeTree(Tree.BY_NAMES, false));				clip.setContents(ss, ss);			}		}		else if (checker.compare(this.getClass(), "Pastes a description of the tree", null, commandName, "Paste")) {			if (tree != null) {				Clipboard clip = Toolkit.getDefaultToolkit().getSystemClipboard();				Transferable t = clip.getContents(this);				try {					String s = (String)t.getTransferData(DataFlavor.stringFlavor);					Tree tr = setTree(s);					if (tr!=null) {						treeEdited(true);						return tr;					}				}				catch (Exception e){				}			}		}		else if (checker.compare(this.getClass(), "Hires a module to alter or transform branch lengths", "[name of module]", commandName, "alterBranchLengths")) {			BranchLengthsAlterer ble = (BranchLengthsAlterer)ownerModule.hireNamedEmployee(BranchLengthsAlterer.class, arguments);			if (ble!=null) {				boolean success = ble.transformTree(tree, null, true);				if (success){					if (treeSourceLocked())						tree.setName("Untitled Tree");					treeEdited(false);				}				ownerModule.fireEmployee(ble); //todo: for branch length estimators, might be good to keep it around, and remembering it if user wants to change parameters			}		}		else if (checker.compare(this.getClass(), "Hires a module to alter the tree", "[name of module]", commandName, "alterTree")) {			TreeAlterer ble = (TreeAlterer)ownerModule.hireNamedEmployee(TreeAlterer.class, arguments);			if (ble!=null) {				boolean success = ble.transformTree(tree, null, true);				if (success){					if (treeSourceLocked())						tree.setName("Untitled Tree");					treeEdited(false);				}				ownerModule.fireEmployee(ble); 			}		}		else if (checker.compare(this.getClass(), "Requests that the tree is drawn to a default (suggested) size", null, commandName, "useSuggestedSize")) {			useSuggestedSize.toggleValue(ParseUtil.getFirstToken(arguments, pos));			if (useSuggestedSize.getValue()) {				setSuggestedSize(false, true);			}			else				setSuggestedSize(true, false);// reset to default suggested size in case prevous suggested size was ridiculous			treeDisplay.pleaseUpdate(false);		}		else if (checker.compare(this.getClass(), "Toggles whether the info panel is on", null, commandName, "toggleInfoPanel")) {			infoPanelOn.toggleValue(ParseUtil.getFirstToken(arguments, pos));			setTreeInfoPanel(infoPanelOn.getValue());		}		else if (checker.compare(this.getClass(), "Sets whether or not the tree is drawn so as to fit within the window, or so as to fit within a scrollable pane", "[on or off to indicate whether constrained to window]", commandName, "toggleSizeToFit")) {			boolean current = sizeToFit.getValue();			useSuggestedSize.setValue(false);			pos.setValue(0);			sizeToFit.toggleValue(ParseUtil.getFirstToken(arguments, pos));			if (current!=sizeToFit.getValue()) {				if (current && !MesquiteThread.isScripting())					doCommand("sizeDrawing", null, checker);				togglePane(false);			}		}		else if (checker.compare(this.getClass(), "When Size to Window is false, brings legends into view", null, commandName, "toggleLegendFloat")) {			boolean current = floatLegends.getValue();			pos.setValue(0);			floatLegends.toggleValue(ParseUtil.getFirstToken(arguments, pos));			if (current != floatLegends.getValue())				toggleLegendFloat();			else				checkPanelPositionsLegal();		}		else if (checker.compare(this.getClass(), "In Text version of window, controls whether extras like trace character show their information directly on a tree or as a list of nodes", null, commandName, "toggleTextOnTree")) {			boolean current = textVersionDrawOnTree.getValue();			pos.setValue(0);			textVersionDrawOnTree.toggleValue(ParseUtil.getFirstToken(arguments, pos));			if (current != textVersionDrawOnTree.getValue()) {				treeDisplay.textVersionDrawOnTree = textVersionDrawOnTree.getValue();				if (getMode()>0)					updateTextPage();			}		}		else if (checker.compare(this.getClass(), "Sets the size of the drawing pane area (only useful if Size To Fit is turned off)", "[width in pixels of drawing area] [height in pixels of drawing area]", commandName, "sizeDrawing")) {			pos.setValue(0);			int w = MesquiteInteger.fromString(arguments, pos);			int h = MesquiteInteger.fromString(arguments, pos);			if (MesquiteInteger.isCombinable(h)  ||  MesquiteInteger.isCombinable(w)) {				boolean resize = false;				if (MesquiteInteger.isCombinable(h) && h>10) {					totalTreeFieldHeight = h;					resize = true;				}				if (MesquiteInteger.isCombinable(w) && w>10) {					totalTreeFieldWidth = w;					resize = true;				}				if (resize) {					sizeDisplay();				}			}			else { 				MesquiteBoolean answer = new MesquiteBoolean(false);				MesquiteInteger newWidth = new MesquiteInteger(totalTreeFieldWidth);				MesquiteInteger newHeight =new MesquiteInteger(totalTreeFieldHeight);				MesquiteInteger.queryTwoIntegers(ownerModule.containerOfModule(), "Size of tree drawing", "Width (Pixels)",  "Height (Pixels)", answer,  newWidth, newHeight,10,MesquiteInteger.unassigned,10, MesquiteInteger.unassigned,"Enter the width and height of the tree drawing.  These values must be at least 10 pixels each.");				if (answer.getValue() && newWidth.getValue()>10 && newHeight.getValue()>10) {					totalTreeFieldWidth = newWidth.getValue();					totalTreeFieldHeight = newHeight.getValue();					sizeDisplay();				}			}		}		else if (checker.compare(this.getClass(), "Sets size of tree window", "[width in pixels of window] [height in pixels of window]", commandName, "setSize")) {			MesquiteInteger io = new MesquiteInteger(0);			int width= MesquiteInteger.fromString(arguments, io);			int height= MesquiteInteger.fromString(arguments, io);			if (MesquiteInteger.isCombinable(width) && MesquiteInteger.isCombinable(height)) {				fromScriptCommand = true;  //this is needed to counteract difficulties with popping in/out and size setting in window constructors				setWindowSize(width, height);				fromScriptCommand = false;				sizeDisplay();				treeDisplay.redoCalculations(355);				treeDisplay.forceRepaint();			}		}		else if (checker.compare(this.getClass(), "Sets the origin for the scrolling area", "[origin x] [origin y]", commandName, "setOrigin")) {			pos.setValue(0);			int horiz = MesquiteInteger.fromString(arguments, pos);			int vert = MesquiteInteger.fromString(arguments, pos);			if (MesquiteInteger.isCombinable(horiz) && MesquiteInteger.isCombinable(vert)) {				setOrigin(horiz, vert);			}		}		else if (checker.compare(this.getClass(), "Sets the current tool", "[name of tool]", commandName, "setTool")) {			ToolPalette palette = getPalette();			if (palette ==null)				return null;			currentTreeTool = (TreeTool)palette.getToolWithName(arguments);			setCurrentTool(currentTreeTool);			setExplanation(currentTreeTool.getDescription());		}		else if (checker.compare(this.getClass(), "Root current tree along branch", "[branch number]", commandName, "rootAlongBranch")) {			MesquiteInteger io = new MesquiteInteger(0);			int atBranch= MesquiteInteger.fromString(arguments, io);			if (atBranch >0 &&  tree.reroot(atBranch, tree.getRoot(), true)) {				treeEdited(false);			}		}		else if (checker.compare(this.getClass(), "Move one branch onto another", "[branch being moved] [branch onto which first will be attached]", commandName, "moveBranch")) {			MesquiteInteger io = new MesquiteInteger(0);			int branchFrom= MesquiteInteger.fromString(arguments, io);			int branchTo= MesquiteInteger.fromString(arguments, io);			if (branchFrom >0 && branchTo >0 &&  (tree.moveBranch(branchFrom, branchTo, true))) {				treeEdited(false);			}		}		/* cut out as of 1.02; shifted to SelectTaxaInClade    	 	else if (checker.compare(this.getClass(), "Touch a taxon in the tree window", "[taxon touched] [branch onto which first will be attached]", commandName, "touchTaxon")) {   	 		MesquiteInteger io = new MesquiteInteger(0);   			int touched= MesquiteInteger.fromString(arguments, io);   			if (touched >=0 && MesquiteInteger.isCombinable(touched)) {   				if (arguments.indexOf("shift") >=0) {  					taxa.setSelected(touched, !taxa.getSelected(touched));  //reverse selection of touched taxon   					taxa.notifyListeners(this, new Notification(MesquiteListener.SELECTION_CHANGED));   				}   				else {   					taxa.deselectAll();   					taxa.setSelected(touched, true);   					taxa.notifyListeners(this, new Notification(MesquiteListener.SELECTION_CHANGED));   				}   			}    	 	}*/		else if (checker.compare(this.getClass(), "Exchange two branches", "[first branch number] [second branch number]", commandName, "exchangeBranches")) {			pos.setValue(0);			int branchFrom= MesquiteInteger.fromString(arguments,pos);			int branchTo= MesquiteInteger.fromString(arguments,pos);			boolean preserveHeights = (arguments.indexOf("option")>=0);			if (branchFrom >0 && branchTo >0 &&  (tree.interchangeBranches(branchFrom, branchTo, preserveHeights, true)))				treeEdited(false);		}		else if (checker.compare(this.getClass(), "Magnify clade descendant from node", "[node number]", commandName, "magnifyClade")) {			int branchFound= MesquiteInteger.fromFirstToken(arguments, pos);			if (branchFound >0 && tree.nodeIsInternal(branchFound)) {				if (branchFound == treeDisplay.getTreeDrawing().getDrawnRoot())					treeDisplay.getTreeDrawing().setDrawnRoot(-1);				else					treeDisplay.getTreeDrawing().setDrawnRoot(branchFound);				treeDisplay.pleaseUpdate(true);				messagePanel.repaint();			}		}		else if (checker.compare(this.getClass(), "Zoom image", "[branch][x][y]", commandName, "zoomB")) {			int branchFound= MesquiteInteger.fromFirstToken(arguments, pos);			int x= MesquiteInteger.fromString(arguments, pos);			int y= MesquiteInteger.fromString(arguments, pos);			boolean zoomIn = (arguments.indexOf("option")<0);			zoom(x,y, zoomIn);		}		else if (checker.compare(this.getClass(), "Zoom image", "[x][y]", commandName, "zoom")) {			int x= MesquiteInteger.fromFirstToken(arguments, pos);			int y= MesquiteInteger.fromString(arguments, pos);			boolean zoomIn = (arguments.indexOf("option")<0);			zoom(x,y, zoomIn);		}		else if (checker.compare(this.getClass(), "Ladderizes the clade", "[branch number]", commandName, "ladderize")) {			Parser parser = new Parser();			String s = parser.getFirstToken(arguments);			int branchFound= MesquiteInteger.fromString(s);			if (s.equalsIgnoreCase("root"))				branchFound = tree.getRoot();			else				branchFound= MesquiteInteger.fromString(s);			if (branchFound >0) {				boolean direction = true;				if (arguments.indexOf("option")>=0)					direction = false;				if (tree.standardize(branchFound, direction, true)){					treeEdited(false);				}			}		}		else if (checker.compare(this.getClass(), "Ladderizes the clade with focal taxon at left or right", "[taoxn number]", commandName, "focalLadderize")) {			int taxonFound= MesquiteInteger.fromFirstToken(arguments, pos);			if (taxonFound >=0) {				boolean direction = true;				if (arguments.indexOf("option")>=0)					direction = false;				if (tree.focalStandardize(taxonFound, direction, true)){					treeEdited(false);				}			}		}		else if (checker.compare(this.getClass(), "Collapse branch to yield polytomy", "[branch number]", commandName, "collapseBranch")) {			int branchFound= MesquiteInteger.fromFirstToken(arguments, pos);			if (branchFound >0 && (tree.collapseBranch(branchFound, true)))				treeEdited(false);		}		else if (checker.compare(this.getClass(), "Collapse all internal branches in clade descendant from node", "[node number]", commandName, "collapseAll")) {			int branchFound= MesquiteInteger.fromFirstToken(arguments, pos);			if (branchFound >0) {				boolean below = false;				if (arguments.indexOf("option")>=0)					below = true;				if (tree.collapseAllBranches(branchFound, below,true))					treeEdited(false);			}		}		else if (checker.compare(this.getClass(), "Draw clade descendant from node compactly as a triangle", "[node number]", commandName, "drawAsTriangle")) {			int branchFound= MesquiteInteger.fromFirstToken(arguments, pos);			if (branchFound >0 && tree.nodeIsInternal(branchFound) && tree.getRoot()!=branchFound) {				NameReference triangleNameRef = NameReference.getNameReference("triangled");				if (tree.getWhichAssociatedBits(triangleNameRef) == null)					tree.makeAssociatedBits("triangled");				tree.setAssociatedBit(triangleNameRef, branchFound, !(tree.getAssociatedBit(triangleNameRef, branchFound)));				treeDisplay.pleaseUpdate(true);			}		}		else if (checker.compare(this.getClass(), "Cut clade descendant from node", "[node number]", commandName, "cutClade")) {			int branchFound= MesquiteInteger.fromFirstToken(arguments, pos);			if (branchFound >0) {				if (tree.deleteClade(branchFound, true)) {					treeEdited(false);				}			}		}		else if (checker.compare(this.getClass(), "Cuts selected taxa from the tree", null, commandName, "cutSelectedTaxa")) {			boolean changed = false;			for (int i = 0; i< taxa.getNumTaxa(); i++){				int node = tree.nodeOfTaxonNumber(i);				if (tree.nodeExists(node) && taxa.getSelected(i)){					tree.deleteClade(node, false);					changed = true;				}			}			if (changed) {				tree.notifyListeners(this, new Notification(MesquiteListener.PARTS_DELETED));				treeEdited(false);			}		}		else if (checker.compare(this.getClass(), "Shows the list of taxa", null, commandName, "showTaxaList")) {			tree.getTaxa().showMe();		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	void stepThroughTrees(){		int numW = numberWritable();		if (numW == 0) {			ownerModule.discreetAlert("Step Through Trees summarizes calculations over a series of trees, but you currently have no calculations active that can be summarized.  \"Values\" in the tree info panel, \"Values for Current Tree\", \"Trace Character History\" and some other calculations can be summarized. (Not all calculations have been enabled for summarizing.)");			return;		}		//if tree is edited, save it		String returnTree = null;		int iCT = currentTreeNumber;		if (treeEdited){			returnTree = tree.writeTree(Tree.BY_NUMBERS, false);		}		Listable[] list = null;		//ask to choose results if multiple writables; if only 1 explain that trees will be cycled. 		if (numW>1){			ListableVector lv = new ListableVector();			for (int i = 0; i<ownerModule.getNumberOfEmployees(); i++) {				Object e=ownerModule.getEmployeeVector().elementAt(i);				if (e instanceof TreeWDIAssistant) {					TreeWDIAssistant ta = (TreeWDIAssistant)e;					if (ta.suppliesWritableResults()){						ObjectContainer oc = new ObjectContainer();						oc.setObject(ta);						oc.setName(ta.nameForWritableResults());						lv.addElement(oc, false);					}				}			}			list = ListDialog.queryListMultiple(this, "Whose results to save?", "You have asked to step through the trees, storing the results of calculations in a text file.  Whose results should be saved in this way?  Choose one or more.", null, lv, null);		}		else {			list = new Listable[1];			for (int i = 0; i<ownerModule.getNumberOfEmployees(); i++) {				Object e=ownerModule.getEmployeeVector().elementAt(i);				if (e instanceof TreeWDIAssistant) {					TreeWDIAssistant ta = (TreeWDIAssistant)e;					if (ta.suppliesWritableResults()){						ObjectContainer oc = new ObjectContainer();						oc.setObject(ta);						list[0] = oc;						break;					}				}			}			ownerModule.discreetAlert("You have asked to step through the trees, storing the results of calculations in a text file.  The results that will be stored are from " + list[0].getName());		}		if (list == null)			return;		int numTrees = treeSourceTask.getNumberOfTrees(taxa);		//if infinite number of trees, ask how many		if (MesquiteInteger.isInfinite(numTrees)){			numTrees = MesquiteInteger.queryInteger(this, "How many trees?", "The tree source for this tree window has unlimited trees.  How many trees do you want to step through?", 100);			if (!MesquiteInteger.isCombinable(numTrees))				return;		}		//choose output file		MesquiteFileDialog fdlg= new MesquiteFileDialog(this, "Output File for Step Through Trees", FileDialog.SAVE);		fdlg.setBackground(ColorTheme.getInterfaceBackground());		fdlg.setVisible(true);		String fileName=fdlg.getFile();		String directory=fdlg.getDirectory();		// fdlg.dispose();		if (StringUtil.blank(fileName) || StringUtil.blank(directory))			return;		MesquiteFile.putFileContents(MesquiteFile.composePath(directory, fileName), "Output from Step Through Trees" + StringUtil.lineEnding(), false);		//write heading		for (int i = 0; i<list.length; i++) {			ObjectContainer econtainer = (ObjectContainer)list[i];			Object e=econtainer.getObject();			if (e instanceof TreeWDIAssistant) {				TreeWDIAssistant ta = (TreeWDIAssistant)e;				if (ta.suppliesWritableResults()){					Object tH = ta.getResultsHeading();					String s;					if (tH instanceof String)						s = (String)tH;					else if (tH instanceof MesquiteNumber){						MesquiteNumber mn = (MesquiteNumber)tH;						s = mn.toStringNames();					}					else						s = tH.toString();					MesquiteFile.appendFileContents(MesquiteFile.composePath(directory, fileName), "\t" + s, false);				}			}		}		MesquiteFile.appendFileContents(MesquiteFile.composePath(directory, fileName), StringUtil.lineEnding(), false);		for (int iTree = 0; iTree<numTrees; iTree++){			goToTreeNumber(iTree);			MesquiteFile.appendFileContents(MesquiteFile.composePath(directory, fileName), "Tree " + (iTree+1), false);			for (int i = 0; i<list.length; i++) {				ObjectContainer econtainer = (ObjectContainer)list[i];				Object e=econtainer.getObject();				if (e instanceof TreeWDIAssistant) {					TreeWDIAssistant ta = (TreeWDIAssistant)e;					if (ta.suppliesWritableResults()){						Object tO = ta.getWritableResults();						String s;						if (tO instanceof String)							s = (String)tO;						else if (tO instanceof MesquiteNumber){							MesquiteNumber mn = (MesquiteNumber)tO;							s = mn.toStringWithDetails();						}						else							s = tO.toString();						MesquiteFile.appendFileContents(MesquiteFile.composePath(directory, fileName), "\t" + s, false);					}				}			}			MesquiteFile.appendFileContents(MesquiteFile.composePath(directory, fileName), StringUtil.lineEnding(), false);			if (!MesquiteInteger.isCombinable(numTrees))				numTrees = treeSourceTask.getNumberOfTrees(taxa);		}		//return tree to former state		goToTreeNumber(iCT);		if (returnTree != null) {			setTree(returnTree);			treeEdited(false);			treeChanged(true);		}		treeDisplay.redoCalculations(6519);		treeDisplay.repaint();	}	int numberWritable(){		int count = 0;		for (int i = 0; i<ownerModule.getNumberOfEmployees(); i++) {			Object e=ownerModule.getEmployeeVector().elementAt(i);			if (e instanceof TreeWDIAssistant) {				TreeWDIAssistant ta = (TreeWDIAssistant)e;				if (ta.suppliesWritableResults()){					count++;				}			}		}		return count;	}	/*.................................................................................................................*/	void zoom(int x, int y, boolean zoomIn){		boolean current = sizeToFit.getValue();		int oX = getOriginX();		int oY = getOriginY();		useSuggestedSize.setValue(false);		int tW, tH;		if (current){			tW = treeDisplay.getBounds().width;			tH = treeDisplay.getBounds().height;		}		else {			tW = totalTreeFieldWidth;			tH = totalTreeFieldHeight;		}		pos.setValue(0);		if (current)			sizeToFit.setValue(false);		int newWidth, newHeight;		if (zoomIn){			newWidth = tW*2;			newHeight = tH*2;		}		else {			newWidth = tW/2;			newHeight = tH/2;		}		totalTreeFieldWidth = newWidth;		totalTreeFieldHeight = newHeight;		sizeDisplay();		togglePane(false, false);		int setX, setY;		if (zoomIn) {			setX = oX-x;			setY = oY-y +scrollWidth; //why is this needed?		}		else {			setX = oX+x/2;			setY = oY+y/2;		}		/*			if (zoomIn)				setOrigin(-(x+ 2*oX),-(y+2*oY));			else				setOrigin(-(oX-x)/2,-(oY-y)/2);		 */		setOrigin(setX, setY);		//treeDisplay.getTreeDrawing().recalculatePositions(treeDisplay.getTree()); //to force node locs recalc	}	/*.................................................................................................................*/	public void treeEdited(boolean rememberEditedTree){		boolean wasEdited = treeEdited;		treeEdited=true;		if (wasEdited && treeSourceLocked()) {			showTreeAnnotation();		}		if (rememberEditedTree){			recentEditedTrees.addElement(tree.cloneTree(), false);			if (recentEditedTrees.size()>=maxRecentEditedTrees)				recentEditedTrees.removeElementAt(0, false);			palette.recentButton.repaint();		}		if (!treeSourceLocked() && originalTree !=null) {			tree.setName(originalTree.getName());		}		messagePanel.setHighlighted(true, !treeSourceLocked());		if (treeInfoPanel != null)			treeInfoPanel.setHighlighted(true, !treeSourceLocked());		palette.paletteScroll.setEnableEnter(true);		if (tree!=null)			treeVersion = tree.getVersionNumber();		//resetLockImage();		highlightedBranch.setValue(0);		dropHighlightedBranch.setValue(0);		branchFrom = 0;		storeTreeMenuItem.setEnabled(!treeSourceLocked());		checkPanelPositionsLegal();		resetBaseExplanation();	}	/*   	 void lockTouched(){   	 	if (!treeSourceTask.nameMatches("StoredTrees") || !(originalTree instanceof MesquiteTree) ) {   	 		lockStoredTrees = true;   	 		ownerModule.alert("You cannot unlock the trees, because trees are being supplied by \"" + treeSourceTask.getName() + "\" and are not editable Stored Trees.  Because the trees are locked, they can be viewed but not modified.  Attempts to modify the tree will yield an unsaved temporary tree, which can be stored permanently using the Store Tree menu item.");   	 	}   	 	else if (lockStoredTrees) {   	 		lockStoredTrees = false;  //Need to do a save as   	 		ownerModule.alert("The stored trees are now unlocked for editing.  Any editing of the tree being browsed will change the original copy stored in the file.");   	 	}   	 	else {   	 		lockStoredTrees = true;   	 		ownerModule.alert("The stored trees are now locked.  Attempts to modify the tree being browsed will yield an unsaved temporary tree, which can be stored permanently using the Store Tree menu item.");   	 	}   	 	resetLockImage();   	 }   	void resetLockImage(){   	   	if (!treeSourceTask.nameMatches("StoredTrees"))   	   		lockPanel.setLockState(0);   	   	else if (!(originalTree instanceof MesquiteTree) || lockStoredTrees)   	   		lockPanel.setLockState(1);   	   	else    	   		lockPanel.setLockState(2);   	}	 */	boolean treeSourceLocked(){		return (originalTree == null || !(originalTree instanceof MesquiteTree) || !treeSourceTask.nameMatches("StoredTrees")); //lockStoredTrees || 	}	/*.................................................................................................................*/	public Tree incrementTreeNumber(){		int numTrees = treeSourceTask.getNumberOfTrees(taxa);		if (currentTreeNumber >= numTrees-2)			return null;		return goToTreeNumber(currentTreeNumber+1);	}	/*.................................................................................................................*/	public Tree goToTreeNumber(int index){		currentTreeNumber = index;		if (MesquiteThread.isScripting() && ((BasicTreeWindowMaker)ownerModule).suppressEPCResponse)			return null;		Tree treeT = treeSourceTask.getTree(taxa, index);		if (treeT == null){  //source may have not known how many trees; ask if it would revise its current number of trees			int numTrees = treeSourceTask.getNumberOfTrees(taxa);			if (currentTreeNumber>= numTrees && MesquiteInteger.isCombinable(numTrees)) {				currentTreeNumber = numTrees -1;				treeT = treeSourceTask.getTree(taxa, currentTreeNumber);				palette.paletteScroll.setMaximumValue(MesquiteTree.toExternal(numTrees-1)); 			}		}		Tree t = setCloneOfTree(treeT, true);		treeEdited=false;		messagePanel.setHighlighted(false, !treeSourceLocked());		if (treeInfoPanel != null)			treeInfoPanel.setHighlighted(false, !treeSourceLocked());		palette.paletteScroll.setCurrentValue(MesquiteTree.toExternal(currentTreeNumber));		//resetLockImage();		storeTreeMenuItem.setEnabled(!treeSourceLocked());		resetBaseExplanation();		checkPanelPositionsLegal();		setTreeName();		return t;	}	/*.................................................................................................................*/	public String getTextContents() {		if (treeDisplay==null)			return "";		String s = "Tree window\n";		if (treeSourceTask !=null)			s += "Showing " + treeSourceTask.getNameForMenuItem();		if (taxa!=null)			s += " for taxa \"" + taxa.getName() + "\"";		if (originalTree!=null)			s += "\nOriginal Tree:  " + originalTree;		s += "\n\n"  + treeDisplay.getTextVersion();		return s;	}	/*.................................................................................................................*/	public void paintContents(Graphics g) {		if (treeDisplay==null)		{			MesquiteMessage.warnProgrammer("Oh no, tree display is null");		}		else {//			^^^			sizeDisplay();			treeDisplay.repaint();			checkPanelPositionsLegal();			palette.repaintBirdsEye();			g.setColor(Color.black);		}	}	public void setOrigin(int x, int y) {		if (treePane !=null) {			treePane.setScrollPosition(-x,-y);			treePane.doLayout();		}		initPosX = x;		initPosY = y;	}	//for java 1.1 printing	public Object fit(Dimension dim){		/*int w;		int h;		int currentWidth = treeDisplay.getFieldWidth();		int currentHeight = treeDisplay.getFieldHeight();		if (currentHeight == 0 || currentWidth == 0) {			w = dim.width;			h = dim.height;		}		else if (((double)dim.width)/currentWidth > ((double)dim.height)/currentHeight) {			w = (int)(((double)dim.height)/currentHeight * currentWidth);			h = dim.height;		}		else {			w = dim.width;			h = (int)(((double)dim.width)/currentWidth * currentHeight);		}		 */		Dimension d = new Dimension(getOriginX(), getOriginY());		treeDisplay.setFieldSize(dim.width,dim.height);		setOrigin(0,0);		treeDisplay.getTreeDrawing().recalculatePositions(treeDisplay.getTree()); //to force node locs recalc		return d;	}	public void unfit(Object o){		int oX = 0;		int oY = 0;		if (o instanceof Dimension) {			oX = ((Dimension)o).width;			oY =  ((Dimension)o).height;		}		setOrigin(oX,oY);		sizeDisplay();	}	public int getOriginX() {		if (treePane ==null)			return 0;		Adjustable h = treePane.getHAdjustable();		return -(int)( ((1.0*(h.getValue()- h.getMinimum()))/(h.getMaximum()-h.getMinimum()))*treeDisplay.getBounds().width);	}	public int getOriginY() {		if (treePane ==null)			return 0;		Adjustable v = treePane.getVAdjustable();		return -(int)( ((1.0*(v.getValue()- v.getMinimum()))/(v.getMaximum()-v.getMinimum()))*treeDisplay.getBounds().height);	}	/*_________________________________________________*/	public   void InvertTaxon(Graphics g, int M) {		if (findTaxon(treeDisplay.getMouseX(), treeDisplay.getMouseY()) == M){ //still in taxon			g.setColor(Color.black);			if (GraphicsUtil.useXORMode(g, true)) {				g.setXORMode(Color.white);				treeDisplay.fillTaxon(g, M);				g.setPaintMode();				g.setColor(Color.black);			}			highlightedTaxon=M;		}		Tree t = treeDisplay.getTree();		if (t!=null && t.getTaxa() !=null) {			if (t.getTaxa().getAnnotation(M)!=null)				setAnnotation(t.getTaxa().getAnnotation(M), "Footnote above refers to taxon \"" + t.getTaxa().getTaxonName(M) + "\"");			else {				setExplanation("Taxon: " + t.getTaxa().getTaxonName(M));				setAnnotation("", null);			}			treeAnnotationShown = false; //so that the base Explanation can know whether to refer to the annotation		}	}	/*_________________________________________________*/	public   void RevertTaxon(Graphics g, int M) {		if (highlightedTaxon >= 0){			g.setColor(Color.black);			if (GraphicsUtil.useXORMode(g, true)) {				g.setXORMode(Color.white);				treeDisplay.fillTaxon(g, highlightedTaxon);				g.setPaintMode();			}			highlightedTaxon=-1;			g.setColor(Color.black);		}		showTreeAnnotation();	}	/*_________________________________________________*/	private int findBranch(int x, int y, MesquiteDouble fraction){		int drawnRoot = treeDisplay.getTreeDrawing().getDrawnRoot(); //TODO: remember drawnRoot!!!		if (!tree.nodeExists(drawnRoot))			drawnRoot = tree.getRoot();		return treeDisplay.getTreeDrawing().findBranch(tree,  drawnRoot, x, y, fraction); //check that still in branch	}	private int findTaxon(int x, int y){		int drawnRoot = treeDisplay.getTreeDrawing().getDrawnRoot(); //TODO: remember drawnRoot!!!		if (!tree.nodeExists(drawnRoot))			drawnRoot = tree.getRoot();		return treeDrawCoordTask.getNamesTask().findTaxon(tree, drawnRoot, x, y);	}	/*_________________________________________________*/	NameReference branchNotesRef = NameReference.getNameReference("note");	private int countinvert = 0;	public   void InvertBranch(Graphics g, int N, MesquiteInteger highlight) {		Tree t = treeDisplay.getTree();		if (t!=null){			MesquiteDouble fraction = new MesquiteDouble();			if (findBranch(treeDisplay.getMouseX(), treeDisplay.getMouseY(), fraction) == N){ //still in N				TreeDrawing treeDrawing = treeDisplay.getTreeDrawing();				highlight.setValue(N);   // sets the highlighed branch				if (treeDrawing!=null && !treeDisplay.repaintPending())					treeDrawing.fillBranchInverted(t, N, g);				//colorInvertBranch(t,N,g);				showBranchExplanation(N);			}		}	}	/*_________________________________________________*/	private void showBranchExplanation(int node){		String s = "";		if (tree.numberOfParentsOfNode(node)>1) 			s = " (Node represents reticulation; has " + tree.numberOfParentsOfNode(node) + " immediate ancestors)";//added 4 feb 02		if (tree.nodeIsTerminal(node)) {			Taxon t = tree.getTaxa().getTaxon(tree.taxonNumberOfNode(node));			if (t!=null)				setExplanation("Taxon: " + t.getName() + s);  			else				setExplanation("Unknown taxon (the tree description may have been malformed or with undefined taxa)" + s);		}		else {			Taxon t1 = tree.getTaxa().getTaxon(tree.taxonNumberOfNode(tree.leftmostTerminalOfNode(node)));			Taxon t2 = tree.getTaxa().getTaxon(tree.taxonNumberOfNode(tree.rightmostTerminalOfNode(node)));			String n1, n2;			if (t1 == null)				n1 = "Unknown taxon";			else				n1 = t1.getName();			if (t2 == null)				n2 = "Unknown taxon";			else				n2 = t2.getName();			setExplanation(" " + tree.numberOfTerminalsInClade(node) + " taxa in clade (" + n1 + " to " + n2 + ").  Node is number " + node + ". " + s);  		}	}	/*_________________________________________________*/	public   void RevertBranch(Graphics g, MesquiteInteger highlight) {		//treeDisplay.deletePendingMoveDrag();		int wasHighlighted = highlight.getValue();		highlight.setValue(0);		if (wasHighlighted> 0 && !treeDisplay.repaintPending()){			treeDisplay.getTreeDrawing().fillBranchInverted(treeDisplay.getTree(), wasHighlighted, g);			//treeDisplay.getTreeDrawing().fillBranchInverted(t, N, g);		}		showTreeAnnotation();		//setAnnotation("", null);		//treeAnnotationShown = false; //so that the base Explanation can know whether to refer to the annotation	}	/*_________________________________________________*/	public void ScanFlash(Graphics g, int x, int y, int modifiers) {		if (treeDisplay == null || tree == null || treeDrawCoordTask == null || treeDrawCoordTask.getNamesTask() == null || treeDisplay.getTreeDrawing()==null)			return;		if (treeDisplay.getInvalid())			return;		MesquiteDouble fraction = new MesquiteDouble();		int branchFound =findBranch(x, y, fraction);		/*  		if (fraction.isCombinable())			if (treeDisplay.getTreeDrawing().isAtNode(fraction))				System.out.println("in node " + branchFound + ", fraction: " + fraction.getValue());			else 				System.out.println("  " + fraction.getValue() + "   " + branchFound);		 */		if (highlightedBranch.getValue() != 0) {  // we are already in a branch			int wasHighlighted = highlightedBranch.getValue();			if (branchFound==0) {				RevertBranch(g, highlightedBranch);				notifyExtrasOfBranchExit(g, wasHighlighted);				setTreeName();  				setExplanation(baseExplanation, false);			}			else if (branchFound!=highlightedBranch.getValue())  {				RevertBranch(g, highlightedBranch); 				InvertBranch(g, branchFound, highlightedBranch);				notifyExtrasOfBranchExit(g, wasHighlighted);				notifyExtrasOfBranchEnter(g, branchFound);			}		}		else if (branchFound!=0) {   // we weren't in a branch, but now we found one			InvertBranch(g, branchFound, highlightedBranch); 			notifyExtrasOfBranchEnter(g, branchFound);			if (tree.nodeIsTerminal(branchFound)) {				Taxon t = tree.getTaxa().getTaxon(tree.taxonNumberOfNode(branchFound));				if (t!=null)					setExplanation("Taxon: " + t.getName());  				else					setExplanation("Unknown taxon (the tree description may have been malformed or with undefined taxa)");			}			else {				Taxon t1 = tree.getTaxa().getTaxon(tree.taxonNumberOfNode(tree.leftmostTerminalOfNode(branchFound)));				Taxon t2 = tree.getTaxa().getTaxon(tree.taxonNumberOfNode(tree.rightmostTerminalOfNode(branchFound)));				String n1, n2;				if (t1 == null)					n1 = "Unknown taxon";				else					n1 = t1.getName();				if (t2 == null)					n2 = "Unknown taxon";				else					n2 = t2.getName();				setExplanation(" " + tree.numberOfTerminalsInClade(branchFound) + " taxa in clade (" + n1 + " to " + n2 + ").  Node is number " + branchFound + ". ");  			}		}		else {			int nameFound = findTaxon(x, y);			if (highlightedTaxon >= 0) {				if (nameFound==-1) {					int wasHighlighted = highlightedTaxon;					RevertTaxon(g, highlightedTaxon);					notifyExtrasOfTaxonExit(g, wasHighlighted);					setExplanation(baseExplanation, false);				}				else if (nameFound!=highlightedTaxon)  {					int wasHighlighted = highlightedTaxon;					RevertTaxon(g, highlightedTaxon); 					InvertTaxon(g, nameFound);					notifyExtrasOfTaxonExit(g, wasHighlighted);					notifyExtrasOfTaxonEnter(g, nameFound);				}			}			else if (nameFound!=-1) {				InvertTaxon(g, nameFound); 				notifyExtrasOfTaxonEnter(g, nameFound);			}			else {				currentTreeTool.moved(x,y,tree,modifiers);				notifyExtrasOfCursorMove(g, x, y);				//notify extras?			}		}	}	/*_________________________________________________*/	public   boolean ScanTouch(Graphics g, int x, int y, int modifiers) {		if (treeDisplay == null || tree == null || treeDrawCoordTask == null || treeDrawCoordTask.getNamesTask() == null || treeDisplay.getTreeDrawing()==null)			return false;		if (treeDisplay.getInvalid())			return false;		xFrom = -1;		yFrom = -1;		xTo = -1;		yTo = -1;		fieldTouchX = -1;		fieldTouchY = -1;		lastFieldDragX = -1;		lastFieldDragY = -1;		taxonTouched = -1;		MesquiteDouble fraction = new MesquiteDouble();		int branchFound =findBranch(x, y, fraction);		if (branchFound!=0) {			branchFrom=branchFound;			if (currentTreeTool.informTransfer()) {  				//branchFrom=branchFound;				xFrom=x;				yFrom= y;				xTo=x;				yTo= y;				if (GraphicsUtil.useXORMode(g, true)){					g.setXORMode(Color.white);					g.setColor(Color.black); 					g.drawLine(xFrom,yFrom,xTo,yTo);				}			}			else {				if (highlightedBranch.getValue() != 0) {					notifyExtrasOfBranchExit(g, highlightedBranch.getValue());					RevertBranch(g, highlightedBranch);				}				currentTreeTool.branchTouched(branchFound, x, y, tree, modifiers);				//branchFrom = 0;			}			notifyExtrasOfBranchTouch(g, branchFound);			return true;		}		else {			int nameFound = findTaxon(x,y);			if (nameFound!=-1) {				currentTreeTool.taxonTouched(nameFound, tree, modifiers);				taxonTouched = nameFound;				notifyExtrasOfTaxonTouch(g, nameFound);				if (highlightedTaxon >= 0 )					RevertTaxon(g, highlightedTaxon);				return true;			}			else {				if (currentTreeTool.isArrowTool()){					fieldTouchX = x;					fieldTouchY = y;					lastFieldDragX = x;					lastFieldDragY = y;				}				boolean fieldTouchAccepted = currentTreeTool.fieldTouched(x,y,tree,modifiers);				//notify extras?				return fieldTouchAccepted;			}		}		//return false;	}	/*_________________________________________________*/	public   void ScanDrop(Graphics g, int x, int y, int modifiers) {		if (treeDisplay == null || tree == null || treeDisplay.getTreeDrawing()==null)			return;		if (treeDisplay.getInvalid())			return;		if (currentTreeTool.isArrowTool() && fieldTouchX >= 0 && fieldTouchY >=0){			g.setColor(Color.blue);			if (GraphicsUtil.useXORMode(g, false)){				g.setXORMode(Color.white); //for some reason color doesn't matter in MacOS, but does in Win95				GraphicsUtil.drawRect(g, fieldTouchX,fieldTouchY,lastFieldDragX-fieldTouchX,lastFieldDragY-fieldTouchY);			}			if (!dragSelect(modifiers, fieldTouchX, fieldTouchY, x-fieldTouchX,y-fieldTouchY)){				if (taxa.anySelected()){					taxa.deselectAll();					taxa.notifyListeners(this, new Notification(MesquiteListener.SELECTION_CHANGED));				}				if (tree.anySelected()){					tree.deselectAll();					tree.notifyListeners(this, new Notification(MesquiteListener.SELECTION_CHANGED));				}				if (Math.abs(x-fieldTouchX)< 4 && Math.abs(y-fieldTouchY)< 4)					notifyExtrasOfFieldTouch(g, x, y, modifiers);			}			fieldTouchX = -1;			fieldTouchY = -1;			lastFieldDragX = -1;			lastFieldDragY = -1;			return;		}		if ((!treeDisplay.getTree().isLocked()) &&  (branchFrom!=0)) {			if (highlightedBranch.getValue() != 0) {				notifyExtrasOfBranchExit(g, highlightedBranch.getValue());				RevertBranch(g, highlightedBranch);			}			else if (highlightedTaxon >=0)				RevertTaxon(g, highlightedTaxon);			g.setColor(Color.black); 			if (GraphicsUtil.useXORMode(g, false)){				g.setXORMode(Color.white);				g.drawLine(xFrom,yFrom,xTo,yTo); //only if drawn			}			if (currentTreeTool.informTransfer()) {				MesquiteDouble fraction = new MesquiteDouble();				int branchTo=findBranch(x, y, fraction);				if (branchTo != 0) {					if (branchTo == branchFrom && currentTreeTool.isArrowTool()){						selectBranch(modifiers, branchTo);					}					else						currentTreeTool.branchTransferred(branchFrom, branchTo, tree, modifiers);				}			}			else if (currentTreeTool.informDrop()) {				currentTreeTool.branchDropped(branchFrom, x, y, tree, modifiers);			}			branchFrom = 0;		}		else {			int nameFound = findTaxon(x,y);			if (nameFound!=-1) {				if (taxonTouched == nameFound && currentTreeTool.isArrowTool())					selectTaxon(modifiers, taxonTouched);				currentTreeTool.taxonMouseUp(nameFound,x,y,tree, modifiers);				notifyExtrasOfTaxonTouch(g, nameFound);				if (highlightedTaxon >= 0 )					RevertTaxon(g, highlightedTaxon);				taxonTouched = -1;				return;			}			else currentTreeTool.fieldMouseUp(x,y,tree,modifiers);			//notify extras?		}		taxonTouched = -1;	}	/*_________________________________________________*/	public   void ScanDrag(Graphics g, int x, int y, int modifiers) {		if (treeDisplay == null || tree == null)			return;		if (treeDisplay.getInvalid())			return;		if (currentTreeTool.isArrowTool() && fieldTouchX >= 0 && fieldTouchY >=0){			g.setColor(Color.blue);			if (GraphicsUtil.useXORMode(g, false)){				g.setXORMode(Color.white); //for some reason color doesn't matter in MacOS, but does in Win95				GraphicsUtil.drawRect(g, fieldTouchX,fieldTouchY,lastFieldDragX-fieldTouchX,lastFieldDragY-fieldTouchY);				GraphicsUtil.drawRect(g, fieldTouchX,fieldTouchY,x-fieldTouchX,y-fieldTouchY);				//g.drawRect(fieldTouchX,fieldTouchY,lastFieldDragX-fieldTouchX,lastFieldDragY-fieldTouchY);				//g.drawRect(fieldTouchX,fieldTouchY,x-fieldTouchX,y-fieldTouchY);			}			lastFieldDragX = x;			lastFieldDragY = y;			return;		}		MesquiteDouble fraction = new MesquiteDouble();		int branchFound =findBranch(x, y, fraction);		if (branchFound > 0) {			if (branchFound != dropHighlightedBranch.getValue()) {				RevertBranch(g, dropHighlightedBranch);				InvertBranch(g, branchFound, dropHighlightedBranch);			}		}		else if (dropHighlightedBranch.getValue()>0)			RevertBranch(g, dropHighlightedBranch);		if (branchFrom!=0) {			if (currentTreeTool.informTransfer()) {				g.setColor(Color.black);				if (GraphicsUtil.useXORMode(g, false)){					g.setXORMode(Color.white); //for some reason color doesn't matter in MacOS, but does in Win95					g.drawLine(xFrom,yFrom,xTo,yTo);				}				xTo=x;				yTo= y;				if (GraphicsUtil.useXORMode(g, false))					g.drawLine(xFrom,yFrom,xTo,yTo);			}			else if (currentTreeTool.informDrag()) {				currentTreeTool.branchDragged(branchFrom, x, y, tree, modifiers);			}		}	}	public void findContained(Tree tree, int N, int x, int y, int w, int h, Vector nodes, Vector taxons) {		TreeDrawing drawing = treeDisplay.getTreeDrawing();		int dX = drawing.x[N];		int dY = drawing.y[N];		if (dX >= x && dX <= x+w && dY>=y && dY <= y+h)			nodes.addElement(new MesquiteInteger(N));		if (tree.nodeIsTerminal(N) && drawing.namePolys != null){			Polygon term = drawing.namePolys[tree.taxonNumberOfNode(N)];			if (term != null && term.intersects(x, y, w, h))				taxons.addElement(new MesquiteInteger(tree.taxonNumberOfNode(N)));		}		for (int d = tree.firstDaughterOfNode(N); tree.nodeExists(d); d = tree.nextSisterOfNode(d)) {			findContained(tree, d, x, y, w, h, nodes, taxons);		}	}	public boolean shrinkWrapNodes(MesquiteTree tree, int N, boolean selBelow) {		int pathsSelAbove = 0;		for (int d = tree.firstDaughterOfNode(N); tree.nodeExists(d); d = tree.nextSisterOfNode(d)) {			boolean selAbove = shrinkWrapNodes(tree, d, selBelow || tree.getSelected(N));			if (selAbove)				pathsSelAbove++;		}		if (pathsSelAbove>1 || tree.getSelected(N))			tree.selectAllInClade(N);		return pathsSelAbove>0 || tree.getSelected(N);	}	/*-----------------------------------------*/	/** SelectsAllNodes in the clade */	public void selectAllTaxaInClade(Tree tree, int node) {		if (tree.nodeIsTerminal(node))			taxa.setSelected(tree.taxonNumberOfNode(node), true);		for (int d = tree.firstDaughterOfNode(node); tree.nodeExists(d); d = tree.nextSisterOfNode(d)) {			selectAllTaxaInClade(tree, d);		}	}	public boolean shrinkWrapTaxa(MesquiteTree tree, int N) {		int pathsSelAbove = 0;		boolean thisIsSelected = tree.nodeIsTerminal(N) && tree.getTaxa().getSelected(tree.taxonNumberOfNode(N));		for (int d = tree.firstDaughterOfNode(N); tree.nodeExists(d); d = tree.nextSisterOfNode(d)) {			boolean selAbove = shrinkWrapTaxa(tree, d);			if (selAbove)				pathsSelAbove++;		}		if (pathsSelAbove>1)			selectAllTaxaInClade(tree, N);		return pathsSelAbove>0 || thisIsSelected;	}	private boolean dragSelect(int modifiers, int x, int y, int w, int h){		Vector nodes = new Vector();		Vector taxons = new Vector();		if (w < 0){			int nx = x + w;			x = nx;			w = -w;		}		if (h < 0){			int ny = y + h;			y = ny;			h = -h;		}		boolean selectionChanged = false;		boolean shiftDown = MesquiteEvent.shiftKeyDown(modifiers);		boolean commandDown = MesquiteEvent.commandOrControlKeyDown(modifiers);		findContained(tree, tree.getRoot(), x, y, w, h, nodes, taxons);		if (nodes.size()>0){			if (!shiftDown && !commandDown)				tree.deselectAll();			for (int i=0; i<nodes.size(); i++){				MesquiteInteger mi = (MesquiteInteger) nodes.elementAt(i);				if (commandDown)					tree.setSelected(mi.getValue(), !tree.getSelected(mi.getValue()));				else					tree.setSelected(mi.getValue(), true);			}			if (shiftDown)				shrinkWrapNodes(tree, tree.getRoot(), false);			tree.notifyListeners(this, new Notification(MesquiteListener.SELECTION_CHANGED));			selectionChanged = true;		}		if (taxons.size()>0){			if (!shiftDown && !commandDown)				taxa.deselectAll();			for (int i=0; i<taxons.size(); i++){				MesquiteInteger mi = (MesquiteInteger) taxons.elementAt(i);				if (commandDown)					taxa.setSelected(mi.getValue(), !taxa.getSelected(mi.getValue()));				else					taxa.setSelected(mi.getValue(), true);			}			if (shiftDown)				shrinkWrapTaxa(tree, tree.getRoot());			taxa.notifyListeners(this, new Notification(MesquiteListener.SELECTION_CHANGED));			selectionChanged = true;		}		return selectionChanged;	}	private void selectBranch(int modifiers, int node){		boolean shiftDown = MesquiteEvent.shiftKeyDown(modifiers);		boolean commandDown = MesquiteEvent.commandOrControlKeyDown(modifiers);		if (!shiftDown && !commandDown)			tree.deselectAll();		if (commandDown)			tree.setSelected(node, !tree.getSelected(node));		else			tree.setSelected(node, true);		if (shiftDown)			shrinkWrapNodes(tree, tree.getRoot(), false);		tree.notifyListeners(this, new Notification(MesquiteListener.SELECTION_CHANGED));	}	private void selectTaxon(int modifiers, int taxon){		boolean shiftDown = MesquiteEvent.shiftKeyDown(modifiers);		boolean commandDown = MesquiteEvent.commandOrControlKeyDown(modifiers);		if (!shiftDown && !commandDown)			taxa.deselectAll();		if (commandDown)			taxa.setSelected(taxon, !taxa.getSelected(taxon));		else			taxa.setSelected(taxon, true);		if (shiftDown)			shrinkWrapTaxa(tree, tree.getRoot());		taxa.notifyListeners(this, new Notification(MesquiteListener.SELECTION_CHANGED));	}	/*................................................................................................*/	public void notifyExtrasOfCursorMove(Graphics g, int x, int y) {		if (treeDisplay.getExtras()!=null) {			Enumeration e = treeDisplay.getExtras().elements();			while (e.hasMoreElements()) {				Object obj = e.nextElement();				if (obj instanceof TreeDisplayExtra) {					TreeDisplayExtra tce = (TreeDisplayExtra)obj;					tce.cursorMove(tree, x, y, g);				}			}		}	}	/*................................................................................................*/	public void notifyExtrasOfTaxonEnter(Graphics g, int M) {		if (treeDisplay.getExtras()!=null) {			Enumeration e = treeDisplay.getExtras().elements();			while (e.hasMoreElements()) {				Object obj = e.nextElement();				if (obj instanceof TreeDisplayExtra) {					TreeDisplayExtra tce = (TreeDisplayExtra)obj;					tce.cursorEnterTaxon(tree, M, g);				}			}		}		if(treeInfoPanel != null && infoPanelOn.getValue())			treeInfoPanel.taxonEnter(M);	}	/*................................................................................................*/	public void notifyExtrasOfTaxonExit(Graphics g, int M) {		if (treeDisplay.getExtras()!=null) {			Enumeration e = treeDisplay.getExtras().elements();			while (e.hasMoreElements()) {				Object obj = e.nextElement();				if (obj instanceof TreeDisplayExtra) {					TreeDisplayExtra tce = (TreeDisplayExtra)obj;					tce.cursorExitTaxon(tree, M, g);				}			}		}		if(treeInfoPanel != null && infoPanelOn.getValue())			treeInfoPanel.taxonExit(M);	}	/*................................................................................................*/	public void notifyExtrasOfTaxonTouch(Graphics g, int M) {		if (treeDisplay.getExtras()!=null) {			Enumeration e = treeDisplay.getExtras().elements();			while (e.hasMoreElements()) {				Object obj = e.nextElement();				if (obj instanceof TreeDisplayExtra) {					TreeDisplayExtra tce = (TreeDisplayExtra)obj;					tce.cursorTouchTaxon(tree, M, g);				}			}		}		if(treeInfoPanel != null && infoPanelOn.getValue())			treeInfoPanel.taxonTouch(M);	}	/*................................................................................................*/	public void notifyExtrasOfBranchEnter(Graphics g, int N) {		if (treeDisplay.getExtras()!=null) {			Enumeration e = treeDisplay.getExtras().elements();			while (e.hasMoreElements()) {				Object obj = e.nextElement();				if (obj instanceof TreeDisplayExtra) {					TreeDisplayExtra tce = (TreeDisplayExtra)obj;					tce.cursorEnterBranch(tree, N, g);				}			}		}		if(treeInfoPanel != null && infoPanelOn.getValue())			treeInfoPanel.branchEnter(N);	}	/*................................................................................................*/	public void notifyExtrasOfBranchExit(Graphics g, int N) {		if (treeDisplay.getExtras()!=null) {			Enumeration e = treeDisplay.getExtras().elements();			while (e.hasMoreElements()) {				Object obj = e.nextElement();				if (obj instanceof TreeDisplayExtra) {					TreeDisplayExtra tce = (TreeDisplayExtra)obj;					tce.cursorExitBranch(tree, N, g);				}			}		}		if(treeInfoPanel != null && infoPanelOn.getValue())			treeInfoPanel.branchExit(N);	}	/*................................................................................................*/	public void notifyExtrasOfBranchTouch(Graphics g, int N) {		if (treeDisplay.getExtras()!=null) {			Enumeration e = treeDisplay.getExtras().elements();			while (e.hasMoreElements()) {				Object obj = e.nextElement();				if (obj instanceof TreeDisplayExtra) {					TreeDisplayExtra tce = (TreeDisplayExtra)obj;					tce.cursorTouchBranch(tree, N, g);				}			}		}		if(treeInfoPanel != null && infoPanelOn.getValue())			treeInfoPanel.branchTouch(N);	}	/*................................................................................................*/	public void notifyExtrasOfFieldTouch(Graphics g, int x, int y, int modifiers) {		if (treeDisplay.getExtras()!=null) {			Enumeration e = treeDisplay.getExtras().elements();			while (e.hasMoreElements()) {				Object obj = e.nextElement();				if (obj instanceof TreeDisplayExtra) {					TreeDisplayExtra tce = (TreeDisplayExtra)obj;					tce.cursorTouchField(tree, g, x, y, modifiers);				}			}		}	}	/*.................................................................................................................*/	private void treeChanged( boolean notifyContextListeners){ 		if (tree.upToDateWithTaxa() && previousTree.upToDateWithTaxa()){			canUndo = true;		}		undoTree.setToClone(previousTree);		undoTree.setName("Untitled Tree");		previousTree.setToClone(tree);		if (tree!=oldTree) {			treeVersion = tree.getVersionNumber();			oldTree=tree;		}		else if (treeVersion!=tree.getVersionNumber()){			treeEdited(false);		}		if (treeDisplay!=null) {			treeDisplay.setTree(tree); 			treeDisplay.getTreeDrawing().setDrawnRoot(tree.getRoot());			//rooted.setValue(tree.getRooted());			setTreeName();			setExplanation(baseExplanation, false);		}		else ownerModule.alert("Tree display null in treeChanged");		if (treeInfoPanel != null)			treeInfoPanel.setTree(tree);		if (notifyContextListeners && windowModule.contextListeners !=null) {			Enumeration e = windowModule.contextListeners.elements();			while (e.hasMoreElements()) {				Object obj = e.nextElement();				if (obj instanceof TreeContextListener) {					TreeContextListener tce = (TreeContextListener)obj;					tce.treeChanged(tree);				}			}		}		if (treeDisplay!=null) {			treeDisplay.setTreeAllExtras(tree);			treeDisplay.pleaseUpdate(true);			if (getMode()>0)				updateTextPage();		}		Enumeration em = ownerModule.getEmployeeVector().elements();		while (em.hasMoreElements()) {			Object obj = em.nextElement();			MesquiteModule mb = (MesquiteModule)obj;			if (mb instanceof TreeWindowAssistant) {				((TreeWindowAssistant)mb).setTree(tree);  			}		}		showTreeAnnotation();		contentsChanged();	}	/*.................................................................................................................*/	void showTreeAnnotation(){		Tree t = annotatableTree();		if (t!=null) {			setDefaultAnnotatable((Annotatable)t); 			setAnnotation((Annotatable)t); 			treeAnnotationShown = true; //so that the base Explanation can refer to the annotation			resetCursor();		}	}	/*.................................................................................................................*/	/** passes which object is being disposed (from MesquiteListener interface)*/	public void disposing(Object obj){		if (obj instanceof Taxa &&  (Taxa)obj ==taxa) {			ownerModule.iQuit();		}	}	/*.................................................................................................................*/	/** passes which object is being disposed (from MesquiteListener interface)*/	public boolean okToDispose(Object obj, int queryUser){		return true;  //TODO: respond	}	/*.................................................................................................................*/	/** passes which object changed (from MesquiteListener interface)*/	public void changed(Object caller, Object obj, Notification notification){		int code = Notification.getCode(notification);		int[] parameters = Notification.getParameters(notification);		if (obj instanceof Taxa &&  (Taxa)obj ==taxa) {			if (code==MesquiteListener.PARTS_CHANGED || code ==MesquiteListener.PARTS_ADDED || code == MesquiteListener.PARTS_MOVED || code == MesquiteListener.PARTS_DELETED) {				canUndo = false;			}			else if (code==MesquiteListener.NAMES_CHANGED || code == MesquiteListener.SELECTION_CHANGED) 				treeDisplay.pleaseUpdate(true);			if (getMode()>0)				updateTextPage();		}		else if (obj instanceof Tree && (Tree)obj == tree){ // && code!=MesquiteListener.ANNOTATION_CHANGED){			treeEdited(true);			treeChanged( code!=MesquiteListener.ANNOTATION_CHANGED && code != MesquiteListener.ANNOTATION_DELETED && code != MesquiteListener.ANNOTATION_ADDED); 		}		/*		else if (obj instanceof Tree && (Tree)obj == tree && code==MesquiteListener.ANNOTATION_CHANGED){    	 		treeEdited();			setTreeName();			setExplanation(baseExplanation, true);			if (getMode()>0)				updateTextPage();		}		 */		/*else if (obj == currentTreeFootnote){			//footnoteToTreeAnnotation();		}*/		super.changed(caller, obj, notification);	}	/*.................................................................................................................*/	void resetBaseExplanation(){		String td = "";		String td2 = "";		if (tree!=null) {			if (treeAnnotationShown && !StringUtil.blank(tree.getAnnotation()))				td = "Footnote above refers to the current tree. \nTree has " +tree.numberOfTerminalsInClade(tree.getRoot()) + " terminal taxa.";			else				td = "The current tree has " +tree.numberOfTerminalsInClade(tree.getRoot()) + " terminal taxa.";			if (tree.hasPolytomies(tree.getRoot())){				if (tree.getPolytomiesAssumption() ==0)					td += " Polytomies in this tree are assumed hard.";				else if (tree.getPolytomiesAssumption() ==1)					td += " Polytomies in this tree are assumed soft.";			}			if (!tree.getRooted())				td += " This tree is unrooted.";			if (tree.anySelectedInClade(tree.getRoot()))				td += " " + tree.numberSelectedInClade(tree.getRoot()) + " branch(es) selected.";			td += "\n";		}		if (ownerModule.getProject().getNumberTaxas()>1 && tree != null)			td += "Tree window shows trees for taxa \"" + tree.getTaxa().getName() + "\"\n";		if (treeEdited)			baseExplanation.setValue(td + "Editing Mode.  " + td2 + "When in browsing mode, the trees shown are from " + treeSourceTask.getName() + " [" + treeSourceTask.getParameters() + "]");		else			baseExplanation.setValue(td + "Browsing Mode.  " + td2 + "The trees shown are from " + treeSourceTask.getName() + " [" + treeSourceTask.getParameters() + "]");		setExplanation(baseExplanation, true);	}	/*.................................................................................................................*/	public void setExplanation(String exp){		baseExplanationUsed = false;		super.setExplanation(exp);	}	/*.................................................................................................................*/	void setExplanation(MesquiteString exp, boolean setEvenIfAlreadyBase){		if (exp == null)			return;		if (exp != baseExplanation || !(baseExplanationUsed && !setEvenIfAlreadyBase)) {			baseExplanationUsed = true;			super.setExplanation(exp.toString());		}	}	/*.................................................................................................................*/	private Tree annotatableTree(){		Tree t;		if (treeEdited) {			t = tree;			if (t !=null && t instanceof Annotatable && (t != originalTree || treeSourceTask.nameMatches("StoredTrees")))				return t;		}		else {			t = originalTree;			if (t !=null && t instanceof Annotatable && treeSourceTask.nameMatches("StoredTrees"))				return t;		}		return null;	}	/*.................................................................................................................*/	private void hookCurrentTree(){		tree.addListener(this);		tree.getTaxa().addListenerHighPriority(tree); //just in case tree isn't part of TreeVector that will notify it; added 14 Feb 02		showTreeAnnotation();	}	/*.................................................................................................................*/	private void unhookPreviousTree(){		tree.removeListener(this);		tree.getTaxa().removeListener(tree); //just in case tree isn't part of TreeVector that will notify it; added 14 Feb 02	}	/*.................................................................................................................*/	public void setTreeName(){		String treename;		if (treeEdited && treeSourceLocked()) {			if (tree!=null)				treename= tree.getName();			else				treename = "Untitled Tree";		}		else if (usingDefaultBush)			treename = "DEFAULT BUSH SHOWN BECAUSE TREE SOURCE NOT SUPPLYING TREE";		else if (tree != null && tree.hasName())			treename = tree.getName();		else			treename = treeSourceTask.getTreeNameString(taxa, MesquiteTree.toInternal(palette.paletteScroll.getCurrentValue())); 		messagePanel.setMessage(treename);  		if (treeInfoPanel != null)			treeInfoPanel.setTreeAndSourceName(treename, treeSourceTask.getName());	}	/*.................................................................................................................*/	public Tree setTree(String TreeDescription){		if (taxa !=null && taxa.isDoomed()) {			ownerModule.iQuit();			return null;		}		if (treeDisplay!=null) {			if (taxa == null){				Tree displayTree =treeDisplay.getTree();				if (displayTree== null)					displayTree = tree;				if (displayTree == null)					return null;				Taxa newTaxa = displayTree.getTaxa();				taxa = newTaxa;			}			if (taxa == null)				return null;			MesquiteTree t = new MesquiteTree(taxa);			if (!t.readTree(TreeDescription)) {				ownerModule.discreetAlert( "That tree description is invalid (" + TreeDescription + ")");				return null;			}				//t.warnRetIfNeeded();			if (tree !=null) {				unhookPreviousTree();			}			treeDisplay.setTree(t);			if (tree !=null)				tree.dispose();			tree = t;			tree.setName("Untitled Tree");			treeEdited = true;			hookCurrentTree();			treeChanged( true);			palette.paletteScroll.setEnableEnter(true);			return tree;		}		return null;	}	/*.................................................................................................................*/	Tree setCloneOfTree(Tree treeToClone, boolean resetOriginal){  // displays copy for editing		if (taxa !=null && taxa.isDoomed()) {			ownerModule.iQuit();			return null;		}		if (treeDisplay!=null) {			if (tree !=null) {				unhookPreviousTree();				tree.dispose();			}			if (treeToClone == null) {				tree = taxa.getDefaultTree();				usingDefaultBush = true;				ownerModule.discreetAlert(MesquiteThread.isScripting() || warningGivenForTreeSource,"Tree source \"" +treeSourceTask.getName() +  "\" is not supplying a tree; a default tree will be shown in Tree Window (b).");				if (!MesquiteThread.isScripting())					warningGivenForTreeSource = true;			}			else  {				if (resetOriginal)					this.originalTree = treeToClone;				usingDefaultBush = false;				tree = treeToClone.cloneTree();			}			hookCurrentTree();			treeChanged( true);			return tree;		}		else ownerModule.alert("Tree display null in setCloneOfTree");		return null;	}	/*.................................................................................................................*/	public Tree setTree(MesquiteTree originalTree){  // displays tree; only used in resetForTreeSource for editedTree		if (taxa !=null && taxa.isDoomed()) {			ownerModule.iQuit();			return null;		}		if (treeDisplay!=null) {			if (tree !=null) {				unhookPreviousTree();				tree.dispose();			}			if (originalTree == null) {				tree = taxa.getDefaultTree();				usingDefaultBush = true;				ownerModule.discreetAlert(MesquiteThread.isScripting() || warningGivenForTreeSource,"Tree source \"" +treeSourceTask.getName() +  "\" is not supplying a tree; a default tree will be shown in Tree Window (a).");				if (!MesquiteThread.isScripting())					warningGivenForTreeSource = true;			}			else  {				usingDefaultBush = false;				tree = originalTree;			}			hookCurrentTree();			treeChanged( true);			return tree;		}		else ownerModule.alert("Tree display null in showTree");		return null;	}	/*.................................................................................................................*/	public void windowResized(){		super.windowResized();		sizeDisplay();	}	/*.................................................................................................................*/	public void dispose(){		disposing = true;		waitUntilDisposable();		if (tree!=null) {			unhookPreviousTree();			tree.dispose();		}		if (taxa!=null)			taxa.removeListener(this);		if (magnifyExtra!=null)			magnifyExtra.dispose();		tree = null;		if (palette!=null)			palette.dispose();		windowModule = null; 		if (currentTreeTool!=null) {			currentTreeTool.dispose();			currentTreeTool = null;		}		treeDrawCoordTask = null;		treeSourceTask = null;		try{			if (treeDisplay !=null){				removeFromWindow(treeDisplay);				treeDisplay.dispose();			}			treeDisplay=null;			if (setTreeNumberCommand!=null)				setTreeNumberCommand.setOwner(null);			setTreeNumberCommand = null;			if (sizeToFit!=null)				sizeToFit.releaseMenuItem();			//if (rooted!=null)			//	rooted.releaseMenuItem();		}		catch (NullPointerException e){		}		super.dispose();	}}/* ======================================================================== */class TreeScrollPane extends ScrollPane{	BasicTreeWindow window;	public TreeScrollPane (int scrollPolicy, BasicTreeWindow window) {		super(scrollPolicy);		//	setWheelScrollingEnabled(false);		this.window = window;	}	public void addTreeDisplay(Component c){		addImpl(c, null, 0);	}	public void setSize(int w, int h){		super.setSize(w, h);		window.checkPanelPositionsLegal();	}	public void setBounds(int x, int y, int w, int h){		super.setBounds(x, y, w, h);		window.checkPanelPositionsLegal();	}}/* ======================================================================== *class LockPanel extends MousePanel {	Image lockClosed, lockOpen, lockImage;	BasicTreeWindow window;	int state;	public LockPanel(BasicTreeWindow window){		super();		this.window = window;		lockClosed  = MesquiteImage.getImage(MesquiteModule.getRootPath() + "images/lockClosed.gif");		lockOpen  = MesquiteImage.getImage(MesquiteModule.getRootPath() + "images/lockOpen.gif");		setLockState(0);	}	public void setLockState(int state){		this.state = state;		if (state == 0)			lockImage = lockClosed;		else if (state ==1)			lockImage = lockClosed;		else if (state == 2)			lockImage = lockOpen;	}	public void paint(Graphics g) { //^^^	   	if (MesquiteWindow.checkDoomed(this))	   		return; 		g.drawImage(lockImage, 0, -1, this); 		g.drawLine(0, getBounds().height-1, getBounds().width, getBounds().height-1);		MesquiteWindow.uncheckDoomed(this); 	}    	public void mouseUp(int modifiers, int x, int y, MesquiteTool tool) {    		window.lockTouched();    		repaint();   	}} *//* ======================================================================== */class MessagePanel extends Panel {	String message;	BasicTreeWindowMaker ownerModule;	boolean showDiamond = false;	boolean indicateModified;	String modifiedString = "";	Polygon poly;	int left = 4;	int top = 4;	int s = 8;	public MessagePanel(BasicTreeWindowMaker ownerModule) {  //in future pass general MesquiteWindow		super();		message="";		poly = new Polygon();		poly.xpoints = new int[4];		poly.ypoints = new int[4];		poly.npoints=0;		poly.addPoint(left, top+s/2);		poly.addPoint(left + s/2, top);		poly.addPoint(left + s, top+s/2);		poly.addPoint(left + s/2, top+s);		poly.npoints=4;		this.ownerModule = ownerModule;		setBackground(ColorTheme.getInterfaceElement());	}	public void paint(Graphics g) {		if (MesquiteWindow.checkDoomed(this))			return;		g.drawRect(0,0, getBounds().width -1, getBounds().height-1);		if (showDiamond){			g.fillPolygon(poly);			if (message != null)				g.drawString(modifiedString + message,  left + s + 4, 12);		}		else if (message != null)			g.drawString(modifiedString + message,  4, 12);		MesquiteWindow.uncheckDoomed(this);	}	public void setMessage(String s) {		message = s;		repaint();	}	public void setHighlighted(boolean edited, boolean storedTrees) {		this.showDiamond = edited;		if (edited && storedTrees)			modifiedString ="Modified from ";		else			modifiedString = "";		if (edited && !storedTrees)			setBackground(ColorDistribution.lightGreen);		else			setBackground(ColorTheme.getInterfaceElement());		if (message != null)			ownerModule.magnifyExtra.name = modifiedString + message;		else			ownerModule.magnifyExtra.name = null;		repaint();	}}/* ======================================================================== *//*New code added Feb.07 oliver*/ // TODO: delete new code comments/** A panel at the bottom of a tree window that can be used for buttons & messages. */class ControlStrip extends Panel {	BasicTreeWindowMaker ownerModule;	Vector buttons;	int left = 4;	int top = 4;	int s = 8;	public ControlStrip(BasicTreeWindowMaker ownerModule) {  //in future pass general MesquiteWindow		super();		setLayout(null);		buttons = new Vector();		this.ownerModule = ownerModule;		setBackground(ColorTheme.getInterfaceElement());	}	public void paint(Graphics g) {		if (MesquiteWindow.checkDoomed(this))			return;		g.drawRect(0,0, getBounds().width -1, getBounds().height-1);		MesquiteWindow.uncheckDoomed(this);	}	public void addButton(MesquiteButton s) {		if (buttons.indexOf(s) < 0) {			buttons.addElement(s);			add(s);		}		s.setVisible(true);		resetLocs();		repaint();	}	public void removeButton(MesquiteButton s) {		buttons.removeElement(s);		remove(s);		s.setVisible(false);		resetLocs();		repaint();	}	private void resetLocs() {		int x = 4;		for (int i = 0; i < buttons.size(); i++) {			MesquiteButton b = (MesquiteButton) buttons.elementAt(i);			b.setLocation(x, 2);			x += 20;		}	}	}	/*End new code added Feb.07 oliver*//* ======================================================================== */class RecentButton extends MousePanel {	BasicTreeWindow window;	static int width = 9; //40;	static int height = 36;	static Image[] recentImage;	static int numImages = 11;	public RecentButton (BasicTreeWindow w){		this.window = w;		//setBackground(ColorDistribution.lightBlue);		setSize(width, height);		if (recentImage == null){			recentImage = new Image[numImages];			for (int i=0; i<numImages; i++)				recentImage[i] = MesquiteImage.getImage(window.getOwnerModule().getPath() + "recent" + MesquiteFile.fileSeparator + "recent" + (i) + ".gif");		}	}	public void mouseDown (int modifiers, int clickCount, long when, int x, int y, MesquiteTool tool) {		MesquitePopup popup = new MesquitePopup(this);		popup.addItem("Recent Edited Trees", (MesquiteCommand)null, null);		popup.addItem("-", (MesquiteCommand)null, null);		if (window.recentEditedTrees.size()==0)			popup.addItem("None Available", (MesquiteCommand)null, null);		else {			popup.addItem("(Newest)", (MesquiteCommand)null, null);			for (int i = window.recentEditedTrees.size()-1; i>=0; i--){				Tree t = window.recentEditedTrees.getTree(i);				popup.addItem(Integer.toString(i+1) + "  " + t.getName(), MesquiteModule.makeCommand("showRecentEdited", window), Integer.toString(i));			}			popup.addItem("(Oldest)", (MesquiteCommand)null, null);		}		popup.showPopup(x+4,y+6);	}	public void paint (Graphics g) {		if (MesquiteWindow.checkDoomed(this))			return;		int i = window.recentEditedTrees.size();		if (i>=numImages)			i = numImages-1;		g.drawImage(recentImage[i],0,0,this);		MesquiteWindow.uncheckDoomed(this);	}}/* ======================================================================== */class TreeWindowPalette extends ToolPalette {	BasicTreeWindow treeWindow;	MiniScroll paletteScroll;	RecentButton recentButton ;	public BirdsEyePanel birdsEyeBox;	BirdsEyeExtra birdsEyeExtra;	int fieldWidth, fieldHeight;	int scrollHeight = 20;	public TreeWindowPalette(BasicTreeWindowMaker ownerModule, BasicTreeWindow containingWindow) {  //in future pass general MesquiteWindow		super( ownerModule,  containingWindow, 2);		treeWindow = containingWindow;		add(paletteScroll = new MiniScroll(treeWindow.setTreeNumberCommand, true, 1, 1, MesquiteTree.toExternal(ownerModule.treeSourceTask.getNumberOfTrees(treeWindow.taxa)-1),"tree"));		paletteScroll.setBackground(Color.green);		paletteScroll.setLocation((getWidth()-paletteScroll.totalWidth+RecentButton.width)/2, scrollHeight);		paletteScroll.setVisible(true);		add(recentButton = new RecentButton(containingWindow));		recentButton.setLocation(paletteScroll.getBounds().x-12, paletteScroll.getBounds().y);		recentButton.setVisible(true);		birdsEyeBox = new BirdsEyePanel(treeWindow, treeWindow.treeDisplay.getTreeDrawing());		setFieldSize(treeWindow.totalTreeFieldWidth,treeWindow.totalTreeFieldHeight);		add(birdsEyeBox);		if (!treeWindow.sizeToFit.getValue())			birdsEyeBox.setVisible(true);		else			birdsEyeBox.setVisible(false);		birdsEyeExtra = new BirdsEyeExtra(ownerModule, treeWindow.treeDisplay, treeWindow);		treeWindow.treeDisplay.addExtra(birdsEyeExtra); //TODO: need to remove later?	}	public int minWidth(){		int w = super.minWidth();		int w2 = paletteScroll.getBounds().width + recentButton.width + 20;		if (w< w2)			return w2;		return w;	}	public void setFieldSize(int width, int height){		if (treeWindow== null || birdsEyeBox == null)			return;		paletteScroll.setLocation((getWidth()-paletteScroll.totalWidth+RecentButton.width)/2, scrollHeight);		recentButton.setLocation(paletteScroll.getBounds().x-12, paletteScroll.getBounds().y);		int birdWidth = getWidth()-8; 		int birdHeight = height*birdWidth/width;		int deepest = getDeepestButton();		if (deepest>getBounds().height-8-birdHeight) { //need to shrink birdsEyeBox to fit			birdHeight = getBounds().height-8 - deepest;			birdWidth = width*birdHeight/height;		}		birdsEyeBox.setBounds(4, getBounds().height-8-birdHeight, birdWidth, birdHeight);	}	public void paint(Graphics g) { //^^^		if (MesquiteWindow.checkDoomed(this))			return;		super.paint(g);		g.setColor(Color.black);		g.drawString("Tree #", paletteScroll.getBounds().x, paletteScroll.getBounds().y-3);		MesquiteWindow.uncheckDoomed(this);	}	public void repaintBirdsEye(){		birdsEyeBox.repaint();	}	public void dispose(){		MesquiteWindow w = MesquiteWindow.windowOfItem(this);		if (w!=null)			w.waitUntilDisposable();		birdsEyeExtra.dispose();		birdsEyeBox.dispose();		treeWindow = null;		remove(paletteScroll);		remove(birdsEyeBox);		super.dispose();	}}/*===========================================*//*===========================================*/class BasicTreeStatisticsPanel extends TreeInfoExtraPanel {	StringInABox statsBox;	String treeStats = null;	int neededHeight = 20;	public BasicTreeStatisticsPanel(ClosablePanelContainer container){		super(container, "Basic Tree Stats");		statsBox =  new StringInABox("", null, 50);		open = true;	}	public void setTree(Tree tree){		super.setTree(tree);		//number of terminal taxa		//any polytomies		//zero length branches (but only if present)		//total path length		//branch lengths absent		adjustMessage();		container.requestHeightChange(this);		repaint();	}	public void setNode(int node){		super.setNode(node);		repaint();	}	void adjustMessage(){		if (tree == null)			treeStats = "no tree";		else {			int numTerms = tree.numberOfTerminalsInClade(tree.getRoot());			int numTermsTotal = tree.getTaxa().getNumTaxa();			if (numTermsTotal == numTerms)				treeStats = "All " + numTerms + " taxa included.\n";			else				treeStats = "" + numTerms + " of " + numTermsTotal + " taxa included.\n";			if (tree.hasPolytomies(tree.getRoot()))				treeStats += "Has polytomies.\n";			if (!tree.hasBranchLengths())				treeStats += "No branch lengths specified.\n";			else {			}		}	}	public int getRequestedHeight(int width){		if (!open)			return MINHEIGHT;		statsBox.setFont(getFont());		statsBox.setString(treeStats);		statsBox.setWidth(width-4);		neededHeight = statsBox.getHeight();		return neededHeight + MINHEIGHT;	}	public void paint(Graphics g){		super.paint(g);		//g.drawString("hello", 8, MINHEIGHT+20);		statsBox.setWidth(getBounds().width-4);		statsBox.setFont(g.getFont());		statsBox.setString(treeStats);		statsBox.draw(g,4, MINHEIGHT);	}}/*===========================================*/class BranchInfoPanel extends TreeInfoExtraPanel {	StringInABox statsBox;	String message = null;	int neededHeight = 20;	String attachmentsMessage = "";	Image query;	public BranchInfoPanel(ClosablePanelContainer container){		super(container, "Branch/Node Info");		query = MesquiteImage.getImage(MesquiteModule.getRootImageDirectoryPath() + "queryGray.gif");		statsBox =  new StringInABox("", null, 50);	}	public void setTree(Tree tree){		super.setTree(tree);		adjustMessage();		container.requestHeightChange(this);		repaint();	}	public void setNode(int node){		super.setNode(node);		adjustMessage();		container.requestHeightChange(this);		repaint();	}	private void adjustMessage(){		attachmentsMessage = "";		if (tree == null)			message = "no tree";		else {			message = "";			if (tree.nodeExists(node)){				if (!tree.branchLengthUnassigned(node))					attachmentsMessage += "Branch length: " + MesquiteDouble.toString(tree.getBranchLength(node)) + "\n";				for (int i=0; i<tree.getNumberAssociatedDoubles(); i++){					DoubleArray d = tree.getAssociatedDoubles(i);					NameReference nr = d.getNameReference();					attachmentsMessage += nr.getValue();					attachmentsMessage += ": " + MesquiteDouble.toString(d.getValue(node));					attachmentsMessage += "\n";				}				for (int i=0; i<tree.getNumberAssociatedLongs(); i++){					LongArray d = tree.getAssociatedLongs(i);					NameReference nr = d.getNameReference();					attachmentsMessage += nr.getValue();					attachmentsMessage += ": " + MesquiteLong.toString(d.getValue(node));					attachmentsMessage += "\n";				}				for (int i=0; i<tree.getNumberAssociatedObjects(); i++){					ObjectArray d = tree.getAssociatedObjects(i);					NameReference nr = d.getNameReference();					if (d.getValue(node) instanceof String){						attachmentsMessage += nr.getValue();						attachmentsMessage += ": " + (d.getValue(node));						attachmentsMessage += "\n";					}				}				if (StringUtil.blank(attachmentsMessage)) {					message = "\n ";				}				message += attachmentsMessage;			}		}	}	public int getRequestedHeight(int width){		if (!open)			return MINHEIGHT;		statsBox.setFont(getFont());		statsBox.setString(message);		statsBox.setWidth(width-4);		neededHeight = statsBox.getHeight();		return neededHeight + MINHEIGHT;	}	public void paint(Graphics g){		super.paint(g);		super.paint(g);		g.drawImage(query, getWidth()-20, 4, this);		statsBox.setWidth(getBounds().width-4);		statsBox.setFont(g.getFont());		statsBox.setString(message);		statsBox.draw(g,4, MINHEIGHT);	}	/* to be used by subclasses to tell that panel touched */	public void mouseUp(int modifiers, int x, int y, MesquiteTool tool) {		if (y<MINHEIGHT && (x> getWidth()- 20)) {			MesquiteTrunk.mesquiteTrunk.alert("Attachments:  Attachments to the tree or its nodes are pieces of information like branch lengths, lineage widths, assigned colors, and so on. Move cursor over nodes to see information attached there.");  //query button hit		}		else			super.mouseUp(modifiers,  x,  y,  tool);	}}/*===========================================*//* ======================================================================== */class TreeInfoPanel extends MousePanel implements ClosablePanelContainer {	static final int width = 200;	//static final int height = 66;	String title = null;	String explanation = null;	StringInABox titleBox, explanationBox;	int[] locs;	BasicTreeWindow w;	Image goaway;	Tree tree;	Vector extras = new Vector();	Font titleFont;	String treeName, sourceName;	boolean edited, storedTrees;	Image add = null;	BasicTreeStatisticsPanel btsp;	BranchInfoPanel ap;	public TreeInfoPanel (BasicTreeWindow w){		super();		this.w = w;		add = MesquiteImage.getImage(MesquiteModule.getRootImageDirectoryPath() + "addGray.gif");		setLayout(null);		addExtraPanel(btsp = new BasicTreeStatisticsPanel(this));		addExtraPanel(ap = new BranchInfoPanel(this));		setBackground(ColorDistribution.veryLightGray);		setFont(new Font("SansSerif", Font.PLAIN, 12));		titleFont = new Font("SansSerif", Font.BOLD, 12);		titleBox =  new StringInABox("", null, width);		explanationBox =  new StringInABox("", null, width);		goaway = MesquiteImage.getImage(MesquiteModule.getRootImageDirectoryPath() + "minimizeTransparent.gif");	}	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot temp = new Snapshot();		temp.addLine("btspOpen " + btsp.isOpen());		temp.addLine("apOpen " + ap.isOpen());		return temp;	}	public void employeeQuit(MesquiteModule m){		if (m == null)			return;		//zap values panel line	}	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Sets attachment panel open", null, commandName, "apOpen")) {			ap.setOpen(arguments == null || arguments.equalsIgnoreCase("true"));		}		else if (checker.compare(this.getClass(), "Sets the basic statistics panel open", null, commandName, "btspOpen")) {			btsp.setOpen(arguments == null || arguments.equalsIgnoreCase("true"));		}		else 			return  super.doCommand(commandName, arguments, checker);		return null;	}	public ClosablePanel getPrecedingPanel(ClosablePanel panel){		int i = extras.indexOf(panel);		if (i >0)			return (ClosablePanel)extras.elementAt(i-1);		return null;	}	void addExtraPanel(TreeInfoExtraPanel p){		extras.addElement(p);		add(p);		resetSizes(getWidth(), getHeight());		p.setVisible(true);		if (tree != null)			p.setTree(tree);	}	void setTree(Tree tree){		this.tree = tree;		title = "Tree: " + tree.getName();		for (int i = 0; i<extras.size(); i++){			TreeInfoExtraPanel panel = ((TreeInfoExtraPanel)extras.elementAt(i));			if (tree != null)				panel.setTree(tree);		}		setHighlighted(edited, storedTrees);	}	void taxonEnter(int it){		for (int i = 0; i<extras.size(); i++){			TreeInfoExtraPanel panel = ((TreeInfoExtraPanel)extras.elementAt(i));			panel.taxonEnter(it);		}	}	void taxonExit(int it){		for (int i = 0; i<extras.size(); i++){			TreeInfoExtraPanel panel = ((TreeInfoExtraPanel)extras.elementAt(i));			panel.taxonExit(it);		}	}	void taxonTouch(int it){		for (int i = 0; i<extras.size(); i++){			TreeInfoExtraPanel panel = ((TreeInfoExtraPanel)extras.elementAt(i));			panel.taxonTouch(it);		}	}	void branchEnter(int node){		for (int i = 0; i<extras.size(); i++){			TreeInfoExtraPanel panel = ((TreeInfoExtraPanel)extras.elementAt(i));			panel.branchEnter(node);		}	}	void branchExit(int node){		for (int i = 0; i<extras.size(); i++){			TreeInfoExtraPanel panel = ((TreeInfoExtraPanel)extras.elementAt(i));			panel.branchExit(node);		}	}	void branchTouch(int node){		for (int i = 0; i<extras.size(); i++){			TreeInfoExtraPanel panel = ((TreeInfoExtraPanel)extras.elementAt(i));			panel.branchTouch(node);		}	}	void setTreeAndSourceName(String treeName, String sourceName){		this.treeName = treeName;		this.sourceName = sourceName;		setHighlighted(edited, storedTrees);	}	public void setHighlighted(boolean edited, boolean storedTrees) {		this.storedTrees = storedTrees;		this.edited = edited;		if (edited && storedTrees)			title = "Tree: Modified from " + treeName;		else 			title = "Tree: " + treeName;		if (edited){			if (storedTrees)				explanation = "Tree is modified from one of the stored trees ";			else				explanation = "Tree has been edited; it is not directly from the tree source.";		}		else {			if (storedTrees)				explanation = "Tree is stored in the project.";			else				explanation = "Tree is not stored in the project.  The tree is from: " + sourceName;		}		resetSizes(getWidth(), getHeight());		repaint();	}	public void requestHeightChange(ClosablePanel panel){		resetSizes(getWidth(), getHeight());		repaint();	}	public void paint(Graphics g){		Color c = g.getColor();		int vertical = 2;		if (title != null){			g.setColor(ColorTheme.getInterfaceElement());			g.fillRect(0, 0, getBounds().width, titleBox.getHeight()+8);			g.setColor(ColorTheme.getInterfaceTextContrast());			titleBox.draw(g,20, vertical);			g.setColor(Color.black);			vertical += 8 + titleBox.getHeight();		}		g.drawImage(goaway, 2, 2, this);		g.drawLine(0, vertical-4, getBounds().width, vertical-4);		if (explanation != null){			g.setColor(Color.white);			g.fillRect(0, vertical, getBounds().width, 8 + explanationBox.getHeight());			g.setColor(Color.black);			explanationBox.draw(g,4, vertical);			vertical += 8 + explanationBox.getHeight();		}		g.setColor(Color.darkGray);		g.fillRect(0, totalVertical, getBounds().width, 2);		//WHEN CALCULATIONS CAN BE ADDED		//	g.drawImage(add, 2, totalVertical+4, this);		g.setColor(c);	}	int totalVertical = 0;	/* to be used by subclasses to tell that panel touched */	public void mouseDown (int modifiers, int clickCount, long when, int x, int y, MesquiteTool tool) {		if (x<30 && y > totalVertical+4 && y < totalVertical + 20){			//WHEN CALCULATIONS CAN BE ADDED			//MesquiteTrunk.mesquiteTrunk.alert("Sorry, doesn't do anything yet");		}	}	/* to be used by subclasses to tell that panel touched */	public void mouseUp(int modifiers, int x, int y, MesquiteTool tool) {		if (x< 16 && y<16)			w.treeInfoPanelGoAway();	}	void resetSizes(int w, int h){		int vertical = 2;		if (title != null){			titleBox.setWidth(w-20);			titleBox.setFont(titleFont);			titleBox.setString(title);			vertical += 8 + titleBox.getHeight();		}		if (explanation != null){			explanationBox.setWidth(w-4);			explanationBox.setFont(getFont());			explanationBox.setString(explanation);			vertical += 8 + explanationBox.getHeight();		}		for (int i = 0; i<extras.size(); i++){			ClosablePanel panel = ((ClosablePanel)extras.elementAt(i));			int requestedlHeight = panel.getRequestedHeight(w);			panel.setBounds(0, vertical, w, requestedlHeight);			vertical += requestedlHeight;		}		totalVertical = vertical;	}	public void setBounds(int x, int y, int w, int h){		super.setBounds(x,y,w,h);		resetSizes(w, h);	}	public void setSize(int w, int h){		super.setSize(w,h);		resetSizes(w, h);	}}/* ======================================================================== *//* scrollbar for tree */class TreeScroll extends MesquiteScrollbar {	BasicTreeWindow basicTreeWindow;	public TreeScroll (BasicTreeWindow basicTreeWindow, int orientation, int value, int visible, int min, int max){		super(orientation, value, visible, min, max);		this.basicTreeWindow=basicTreeWindow;	}	public void scrollTouched() {		int currentValue = getValue();	}	public void dispose(){		basicTreeWindow = null;		//super.dispose();	}}/* ======================================================================== */class BirdsEyeExtra extends TreeDisplayExtra {	BasicTreeWindow treeWindow;	public BirdsEyeExtra (MesquiteModule ownerModule, TreeDisplay treeDisplay, BasicTreeWindow treeWindow) {		super(ownerModule, treeDisplay);		this.treeWindow = treeWindow;	}	/*.................................................................................................................*/	public   void drawOnTree(Tree tree, int drawnRoot, Graphics g) {		if (!treeWindow.sizeToFit.getValue())			treeWindow.palette.birdsEyeBox.repaint();	}	public   void setTree(Tree tree) {	}	public   void printOnTree(Tree tree, int drawnRoot, Graphics g) {	}	public void dispose(){		treeWindow = null;		super.dispose();	}}/* ======================================================================== */class MagnifyExtra extends TreeDisplayExtra {	Image image;	String name = "";	public MagnifyExtra (MesquiteModule ownerModule, TreeDisplay treeDisplay, TreeTool tool) {		super(ownerModule, treeDisplay);		image = MesquiteImage.getImage(tool.getImagePath());	}	/*.................................................................................................................*/	public   void drawOnTree(Tree tree, int drawnRoot, Graphics g) {		if (drawnRoot!= tree.getRoot()) {			TreeDrawing td = treeDisplay.getTreeDrawing();			g.drawImage(image, td.x[drawnRoot], td.y[drawnRoot], treeDisplay);		}	}	public   void setTree(Tree tree) {	}	/** Returns any strings to be appended to taxon name.*/	public String getTaxonStringAddition(Taxon taxon){		Taxa taxa = taxon.getTaxa();		int which = taxa.whichTaxonNumber(taxon);		String s = taxa.getAnnotation(which);		if (!StringUtil.blank(s))			return "*";		return null;	}	public   void printOnTree(Tree tree, int drawnRoot, Graphics g) {		if (name!=null)			g.drawString(name, 50, treeDisplay.getBounds().height - 20);	}}/* ======================================================================== */class BirdsEyePanel extends MesquitePanel {	TreeDrawing treeDrawing;	BasicTreeWindow treeWindow;	int offsetX = 0;	int offsetY=0;	int origTouchX, origTouchY, dragOffsetX, dragOffsetY;	int rootX, rootY;	Rectangle vis;	public BirdsEyePanel (BasicTreeWindow treeWindow, TreeDrawing treeDrawing) {		this.treeDrawing=treeDrawing;		this.treeWindow = treeWindow;		setBackground(ColorTheme.getInterfaceBackgroundPale());		vis = new Rectangle();	}	public void dispose(){		treeWindow = null;		treeDrawing = null;		//super.dispose();	}	public void sketchTree(Tree tree, int N, Graphics g) {		int nodeX=getTransformedX(N);		int nodeY=getTransformedY(N);		for (int d = tree.firstDaughterOfNode(N); tree.nodeExists(d); d = tree.nextSisterOfNode(d)) {			int daughterX=getTransformedX(d);			int daughterY=getTransformedY(d);			g.drawLine(nodeX, nodeY, daughterX, daughterY);			sketchTree(tree, d, g);		}	}	public void setFieldSize(int width, int height){	}	private int getTransformedX(int node){		return getBounds().width *treeDrawing.x[node] /(treeWindow.treeDisplay.getFieldWidth());	}	private int getTransformedY(int node){		return getBounds().height *treeDrawing.y[node] /(treeWindow.treeDisplay.getFieldHeight());	}	public void paint(Graphics g) {		if (treeWindow == null || treeWindow.treeDisplay == null)			return;		if (MesquiteWindow.checkDoomed(this))			return;		Tree tree = treeWindow.treeDisplay.getTree();		if (tree == null){			MesquiteWindow.uncheckDoomed(this);			return;		}		treeDrawing = treeWindow.treeDisplay.getTreeDrawing();		int drawnRoot = treeDrawing.getDrawnRoot();		if (tree != null && !tree.nodeExists(drawnRoot))			drawnRoot = tree.getRoot();		g.setColor(Color.white);		rootX=getTransformedX(drawnRoot);		rootY=getTransformedY(drawnRoot);		int oX = -treeWindow.getOriginX();		int oY = -treeWindow.getOriginY();		vis.x=getBounds().width *oX /(treeWindow.treeDisplay.getFieldWidth());		vis.y=getBounds().height *oY /(treeWindow.treeDisplay.getFieldHeight());		if (treeWindow.treePane==null) {			vis.width = getBounds().width*treeWindow.treeDisplay.getBounds().width/(treeWindow.treeDisplay.getFieldWidth());			vis.height = getBounds().height*treeWindow.treeDisplay.getBounds().height/(treeWindow.treeDisplay.getFieldHeight());		}		else {			vis.width = getBounds().width*treeWindow.treePane.getBounds().width/(treeWindow.treeDisplay.getFieldWidth());			vis.height = getBounds().height*treeWindow.treePane.getBounds().height/(treeWindow.treeDisplay.getFieldHeight());		}		g.fillRoundRect(vis.x, vis.y, vis.width, vis.height, 8, 8);		g.setColor(Color.gray);		sketchTree(tree, drawnRoot, g);		g.setColor(Color.black);		g.drawRoundRect(vis.x, vis.y, vis.width, vis.height,8,8);		g.drawRect(0,0, getBounds().width-1, getBounds().height-1);		g.drawRect(1,1, getBounds().width-3, getBounds().height-3);		MesquiteWindow.uncheckDoomed(this);	}	public void mouseDrag (int modifiers, int x, int y, MesquiteTool tool) {		if (MesquiteWindow.checkDoomed(this))			return;		Graphics g = null;		if (GraphicsUtil.useXORMode(null, false)){			g=getGraphics();			g.setXORMode(Color.white);			g.setColor(Color.green);			g.drawRoundRect(vis.x + dragOffsetX, vis.y + dragOffsetY, vis.width, vis.height, 8 ,8);		}		dragOffsetX=x-origTouchX;		dragOffsetY=y-origTouchY;		if (GraphicsUtil.useXORMode(null, false)){			g.drawRoundRect(vis.x + dragOffsetX, vis.y + dragOffsetY, vis.width, vis.height, 8 ,8);			g.dispose();		}		MesquiteWindow.uncheckDoomed(this);	}	public void mouseDown (int modifiers, int clickCount, long when, int x, int y, MesquiteTool tool) {		if (MesquiteWindow.checkDoomed(this))			return;		origTouchX=x;		origTouchY=y;		dragOffsetX=0;		dragOffsetY=0;		if (GraphicsUtil.useXORMode(null, false)){					Graphics g=getGraphics();			g.setXORMode(Color.white);			g.setColor(Color.green);			g.drawRoundRect(vis.x, vis.y, vis.width, vis.height, 8 ,8);			g.dispose();		}		MesquiteWindow.uncheckDoomed(this);	}	public void mouseUp (int modifiers, int x, int y, MesquiteTool tool) {		if (MesquiteWindow.checkDoomed(this))			return;		offsetX=offsetX + dragOffsetX;		offsetY=offsetY + dragOffsetY;		if (GraphicsUtil.useXORMode(null, false)){			Graphics g=getGraphics();			g.setXORMode(Color.white);			g.setColor(Color.green);			g.drawRoundRect(vis.x + dragOffsetX, vis.y + dragOffsetY, vis.width, vis.height, 8, 8);			g.setPaintMode();			g.dispose();		}		int oX = (vis.x + dragOffsetX)*(treeWindow.treeDisplay.getFieldWidth())/(getBounds().width);		int oY = (vis.y + dragOffsetY)*(treeWindow.treeDisplay.getFieldHeight())/(getBounds().height);		if (oX<0)			oX=0;		if (oY<0)			oY=0;		treeWindow.setOrigin(-oX,-oY);		treeWindow.treeDisplay.pleaseUpdate(true);		repaint();		MesquiteWindow.uncheckDoomed(this);	}}